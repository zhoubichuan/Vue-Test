---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 四.案例4

## 1.垄断一体化

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      control: { MousePosition },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style, Text },
      interaction: { Draw, Snap },
      geom: { LineString, Point, Polygon },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })

    const nodes = new VectorSource({ wrapX: false })
    const nodesLayer = new VectorLayer({
      source: nodes,
      style: function (f) {
        const style = new Style({
          image: new CircleStyle({
            radius: 8,
            fill: new Fill({ color: "rgba(255, 0, 0, 0.2)" }),
            stroke: new Stroke({ color: "red", width: 1 }),
          }),
          text: new Text({
            text: f.get("node").id.toString(),
            fill: new Fill({ color: "red" }),
            stroke: new Stroke({
              color: "white",
              width: 3,
            }),
          }),
        })
        return [style]
      },
    })

    const edges = new VectorSource({ wrapX: false })
    const edgesLayer = new VectorLayer({
      source: edges,
      style: function (f) {
        const style = new Style({
          stroke: new Stroke({
            color: "blue",
            width: 1,
          }),
          text: new Text({
            text: f.get("edge").id.toString(),
            fill: new Fill({ color: "blue" }),
            stroke: new Stroke({
              color: "white",
              width: 2,
            }),
          }),
        })
        return [style]
      },
    })

    const faces = new VectorSource({ wrapX: false })
    const facesLayer = new VectorLayer({
      source: faces,
      style: function (f) {
        const style = new Style({
          stroke: new Stroke({
            color: "black",
            width: 1,
          }),
          fill: new Fill({
            color: "rgba(0, 255, 0, 0.2)",
          }),
          text: new Text({
            font: "bold 12px sans-serif",
            text: f.get("face").id.toString(),
            fill: new Fill({ color: "green" }),
            stroke: new Stroke({
              color: "white",
              width: 2,
            }),
          }),
        })
        return [style]
      },
    })

    const map = new Map({
      layers: [raster, facesLayer, edgesLayer, nodesLayer],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 16,
      }),
    })

    const topo = topolis.createTopology()

    topo.on("addnode", nodeToFeature)
    topo.on("removenode", function (e) {
      removeElementFeature(nodes, e)
    })
    topo.on("addedge", edgeToFeature)
    topo.on("modedge", function (e) {
      const feature = edges.getFeatureById(e.id)
      feature.setGeometry(new LineString(e.coordinates))
    })
    topo.on("removeedge", function (e) {
      removeElementFeature(edges, e)
    })
    topo.on("addface", faceToFeature)
    topo.on("removeface", function (e) {
      removeElementFeature(faces, e)
    })

    function removeElementFeature(source, element) {
      const feature = source.getFeatureById(element.id)
      source.removeFeature(feature)
    }

    function nodeToFeature(node) {
      const feature = new Feature({
        geometry: new Point(node.coordinate),
        node: node,
      })
      feature.setId(node.id)
      nodes.addFeature(feature)
    }

    function edgeToFeature(edge) {
      const feature = new Feature({
        geometry: new LineString(edge.coordinates),
        edge: edge,
      })
      feature.setId(edge.id)
      edges.addFeature(feature)
    }

    function faceToFeature(face) {
      const coordinates = topo.getFaceGeometry(face)
      const feature = new Feature({
        geometry: new Polygon(coordinates),
        face: face,
      })
      feature.setId(face.id)
      faces.addFeature(feature)
    }

    function createNode(topo, coord) {
      let node
      const existingEdge = topo.getEdgeByPoint(coord, 5)[0]
      if (existingEdge) {
        node = topo.modEdgeSplit(existingEdge, coord)
      } else {
        node = topo.addIsoNode(coord)
      }
      return node
    }

    function onDrawend(e) {
      const edgeGeom = e.feature.getGeometry().getCoordinates()
      const startCoord = edgeGeom[0]
      const endCoord = edgeGeom[edgeGeom.length - 1]
      let start, end
      try {
        start = topo.getNodeByPoint(startCoord)
        end = topo.getNodeByPoint(endCoord)
        const edgesAtStart = topo.getEdgeByPoint(startCoord, 5)
        const edgesAtEnd = topo.getEdgeByPoint(endCoord, 5)
        const crossing = topo.getEdgesByLine(edgeGeom)
        if (
          crossing.length === 1 &&
          !start &&
          !end &&
          edgesAtStart.length === 0 &&
          edgesAtEnd.length === 0
        ) {
          topo.remEdgeNewFace(crossing[0])
          start = crossing[0].start
          if (start.face) {
            topo.removeIsoNode(start)
          }
          end = crossing[0].end
          if (end.face) {
            topo.removeIsoNode(end)
          }
          return
        }
        if (!start) {
          start = createNode(topo, startCoord)
          edgeGeom[0] = start.coordinate
        }
        if (!end) {
          end = createNode(topo, endCoord)
          edgeGeom[edgeGeom.length - 1] = end.coordinate
        }
        topo.addEdgeNewFaces(start, end, edgeGeom)
      } catch (e) {
        toastr.warning(e.toString())
      }
    }

    const draw = new Draw({
      type: "LineString",
    })
    draw.on("drawend", onDrawend)
    map.addInteraction(draw)
    const snap = new Snap({
      source: edges,
    })
    map.addInteraction(snap)
    map.addControl(new MousePosition())
  },
}
</script>
```

:::

## 2.追踪多边形

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">Geometry type &nbsp;</label>
    <select id="type">
      <option value="Polygon">Polygon</option>
      <option value="LineString">LineString</option>
      <option value="None">None</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      interaction: { Draw, Snap },
      geom: { LineString },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Fill, Stroke, Style },
      format: { GeoJSON },
    } = ol
    function length(a, b) {
      return Math.sqrt(
        (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
      )
    }

    // coordinates; will return true if c is on the [a, b] segment
    function isOnSegment(c, a, b) {
      const lengthAc = length(a, c)
      const lengthAb = length(a, b)
      const dot =
        ((c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])) /
        lengthAb
      return Math.abs(lengthAc - dot) < 1e-6 && lengthAc < lengthAb
    }

    // modulo for negative values, eg: mod(-1, 4) returns 3
    function mod(a, b) {
      return ((a % b) + b) % b
    }

    // returns a coordinates array which contains the segments of the feature's
    // outer ring between the start and end points
    // Note: this assumes the base feature is a single polygon
    function getPartialRingCoords(feature, startPoint, endPoint) {
      let polygon = feature.getGeometry()
      if (polygon.getType() === "MultiPolygon") {
        polygon = polygon.getPolygon(0)
      }
      const ringCoords = polygon.getLinearRing().getCoordinates()

      let i,
        pointA,
        pointB,
        startSegmentIndex = -1
      for (i = 0; i < ringCoords.length; i++) {
        pointA = ringCoords[i]
        pointB = ringCoords[mod(i + 1, ringCoords.length)]

        // check if this is the start segment dot product
        if (isOnSegment(startPoint, pointA, pointB)) {
          startSegmentIndex = i
          break
        }
      }

      const cwCoordinates = []
      let cwLength = 0
      const ccwCoordinates = []
      let ccwLength = 0

      // build clockwise coordinates
      for (i = 0; i < ringCoords.length; i++) {
        pointA =
          i === 0
            ? startPoint
            : ringCoords[mod(i + startSegmentIndex, ringCoords.length)]
        pointB = ringCoords[mod(i + startSegmentIndex + 1, ringCoords.length)]
        cwCoordinates.push(pointA)

        if (isOnSegment(endPoint, pointA, pointB)) {
          cwCoordinates.push(endPoint)
          cwLength += length(pointA, endPoint)
          break
        } else {
          cwLength += length(pointA, pointB)
        }
      }

      // build counter-clockwise coordinates
      for (i = 0; i < ringCoords.length; i++) {
        pointA = ringCoords[mod(startSegmentIndex - i, ringCoords.length)]
        pointB =
          i === 0
            ? startPoint
            : ringCoords[mod(startSegmentIndex - i + 1, ringCoords.length)]
        ccwCoordinates.push(pointB)

        if (isOnSegment(endPoint, pointA, pointB)) {
          ccwCoordinates.push(endPoint)
          ccwLength += length(endPoint, pointB)
          break
        } else {
          ccwLength += length(pointA, pointB)
        }
      }

      // keep the shortest path
      return ccwLength < cwLength ? ccwCoordinates : cwCoordinates
    }

    // layers definition

    const raster = new TileLayer({
      source: new OSM(),
    })

    // features in this layer will be snapped to
    const baseVector = new VectorLayer({
      source: new VectorSource({
        format: new GeoJSON(),
        url: "https://ahocevar.com/geoserver/wfs?service=wfs&request=getfeature&typename=topp:states&cql_filter=STATE_NAME='Idaho'&outputformat=application/json",
      }),
    })

    // this is were the drawn features go
    const drawVector = new VectorLayer({
      source: new VectorSource(),
      style: new Style({
        stroke: new Stroke({
          color: "rgba(100, 255, 0, 1)",
          width: 2,
        }),
        fill: new Fill({
          color: "rgba(100, 255, 0, 0.3)",
        }),
      }),
    })

    // this line only appears when we're tracing a feature outer ring
    const previewLine = new Feature({
      geometry: new LineString([]),
    })
    const previewVector = new VectorLayer({
      source: new VectorSource({
        features: [previewLine],
      }),
      style: new Style({
        stroke: new Stroke({
          color: "rgba(255, 0, 0, 1)",
          width: 2,
        }),
      }),
    })

    const map = new Map({
      layers: [raster, baseVector, drawVector, previewVector],
      target: this.$refs.map,
      view: new View({
        center: [-12986427, 5678422],
        zoom: 5,
      }),
    })

    let drawInteraction, tracingFeature, startPoint, endPoint
    let drawing = false

    const getFeatureOptions = {
      hitTolerance: 10,
      layerFilter: (layer) => {
        return layer === baseVector
      },
    }

    // the click event is used to start/end tracing around a feature
    map.on("click", (event) => {
      if (!drawing) {
        return
      }

      let hit = false
      map.forEachFeatureAtPixel(
        event.pixel,
        (feature) => {
          if (tracingFeature && feature !== tracingFeature) {
            return
          }

          hit = true
          const coord = map.getCoordinateFromPixel(event.pixel)

          // second click on the tracing feature: append the ring coordinates
          if (feature === tracingFeature) {
            endPoint = tracingFeature.getGeometry().getClosestPoint(coord)
            const appendCoords = getPartialRingCoords(
              tracingFeature,
              startPoint,
              endPoint
            )
            drawInteraction.removeLastPoint()
            drawInteraction.appendCoordinates(appendCoords)
            tracingFeature = null
          }

          // start tracing on the feature ring
          tracingFeature = feature
          startPoint = tracingFeature.getGeometry().getClosestPoint(coord)
        },
        getFeatureOptions
      )

      if (!hit) {
        // clear current tracing feature & preview
        previewLine.getGeometry().setCoordinates([])
        tracingFeature = null
      }
    })

    // the pointermove event is used to show a preview of the result of the tracing
    map.on("pointermove", (event) => {
      if (tracingFeature && drawing) {
        let coord = null
        map.forEachFeatureAtPixel(
          event.pixel,
          (feature) => {
            if (tracingFeature === feature) {
              coord = map.getCoordinateFromPixel(event.pixel)
            }
          },
          getFeatureOptions
        )

        let previewCoords = []
        if (coord) {
          endPoint = tracingFeature.getGeometry().getClosestPoint(coord)
          previewCoords = getPartialRingCoords(
            tracingFeature,
            startPoint,
            endPoint
          )
        }
        previewLine.getGeometry().setCoordinates(previewCoords)
      }
    })

    const snapInteraction = new Snap({
      source: baseVector.getSource(),
    })

    const typeSelect = document.getElementById("type")

    function addInteraction() {
      const value = typeSelect.value
      if (value !== "None") {
        drawInteraction = new Draw({
          source: drawVector.getSource(),
          type: typeSelect.value,
        })
        drawInteraction.on("drawstart", () => {
          drawing = true
        })
        drawInteraction.on("drawend", () => {
          drawing = false
          previewLine.getGeometry().setCoordinates([])
          tracingFeature = null
        })
        map.addInteraction(drawInteraction)
        map.addInteraction(snapInteraction)
      }
    }

    typeSelect.onchange = function () {
      map.removeInteraction(drawInteraction)
      map.removeInteraction(snapInteraction)
      addInteraction()
    }
    addInteraction()
  },
}
</script>
```

:::

## 3.翻译功能

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      interaction: { Select, Translate, defaults: defaultInteractions },
      proj: { fromLonLat },
    } = ol

    const vector = new VectorLayer({
      background: "white",
      source: new VectorSource({
        url: "https://openlayers.org/data/vector/us-states.json",
        format: new GeoJSON(),
      }),
    })

    const select = new Select()

    const translate = new Translate({
      features: select.getFeatures(),
    })

    const map = new Map({
      interactions: defaultInteractions().extend([select, translate]),
      layers: [vector],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-100, 38.5]),
        zoom: 4,
      }),
    })
  },
}
</script>
```

:::

## 4.turf.js

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      proj: { fromLonLat },
    } = ol
    const source = new VectorSource()
    fetch(this.$withBase("/data/geojson/roads-seoul.geojson"))
      .then(function (response) {
        return response.json()
      })
      .then(function (json) {
        const format = new GeoJSON()
        const features = format.readFeatures(json)
        const street = features[0]

        // convert to a turf.js feature
        const turfLine = format.writeFeatureObject(street)

        // show a marker every 200 meters
        const distance = 0.2

        // get the line length in kilometers
        const length = turf.lineDistance(turfLine, "kilometers")
        for (let i = 1; i <= length / distance; i++) {
          const turfPoint = turf.along(turfLine, i * distance, "kilometers")

          // convert the generated point to a OpenLayers feature
          const marker = format.readFeature(turfPoint)
          marker.getGeometry().transform("EPSG:4326", "EPSG:3857")
          source.addFeature(marker)
        }

        street.getGeometry().transform("EPSG:4326", "EPSG:3857")
        source.addFeature(street)
      })
    const vectorLayer = new VectorLayer({
      source: source,
    })

    const rasterLayer = new TileLayer({
      source: new OSM(),
    })

    const map = new Map({
      layers: [rasterLayer, vectorLayer],
      target: document.getElementById("map"),
      view: new View({
        center: fromLonLat([126.980366, 37.52654]),
        zoom: 15,
      }),
    })
  },
}
</script>
```

:::

## 5.UTFGrid

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div style="display: none;">
    <div id="country-info">
      <div id="country-name">&nbsp;</div>
      <img id="country-flag" />
    </div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Overlay,
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { TileJSON, UTFGrid },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"

    const mapLayer = new TileLayer({
      source: new TileJSON({
        url:
          "https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=" +
          key,
      }),
    })

    const gridSource = new UTFGrid({
      url:
        "https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=" +
        key,
    })

    const gridLayer = new TileLayer({ source: gridSource })

    const view = new View({
      center:[12579156, 3274244],
      zoom: 1,
    })

    const mapElement = document.getElementById("map")
    const map = new Map({
      layers: [mapLayer, gridLayer],
      target: mapElement,
      view: view,
    })

    const infoElement = document.getElementById("country-info")
    const flagElement = document.getElementById("country-flag")
    const nameElement = document.getElementById("country-name")

    const infoOverlay = new Overlay({
      element: infoElement,
      offset: [15, 15],
      stopEvent: false,
    })
    map.addOverlay(infoOverlay)

    const displayCountryInfo = function (coordinate) {
      const viewResolution = /** @type {number} */ (view.getResolution())
      gridSource.forDataAtCoordinateAndResolution(
        coordinate,
        viewResolution,
        function (data) {
          // If you want to use the template from the TileJSON,
          //  load the mustache.js library separately and call
          //  info.innerHTML = Mustache.render(gridSource.getTemplate(), data);
          mapElement.style.cursor = data ? "pointer" : ""
          if (data) {
            flagElement.src = "data:image/png;base64," + data["flag_png"]
            nameElement.innerHTML = data["admin"]
          }
          infoOverlay.setPosition(data ? coordinate : undefined)
        }
      )
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const coordinate = map.getEventCoordinate(evt.originalEvent)
      displayCountryInfo(coordinate)
    })

    map.on("click", function (evt) {
      displayCountryInfo(evt.coordinate)
    })
  },
}
</script>
```

:::
