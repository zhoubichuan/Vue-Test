---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十五.自定义类型

## 1.区域增长

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <label class="input-group">
      Threshold:
      <input id="threshold" type="range" min="1" max="50" value="20" />
      <span id="threshold-value"></span>
    </label>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Raster: RasterSource },
      proj: { fromLonLat },
    } = ol

    function growRegion(inputs, data) {
      const image = inputs[0]
      let seed = data.pixel
      const delta = parseInt(data.delta)
      if (!seed) {
        return image
      }

      seed = seed.map(Math.round)
      const width = image.width
      const height = image.height
      const inputData = image.data
      const outputData = new Uint8ClampedArray(inputData)
      const seedIdx = (seed[1] * width + seed[0]) * 4
      const seedR = inputData[seedIdx]
      const seedG = inputData[seedIdx + 1]
      const seedB = inputData[seedIdx + 2]
      let edge = [seed]
      while (edge.length) {
        const newedge = []
        for (let i = 0, ii = edge.length; i < ii; i++) {
          // As noted in the Raster source constructor, this function is provided
          // using the `lib` option. Other functions will NOT be visible unless
          // provided using the `lib` option.
          const next = next4Edges(edge[i])
          for (let j = 0, jj = next.length; j < jj; j++) {
            const s = next[j][0]
            const t = next[j][1]
            if (s >= 0 && s < width && t >= 0 && t < height) {
              const ci = (t * width + s) * 4
              const cr = inputData[ci]
              const cg = inputData[ci + 1]
              const cb = inputData[ci + 2]
              const ca = inputData[ci + 3]
              // if alpha is zero, carry on
              if (ca === 0) {
                continue
              }
              if (
                Math.abs(seedR - cr) < delta &&
                Math.abs(seedG - cg) < delta &&
                Math.abs(seedB - cb) < delta
              ) {
                outputData[ci] = 255
                outputData[ci + 1] = 0
                outputData[ci + 2] = 0
                outputData[ci + 3] = 255
                newedge.push([s, t])
              }
              // mark as visited
              inputData[ci + 3] = 0
            }
          }
        }
        edge = newedge
      }
      return { data: outputData, width: width, height: height }
    }

    function next4Edges(edge) {
      const x = edge[0]
      const y = edge[1]
      return [
        [x + 1, y],
        [x - 1, y],
        [x, y + 1],
        [x, y - 1],
      ]
    }

    const key = "Get your own API key at https://www.maptiler.com/cloud/"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const imagery = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })

    const raster = new RasterSource({
      sources: [imagery.getSource()],
      operationType: "image",
      operation: growRegion,
      // Functions in the `lib` object will be available to the operation run in
      // the web worker.
      lib: {
        next4Edges: next4Edges,
      },
    })

    const rasterImage = new ImageLayer({
      opacity: 0.7,
      source: raster,
    })

    const map = new Map({
      layers: [imagery, rasterImage],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-119.07, 47.65]),
        zoom: 11,
      }),
    })

    let coordinate

    map.on("click", function (event) {
      coordinate = event.coordinate
      raster.changed()
    })

    const thresholdControl = document.getElementById("threshold")

    raster.on("beforeoperations", function (event) {
      // the event.data object will be passed to operations
      const data = event.data
      data.delta = thresholdControl.value
      if (coordinate) {
        data.pixel = map.getPixelFromCoordinate(coordinate)
      }
    })

    function updateControlValue() {
      document.getElementById("threshold-value").innerText =
        thresholdControl.value
    }
    updateControlValue()

    const listener = function () {
      updateControlValue()
      raster.changed()
    }
    thresholdControl.addEventListener("input", listener)
    thresholdControl.addEventListener("change", listener)
  },
}
</script>
```

:::

## 2.常规形状

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Point },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: { Fill, RegularShape, Stroke, Style },
    } = ol

    const stroke = new Stroke({ color: "black", width: 2 })
    const fill = new Fill({ color: "red" })

    const styles = {
      square: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 4,
          radius: 10,
          angle: Math.PI / 4,
        }),
      }),
      rectangle: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          radius: 10 / Math.SQRT2,
          radius2: 10,
          points: 4,
          angle: 0,
          scale: [1, 0.5],
        }),
      }),
      triangle: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 3,
          radius: 10,
          rotation: Math.PI / 4,
          angle: 0,
        }),
      }),
      star: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 5,
          radius: 10,
          radius2: 4,
          angle: 0,
        }),
      }),
      cross: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 4,
          radius: 10,
          radius2: 0,
          angle: 0,
        }),
      }),
      x: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 4,
          radius: 10,
          radius2: 0,
          angle: Math.PI / 4,
        }),
      }),
      stacked: [
        new Style({
          image: new RegularShape({
            fill: fill,
            stroke: stroke,
            points: 4,
            radius: 5,
            angle: Math.PI / 4,
            displacement: [0, 10],
          }),
        }),
        new Style({
          image: new RegularShape({
            fill: fill,
            stroke: stroke,
            points: 4,
            radius: 10,
            angle: Math.PI / 4,
          }),
        }),
      ],
    }

    const styleKeys = [
      "x",
      "cross",
      "star",
      "triangle",
      "square",
      "rectangle",
      "stacked",
    ]
    const count = 250
    const features = new Array(count)
    const e = 4500000
    for (let i = 0; i < count; ++i) {
      const coordinates = [2 * e * Math.random() - e, 2 * e * Math.random() - e]
      features[i] = new Feature(new Point(coordinates))
      features[i].setStyle(
        styles[styleKeys[Math.floor(Math.random() * styleKeys.length)]]
      )
    }

    const source = new VectorSource({
      features: features,
    })

    const vectorLayer = new VectorLayer({
      source: source,
    })

    const map = new Map({
      layers: [vectorLayer],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 3.渲染几何形状到画布

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { LineString, Point, Polygon },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      render: { toContext },
    } = ol

    const canvas = document.getElementById("canvas")
    const vectorContext = toContext(canvas.getContext("2d"), {
      size: [100, 100],
    })

    const fill = new Fill({ color: "blue" })
    const stroke = new Stroke({ color: "black" })
    const style = new Style({
      fill: fill,
      stroke: stroke,
      image: new CircleStyle({
        radius: 10,
        fill: fill,
        stroke: stroke,
      }),
    })
    vectorContext.setStyle(style)

    vectorContext.drawGeometry(
      new LineString([
        [10, 10],
        [90, 90],
      ])
    )
    vectorContext.drawGeometry(
      new Polygon([
        [
          [2, 2],
          [98, 2],
          [2, 98],
          [2, 2],
        ],
      ])
    )
    vectorContext.drawGeometry(new Point([88, 88]))
  },
}
</script>
```

:::

## 4.渲染 16 位 NumpyTiles

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <h5>Contrast stretch</h5>
    <ul>
      <li>
        Min <input type="range" min="1000" max="10000" id="input-min" />
        <span id="output-min"></span>
      </li>
      <li>
        Max <input type="range" min="10000" max="50000" id="input-max" />
        <span id="output-max"></span>
      </li>
    </ul>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { WebGLTile: TileLayer },
      source: { DataTile: DataTileSource },
      proj: { fromLonLat },
    } = ol
    // 16-bit COG
    // Which will be served as NumpyTiles.
    const COG =
      "https://storage.googleapis.com/open-cogs/stac-examples/20201211_223832_CS2_analytic.tif"

    function numpyTileLoader(z, x, y) {
      const url = `https://api.cogeo.xyz/cog/tiles/WebMercatorQuad/${z}/${x}/${y}@1x?format=npy&url=${encodeURIComponent(
        COG
      )}`

      return fetch(url)
        .then((r) => r.arrayBuffer())
        .then((buffer) => NumpyLoader.fromArrayBuffer(buffer))
        .then((numpyData) => {
          // flatten the numpy data
          const dataTile = new Float32Array(256 * 256 * 5)
          const bandSize = 256 * 256
          for (let x = 0; x < 256; x++) {
            for (let y = 0; y < 256; y++) {
              const px = x + y * 256
              dataTile[px * 5 + 0] = numpyData.data[y * 256 + x]
              dataTile[px * 5 + 1] = numpyData.data[bandSize + y * 256 + x]
              dataTile[px * 5 + 2] = numpyData.data[bandSize * 2 + y * 256 + x]
              dataTile[px * 5 + 3] = numpyData.data[bandSize * 3 + y * 256 + x]
              dataTile[px * 5 + 4] =
                numpyData.data[bandSize * 4 + y * 256 + x] > 0 ? 1.0 : 0
            }
          }
          return dataTile
        })
    }

    const interpolateBand = (bandIdx) => [
      "interpolate",
      ["linear"],
      ["band", bandIdx],
      ["var", "bMin"],
      0,
      ["var", "bMax"],
      1,
    ]

    const initialMin = 3000
    const initialMax = 18000

    const numpyLayer = new TileLayer({
      style: {
        color: [
          "array",
          interpolateBand(3),
          interpolateBand(2),
          interpolateBand(1),
          ["band", 5],
        ],
        variables: {
          bMin: initialMin,
          bMax: initialMax,
        },
      },
      source: new DataTileSource({
        loader: numpyTileLoader,
        bandCount: 5,
      }),
    })

    const map = new Map({
      target: this.$refs.map,
      layers: [numpyLayer],
      view: new View({
        center: fromLonLat([172.933, 1.3567]),
        zoom: 15,
      }),
    })

    const inputMin = document.getElementById("input-min")
    const inputMax = document.getElementById("input-max")
    const outputMin = document.getElementById("output-min")
    const outputMax = document.getElementById("output-max")

    const handleMin = (evt) => {
      numpyLayer.updateStyleVariables({
        bMin: parseFloat(evt.target.value),
        bMax: parseFloat(inputMax.value),
      })
      outputMin.innerText = evt.target.value
    }
    inputMin.addEventListener("input", handleMin)
    inputMin.addEventListener("change", handleMin)

    const handleMax = (evt) => {
      numpyLayer.updateStyleVariables({
        bMin: parseFloat(inputMin.value),
        bMax: parseFloat(evt.target.value),
      })
      outputMax.innerText = evt.target.value
    }
    inputMax.addEventListener("input", handleMax)
    inputMax.addEventListener("change", handleMax)

    inputMin.value = initialMin
    inputMax.value = initialMax
    outputMin.innerText = initialMin
    outputMax.innerText = initialMax
  },
}
</script>
```

:::

## 5.使用 EPSG.io 搜索重新投影

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="epsg-query">Search projection:&nbsp</label>
    <input
      type="text"
      id="epsg-query"
      placeholder="4326, 27700, 3031, US National Atlas, Swiss, France, ..."
      class="form-control"
      size="50"
    />
    <button id="epsg-search" class="btn">Search</button>
    <span id="epsg-result"></span>
  </form>
  <form class="form-inline">
    <label for="render-edges">
      Render reprojection edges:&nbsp;
      <input type="checkbox" id="render-edges" />
    </label>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <label for="show-tiles">
      Show tile coordinates:&nbsp;
      <input type="checkbox" id="show-tiles" />
    </label>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <label for="show-graticule">
      Show graticule:&nbsp;
      <input type="checkbox" id="show-graticule" />
    </label>
  </form>
</template>

<script>
export default {
  mounted() {
    // import proj4 from 'proj4';
    let {
      extent: { applyTransform },
      Map,
      View,
      layer: { Tile: TileLayer, Graticule },
      source: { OSM, Vector: VectorSource, TileDebug },
      style: { Stroke },
      proj: {
        get: getProjection,
        getTransform,
        proj4: { register },
      },
    } = ol

    const osmSource = new OSM()

    const debugLayer = new TileLayer({
      source: new TileDebug({
        tileGrid: osmSource.getTileGrid(),
        projection: osmSource.getProjection(),
      }),
      visible: false,
    })

    const graticule = new Graticule({
      // the style to use for the lines, optional.
      strokeStyle: new Stroke({
        color: "rgba(255,120,0,0.9)",
        width: 2,
        lineDash: [0.5, 4],
      }),
      showLabels: true,
      visible: false,
      wrapX: false,
    })

    const map = new Map({
      layers: [
        new TileLayer({
          source: osmSource,
        }),
        debugLayer,
        graticule,
      ],
      target: this.$refs.map,
      view: new View({
        projection: "EPSG:3857",
        center: [0, 0],
        zoom: 1,
      }),
    })

    const queryInput = document.getElementById("epsg-query")
    const searchButton = document.getElementById("epsg-search")
    const resultSpan = document.getElementById("epsg-result")
    const renderEdgesCheckbox = document.getElementById("render-edges")
    const showTilesCheckbox = document.getElementById("show-tiles")
    const showGraticuleCheckbox = document.getElementById("show-graticule")

    function setProjection(code, name, proj4def, bbox) {
      if (
        code === null ||
        name === null ||
        proj4def === null ||
        bbox === null
      ) {
        resultSpan.innerHTML = "Nothing usable found, using EPSG:3857..."
        map.setView(
          new View({
            projection: "EPSG:3857",
            center: [0, 0],
            zoom: 1,
          })
        )
        return
      }

      resultSpan.innerHTML = "(" + code + ") " + name

      const newProjCode = "EPSG:" + code
      proj4.defs(newProjCode, proj4def)
      register(proj4)
      const newProj = getProjection(newProjCode)
      const fromLonLat = getTransform("EPSG:4326", newProj)

      let worldExtent = [bbox[1], bbox[2], bbox[3], bbox[0]]
      newProj.setWorldExtent(worldExtent)

      // approximate calculation of projection extent,
      // checking if the world extent crosses the dateline
      if (bbox[1] > bbox[3]) {
        worldExtent = [bbox[1], bbox[2], bbox[3] + 360, bbox[0]]
      }
      const extent = applyTransform(worldExtent, fromLonLat, undefined, 8)
      newProj.setExtent(extent)
      const newView = new View({
        projection: newProj,
      })
      map.setView(newView)
      newView.fit(extent)
    }

    function search(query) {
      resultSpan.innerHTML = "Searching ..."
      fetch("https://epsg.io/?format=json&q=" + query)
        .then(function (response) {
          return response.json()
        })
        .then(function (json) {
          const results = json["results"]
          if (results && results.length > 0) {
            for (let i = 0, ii = results.length; i < ii; i++) {
              const result = results[i]
              if (result) {
                const code = result["code"]
                const name = result["name"]
                const proj4def = result["proj4"]
                const bbox = result["bbox"]
                if (
                  code &&
                  code.length > 0 &&
                  proj4def &&
                  proj4def.length > 0 &&
                  bbox &&
                  bbox.length == 4
                ) {
                  setProjection(code, name, proj4def, bbox)
                  return
                }
              }
            }
          }
          setProjection(null, null, null, null)
        })
    }

    /**
     * Handle click event.
     * @param {Event} event The event.
     */
    searchButton.onclick = function (event) {
      search(queryInput.value)
      event.preventDefault()
    }

    /**
     * Handle checkbox change events.
     */
    renderEdgesCheckbox.onchange = function () {
      osmSource.setRenderReprojectionEdges(renderEdgesCheckbox.checked)
    }
    showTilesCheckbox.onchange = function () {
      debugLayer.setVisible(showTilesCheckbox.checked)
    }
    showGraticuleCheckbox.onchange = function () {
      graticule.setVisible(showGraticuleCheckbox.checked)
    }
  },
}
</script>
```

:::
