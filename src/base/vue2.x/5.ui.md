---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 五.案例 9

## 1.地震图

解析 KML 文件并将要素呈现为矢量图层。给定图层 a style 以相对于震级的大小来渲染地震位置。

:::demo

```vue
<template>
  <div ref="map" class="map"><div id="info"></div></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { Stamen, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      format: { KML },
    } = ol
    const styleCache = {}
    const styleFunction = function (feature) {
      const name = feature.get("name")
      const magnitude = parseFloat(name.substr(2))
      const radius = 5 + 20 * (magnitude - 5)
      let style = styleCache[radius]
      if (!style) {
        style = new Style({
          image: new CircleStyle({
            radius: radius,
            fill: new Fill({
              color: "rgba(255, 153, 0, 0.4)",
            }),
            stroke: new Stroke({
              color: "rgba(255, 204, 0, 0.2)",
              width: 1,
            }),
          }),
        })
        styleCache[radius] = style
      }
      return style
    }

    const vector = new VectorLayer({
      source: new VectorSource({
        url: this.$withBase("/data/kml/2012_Earthquakes_Mag5.kml"),
        format: new KML({
          extractStyles: false,
        }),
      }),
      style: styleFunction,
    })

    const raster = new TileLayer({
      source: new Stamen({
        layer: "toner",
      }),
    })

    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    const info = $("#info")
    console.dir(info)
    info.tooltip({
      animation: false,
      trigger: "manual",
    })

    const displayFeatureInfo = function (pixel) {
      info.css({
        left: pixel[0] + "px",
        top: pixel[1] - 15 + "px",
      })
      const feature = map.forEachFeatureAtPixel(pixel, function (feature) {
        return feature
      })
      if (feature) {
        info.attr("data-original-title", feature.get("name")).tooltip("show")
      } else {
        info.tooltip("hide")
      }
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        info.tooltip("hide")
        return
      }
      displayFeatureInfo(map.getEventPixel(evt.originalEvent))
    })

    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
  },
}
</script>
```

:::

## 2.自定义地震图

使用 `toContext` 创建自定义图标符号

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { KML },
      geom: { Polygon },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { Stamen, Vector: VectorSource },
      style: { Fill, Icon, Stroke, Style },
      render: { toContext },
    } = ol
    const symbol = [
      [0, 0],
      [4, 2],
      [6, 0],
      [10, 5],
      [6, 3],
      [4, 5],
      [0, 0],
    ]
    let scale
    const scaleFunction = function (coordinate) {
      return [coordinate[0] * scale, coordinate[1] * scale]
    }
    const styleCache = {}
    const styleFunction = function (feature) {
      const name = feature.get("name")
      const magnitude = parseFloat(name.substr(2))
      const size = parseInt(10 + 40 * (magnitude - 5), 10)
      scale = size / 10
      let style = styleCache[size]
      if (!style) {
        const canvas = document.createElement("canvas")
        const vectorContext = toContext(canvas.getContext("2d"), {
          size: [size, size],
          pixelRatio: 1,
        })
        vectorContext.setStyle(
          new Style({
            fill: new Fill({ color: "rgba(255, 153, 0, 0.4)" }),
            stroke: new Stroke({ color: "rgba(255, 204, 0, 0.2)", width: 2 }),
          })
        )
        vectorContext.drawGeometry(new Polygon([symbol.map(scaleFunction)]))
        style = new Style({
          image: new Icon({
            img: canvas,
            imgSize: [size, size],
            rotation: 1.2,
          }),
        })
        styleCache[size] = style
      }
      return style
    }

    const vector = new VectorLayer({
      source: new VectorSource({
        url: this.$withBase("/data/kml/2012_Earthquakes_Mag5.kml"),
        format: new KML({
          extractStyles: false,
        }),
      }),
      style: styleFunction,
    })

    const raster = new TileLayer({
      source: new Stamen({
        layer: "toner",
      }),
    })

    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 3.可编辑的 ArcGIS REST 功能服务

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">Draw or modify &nbsp;</label>
    <select id="type">
      <option value="DRAW">Draw</option>
      <option value="MODIFY">Modify</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      format: { EsriJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
      tilegrid: { createXYZ },
      proj: { fromLonLat },
      loadingstrategy: { tile: tileStrategy },
      interaction: { Draw, Modify, Select, defaults: defaultInteractions },
    } = ol
    const serviceUrl =
      "https://sampleserver6.arcgisonline.com/arcgis/rest/services/Wildfire/FeatureServer/"
    const layer = "2"

    const esrijsonFormat = new EsriJSON()

    const vectorSource = new VectorSource({
      loader: function (extent, resolution, projection) {
        const url =
          serviceUrl +
          layer +
          "/query/?f=json&" +
          "returnGeometry=true&spatialRel=esriSpatialRelIntersects&geometry=" +
          encodeURIComponent(
            '{"xmin":' +
              extent[0] +
              ',"ymin":' +
              extent[1] +
              ',"xmax":' +
              extent[2] +
              ',"ymax":' +
              extent[3] +
              ',"spatialReference":{"wkid":102100}}'
          ) +
          "&geometryType=esriGeometryEnvelope&inSR=102100&outFields=*" +
          "&outSR=102100"
        $.ajax({
          url: url,
          dataType: "jsonp",
          success: function (response) {
            if (response.error) {
              alert(
                response.error.message +
                  "\n" +
                  response.error.details.join("\n")
              )
            } else {
              // dataProjection will be read from document
              const features = esrijsonFormat.readFeatures(response, {
                featureProjection: projection,
              })
              if (features.length > 0) {
                vectorSource.addFeatures(features)
              }
            }
          },
        })
      },
      strategy: tileStrategy(
        createXYZ({
          tileSize: 512,
        })
      ),
    })

    const vector = new VectorLayer({
      source: vectorSource,
    })

    const raster = new TileLayer({
      source: new XYZ({
        attributions:
          'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/' +
          'rest/services/World_Topo_Map/MapServer">ArcGIS</a>',
        url:
          "https://server.arcgisonline.com/ArcGIS/rest/services/" +
          "World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
      }),
    })

    const draw = new Draw({
      source: vectorSource,
      type: "Polygon",
    })

    const select = new Select()
    select.setActive(false)
    const selected = select.getFeatures()

    const modify = new Modify({
      features: selected,
    })
    modify.setActive(false)

    const map = new Map({
      interactions: defaultInteractions().extend([draw, select, modify]),
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-110.875, 37.345]),
        zoom: 5,
      }),
    })

    const typeSelect = document.getElementById("type")

    /**
     * Let user change the interaction type.
     */
    typeSelect.onchange = function () {
      draw.setActive(typeSelect.value === "DRAW")
      select.setActive(typeSelect.value === "MODIFY")
      modify.setActive(typeSelect.value === "MODIFY")
    }

    const dirty = {}

    selected.on("add", function (evt) {
      const feature = evt.element
      feature.on("change", function (evt) {
        dirty[evt.target.get("objectid")] = true
      })
    })

    selected.on("remove", function (evt) {
      const feature = evt.element
      const fid = feature.get("objectid")
      if (dirty[fid] === true) {
        const payload =
          "[" +
          esrijsonFormat.writeFeature(feature, {
            featureProjection: map.getView().getProjection(),
          }) +
          "]"
        const url = serviceUrl + layer + "/updateFeatures"
        $.post(url, { f: "json", features: payload }).done(function (data) {
          const result = typeof data === "string" ? JSON.parse(data) : data
          if (result.updateResults && result.updateResults.length > 0) {
            if (result.updateResults[0].success !== true) {
              const error = result.updateResults[0].error
              alert(error.description + " (" + error.code + ")")
            } else {
              delete dirty[fid]
            }
          }
        })
      }
    })

    draw.on("drawend", function (evt) {
      const feature = evt.feature
      const payload =
        "[" +
        esrijsonFormat.writeFeature(feature, {
          featureProjection: map.getView().getProjection(),
        }) +
        "]"
      const url = serviceUrl + layer + "/addFeatures"
      $.post(url, { f: "json", features: payload }).done(function (data) {
        const result = typeof data === "string" ? JSON.parse(data) : data
        if (result.addResults && result.addResults.length > 0) {
          if (result.addResults[0].success === true) {
            feature.set("objectid", result.addResults[0]["objectId"])
          } else {
            const error = result.addResults[0].error
            alert(error.description + " (" + error.code + ")")
          }
        }
      })
    })
  },
}
</script>
```

:::

## 4.EPSG:4326

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { TileWMS },
      control: { ScaleLine, defaults: defaultControls },
    } = ol
    const layers = [
      new TileLayer({
        source: new TileWMS({
          url: "https://ahocevar.com/geoserver/wms",
          params: {
            LAYERS: "ne:NE1_HR_LC_SR_W_DR",
            TILED: true,
          },
        }),
      }),
    ]

    const map = new Map({
      controls: defaultControls().extend([
        new ScaleLine({
          units: "degrees",
        }),
      ]),
      layers: layers,
      target: this.$refs.map,
      view: new View({
        projection: "EPSG:4326",
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 5.导出 PDF 示例

:::demo

```vue
<template>
  <div class="row-fluid">
    <div class="span12">
      <div ref="map" class="map"></div>
    </div>
  </div>
  <form class="form">
    <label for="format">Page size </label>
    <select id="format">
      <option value="a0">A0 (slow)</option>
      <option value="a1">A1</option>
      <option value="a2">A2</option>
      <option value="a3">A3</option>
      <option value="a4" selected>A4</option>
      <option value="a5">A5 (fast)</option>
    </select>
    <label for="resolution">Resolution </label>
    <select id="resolution">
      <option value="72">72 dpi (fast)</option>
      <option value="150">150 dpi</option>
      <option value="300">300 dpi (slow)</option>
    </select>
  </form>
  <button id="export-pdf">导出 PDF</button>
</template>

<script>
export default {
  mounted() {
    let {
      format: { WKT },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })

    const format = new WKT()
    const feature = format.readFeature(
      "POLYGON((10.689697265625 -25.0927734375, 34.595947265625 " +
        "-20.1708984375, 38.814697265625 -35.6396484375, 13.502197265625 " +
        "-39.1552734375, 10.689697265625 -25.0927734375))"
    )
    feature.getGeometry().transform("EPSG:4326", "EPSG:3857")

    const vector = new VectorLayer({
      source: new VectorSource({
        features: [feature],
      }),
      opacity: 0.5,
    })

    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    const dims = {
      a0: [1189, 841],
      a1: [841, 594],
      a2: [594, 420],
      a3: [420, 297],
      a4: [297, 210],
      a5: [210, 148],
    }

    const exportButton = document.getElementById("export-pdf")

    exportButton.addEventListener(
      "click",
      function () {
        exportButton.disabled = true
        document.body.style.cursor = "progress"

        const format = document.getElementById("format").value
        const resolution = document.getElementById("resolution").value
        const dim = dims[format]
        const width = Math.round((dim[0] * resolution) / 25.4)
        const height = Math.round((dim[1] * resolution) / 25.4)
        const size = map.getSize()
        const viewResolution = map.getView().getResolution()

        map.once("rendercomplete", function () {
          const mapCanvas = document.createElement("canvas")
          mapCanvas.width = width
          mapCanvas.height = height
          const mapContext = mapCanvas.getContext("2d")
          Array.prototype.forEach.call(
            document.querySelectorAll(".ol-layer canvas"),
            function (canvas) {
              if (canvas.width > 0) {
                const opacity = canvas.parentNode.style.opacity
                mapContext.globalAlpha = opacity === "" ? 1 : Number(opacity)
                const transform = canvas.style.transform
                // Get the transform parameters from the style's transform matrix
                const matrix = transform
                  .match(/^matrix\(([^\(]*)\)$/)[1]
                  .split(",")
                  .map(Number)
                // Apply the transform to the export map context
                CanvasRenderingContext2D.prototype.setTransform.apply(
                  mapContext,
                  matrix
                )
                mapContext.drawImage(canvas, 0, 0)
              }
            }
          )
          mapContext.globalAlpha = 1
          const pdf = new jspdf.jsPDF("landscape", undefined, format)
          pdf.addImage(
            mapCanvas.toDataURL("image/jpeg"),
            "JPEG",
            0,
            0,
            dim[0],
            dim[1]
          )
          pdf.save("map.pdf")
          // Reset original map size
          map.setSize(size)
          map.getView().setResolution(viewResolution)
          exportButton.disabled = false
          document.body.style.cursor = "auto"
        })

        // Set print size
        const printSize = [width, height]
        map.setSize(printSize)
        const scaling = Math.min(width / size[0], height / size[1])
        map.getView().setResolution(viewResolution / scaling)
      },
      false
    )
  },
}
</script>
```

:::
