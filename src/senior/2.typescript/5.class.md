---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 五.案例5

## 1.图层组

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div id="layertree">
    <h5>Click on layer nodes below to change their properties.</h5>
    <ul>
      <li>
        <span>OSM layer</span>
        <fieldset id="layer0">
          <label class="checkbox" for="visible0">
            visible <input id="visible0" class="visible" type="checkbox" />
          </label>
          <label>
            opacity
            <input class="opacity" type="range" min="0" max="1" step="0.01" />
          </label>
        </fieldset>
      </li>
      <li>
        <span>Layer group</span>
        <fieldset id="layer1">
          <label class="checkbox" for="visible1">
            visible <input id="visible1" class="visible" type="checkbox" />
          </label>
          <label>
            opacity
            <input class="opacity" type="range" min="0" max="1" step="0.01" />
          </label>
        </fieldset>
        <ul>
          <li>
            <span>Food insecurity layer</span>
            <fieldset id="layer10">
              <label class="checkbox" for="visible10">
                visible <input id="visible10" class="visible" type="checkbox" />
              </label>
              <label>
                opacity
                <input
                  class="opacity"
                  type="range"
                  min="0"
                  max="1"
                  step="0.01"
                />
              </label>
            </fieldset>
          </li>
          <li>
            <span>World borders layer</span>
            <fieldset id="layer11">
              <label class="checkbox" for="visible11">
                visible <input id="visible11" class="visible" type="checkbox" />
              </label>
              <label>
                opacity
                <input
                  class="opacity"
                  type="range"
                  min="0"
                  max="1"
                  step="0.01"
                />
              </label>
            </fieldset>
          </li>
        </ul>
      </li>
    </ul>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Group: LayerGroup },
      source: { OSM, TileJSON },
      proj: { fromLonLat },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"

    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
        new LayerGroup({
          layers: [
            new TileLayer({
              source: new TileJSON({
                url:
                  "https://api.tiles.mapbox.com/v4/mapbox.20110804-hoa-foodinsecurity-3month.json?secure&access_token=" +
                  key,
                crossOrigin: "anonymous",
              }),
            }),
            new TileLayer({
              source: new TileJSON({
                url:
                  "https://api.tiles.mapbox.com/v4/mapbox.world-borders-light.json?secure&access_token=" +
                  key,
                crossOrigin: "anonymous",
              }),
            }),
          ],
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([37.4057, 8.81566]),
        zoom: 4,
      }),
    })

    function bindInputs(layerid, layer) {
      const visibilityInput = $(layerid + " input.visible")
      visibilityInput.on("change", function () {
        layer.setVisible(this.checked)
      })
      visibilityInput.prop("checked", layer.getVisible())

      const opacityInput = $(layerid + " input.opacity")
      opacityInput.on("input change", function () {
        layer.setOpacity(parseFloat(this.value))
      })
      opacityInput.val(String(layer.getOpacity()))
    }
    function setup(id, group) {
      group.getLayers().forEach(function (layer, i) {
        const layerid = id + i
        bindInputs(layerid, layer)
        if (layer instanceof LayerGroup) {
          setup(layerid, layer)
        }
      })
    }
    setup("#layer", map.getLayerGroup())

    $("#layertree li > span")
      .click(function () {
        $(this).siblings("fieldset").toggle()
      })
      .siblings("fieldset")
      .hide()
  },
}
</script>
```

:::

## 2.图层最小/最大分辨率

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM, TileJSON },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"

    /**
     * Create the map.
     */
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
          minResolution: 200,
          maxResolution: 2000,
        }),
        new TileLayer({
          source: new TileJSON({
            url:
              "https://api.tiles.mapbox.com/v4/mapbox.natural-earth-hypso-bathy.json?secure&access_token=" +
              key,
            crossOrigin: "anonymous",
          }),
          minResolution: 2000,
          maxResolution: 20000,
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [653600, 5723680],
        zoom: 5,
      }),
    })
  },
}
</script>
```

:::

## 3.层不透明度

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <label>
    Layer opacity
    <input
      id="opacity-input"
      type="range"
      min="0"
      max="1"
      step="0.01"
      value="1"
    />
    <span id="opacity-output"></span>
  </label>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { WebGLTile: TileLayer },
      source: { XYZ, OSM },
      style: Style,
      proj: { fromLonLat },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"

    const imagery = new TileLayer({
      className: "ol-layer-imagery",
      source: new XYZ({
        attributions:
          '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ',
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })

    const osm = new TileLayer({
      source: new OSM(),
    })

    const map = new Map({
      layers: [imagery, osm],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })

    const opacityInput = document.getElementById("opacity-input")
    const opacityOutput = document.getElementById("opacity-output")
    function update() {
      const opacity = parseFloat(opacityInput.value)
      osm.setOpacity(opacity)
      opacityOutput.innerText = opacity.toFixed(2)
    }
    opacityInput.addEventListener("input", update)
    opacityInput.addEventListener("change", update)
    update()
  },
}
</script>
```

:::

## 4.层间谍

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
      style: Style,
      proj: { fromLonLat },
      render: { getRenderPixel },
    } = ol

    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const roads = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url: "https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=" + key,
        tileSize: 512,
        maxZoom: 22,
      }),
    })

    const imagery = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
        maxZoom: 20,
      }),
    })

    const container = this.$refs.map

    const map = new Map({
      layers: [roads, imagery],
      target: container,
      view: new View({
        center: fromLonLat([-109, 46.5]),
        zoom: 6,
      }),
    })

    let radius = 75
    document.addEventListener("keydown", function (evt) {
      if (evt.which === 38) {
        radius = Math.min(radius + 5, 150)
        map.render()
        evt.preventDefault()
      } else if (evt.which === 40) {
        radius = Math.max(radius - 5, 25)
        map.render()
        evt.preventDefault()
      }
    })

    // get the pixel position with every move
    let mousePosition = null

    container.addEventListener("mousemove", function (event) {
      mousePosition = map.getEventPixel(event)
      map.render()
    })

    container.addEventListener("mouseout", function () {
      mousePosition = null
      map.render()
    })

    // before rendering the layer, do some clipping
    imagery.on("prerender", function (event) {
      const ctx = event.context
      ctx.save()
      ctx.beginPath()
      if (mousePosition) {
        // only show a circle around the mouse
        const pixel = getRenderPixel(event, mousePosition)
        const offset = getRenderPixel(event, [
          mousePosition[0] + radius,
          mousePosition[1],
        ])
        const canvasRadius = Math.sqrt(
          Math.pow(offset[0] - pixel[0], 2) + Math.pow(offset[1] - pixel[1], 2)
        )
        ctx.arc(pixel[0], pixel[1], canvasRadius, 0, 2 * Math.PI)
        ctx.lineWidth = (5 * canvasRadius) / radius
        ctx.strokeStyle = "rgba(0,0,0,0.5)"
        ctx.stroke()
      }
      ctx.clip()
    })

    // after rendering the layer, restore the canvas context
    imagery.on("postrender", function (event) {
      const ctx = event.context
      ctx.restore()
    })
  },
}
</script>
```

:::

## 5.图层滑动

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <input id="swipe" type="range" style="width: 100%" />
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM, XYZ },
      render: { getRenderPixel },
    } = ol

    const osm = new TileLayer({
      source: new OSM(),
    })

    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const aerial = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
        maxZoom: 20,
      }),
    })

    const map = new Map({
      layers: [osm, aerial],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })

    const swipe = document.getElementById("swipe")

    aerial.on("prerender", function (event) {
      const ctx = event.context
      const mapSize = map.getSize()
      const width = mapSize[0] * (swipe.value / 100)
      const tl = getRenderPixel(event, [width, 0])
      const tr = getRenderPixel(event, [mapSize[0], 0])
      const bl = getRenderPixel(event, [width, mapSize[1]])
      const br = getRenderPixel(event, mapSize)

      ctx.save()
      ctx.beginPath()
      ctx.moveTo(tl[0], tl[1])
      ctx.lineTo(bl[0], bl[1])
      ctx.lineTo(br[0], br[1])
      ctx.lineTo(tr[0], tr[1])
      ctx.closePath()
      ctx.clip()
    })

    aerial.on("postrender", function (event) {
      const ctx = event.context
      ctx.restore()
    })

    const listener = function () {
      map.render()
    }
    swipe.addEventListener("input", listener)
    swipe.addEventListener("change", listener)
  },
}
</script>
```

:::
