---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 三.类型推导

## 1.IIIF 图像 API

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div class="controls">
    <div id="iiif-notification">&nbsp;</div>
    <label for="imageInfoUrl">Enter <code>info.json</code> URL:</label>
    <input
      type="text"
      id="imageInfoUrl"
      value="https://iiif.ub.uni-leipzig.de/iiif/j2k/0000/0107/0000010732/00000072.jpx/info.json"
    />
    <button id="display">Display image</button>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { IIIFInfo },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { IIIF },
    } = ol

    const layer = new TileLayer(),
      map = new Map({
        layers: [layer],
        target: this.$refs.map,
      }),
      notifyDiv = document.getElementById("iiif-notification"),
      urlInput = document.getElementById("imageInfoUrl"),
      displayButton = document.getElementById("display")

    function refreshMap(imageInfoUrl) {
      fetch(imageInfoUrl)
        .then(function (response) {
          response
            .json()
            .then(function (imageInfo) {
              const options = new IIIFInfo(imageInfo).getTileSourceOptions()
              if (options === undefined || options.version === undefined) {
                notifyDiv.textContent =
                  "Data seems to be no valid IIIF image information."
                return
              }
              options.zDirection = -1
              const iiifTileSource = new IIIF(options)
              layer.setSource(iiifTileSource)
              map.setView(
                new View({
                  resolutions: iiifTileSource.getTileGrid().getResolutions(),
                  extent: iiifTileSource.getTileGrid().getExtent(),
                  constrainOnlyCenter: true,
                })
              )
              map.getView().fit(iiifTileSource.getTileGrid().getExtent())
              notifyDiv.textContent = ""
            })
            .catch(function (body) {
              notifyDiv.textContent = "Could not read image info json. " + body
            })
        })
        .catch(function () {
          notifyDiv.textContent = "Could not read data from URL."
        })
    }

    displayButton.addEventListener("click", function () {
      refreshMap(urlInput.value)
    })

    refreshMap(urlInput.value)
  },
}
</script>
```

:::

## 2.Image ArcGIS MapServer

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Image: ImageLayer },
      source: { OSM, ImageArcGISRest },
    } = ol

    const url =
      "https://sampleserver1.arcgisonline.com/ArcGIS/rest/services/" +
      "Specialty/ESRI_StateCityHighway_USA/MapServer"

    const layers = [
      new TileLayer({
        source: new OSM(),
      }),
      new ImageLayer({
        source: new ImageArcGISRest({
          ratio: 1,
          params: {},
          url: url,
        }),
      }),
    ]
    const map = new Map({
      layers: layers,
      target: this.$refs.map,
      view: new View({
        center: [-10997148, 4569099],
        zoom: 4,
      }),
    })
  },
}
</script>
```

:::

## 3.图像滤镜

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <select id="kernel" name="kernel">
    <option>none</option>
    <option selected>sharpen</option>
    <option value="sharpenless">sharpen less</option>
    <option>blur</option>
    <option>shadow</option>
    <option>emboss</option>
    <option value="edge">edge detect</option>
  </select>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
      proj: { fromLonLat },
    } = ol

    const key = "Get your own API key at https://www.maptiler.com/cloud/"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const imagery = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })

    const map = new Map({
      layers: [imagery],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-120, 50]),
        zoom: 6,
      }),
    })

    const kernels = {
      none: [0, 0, 0, 0, 1, 0, 0, 0, 0],
      sharpen: [0, -1, 0, -1, 5, -1, 0, -1, 0],
      sharpenless: [0, -1, 0, -1, 10, -1, 0, -1, 0],
      blur: [1, 1, 1, 1, 1, 1, 1, 1, 1],
      shadow: [1, 2, 1, 0, 1, 0, -1, -2, -1],
      emboss: [-2, 1, 0, -1, 1, 1, 0, 1, 2],
      edge: [0, 1, 0, 1, -4, 1, 0, 1, 0],
    }

    function normalize(kernel) {
      const len = kernel.length
      const normal = new Array(len)
      let i,
        sum = 0
      for (i = 0; i < len; ++i) {
        sum += kernel[i]
      }
      if (sum <= 0) {
        normal.normalized = false
        sum = 1
      } else {
        normal.normalized = true
      }
      for (i = 0; i < len; ++i) {
        normal[i] = kernel[i] / sum
      }
      return normal
    }

    const select = document.getElementById("kernel")
    let selectedKernel = normalize(kernels[select.value])

    /**
     * Update the kernel and re-render on change.
     */
    select.onchange = function () {
      selectedKernel = normalize(kernels[select.value])
      map.render()
    }

    /**
     * Apply a filter on "postrender" events.
     */
    imagery.on("postrender", function (event) {
      convolve(event.context, selectedKernel)
    })

    /**
     * Apply a convolution kernel to canvas.  This works for any size kernel, but
     * performance starts degrading above 3 x 3.
     * @param {CanvasRenderingContext2D} context Canvas 2d context.
     * @param {Array<number>} kernel Kernel.
     */
    function convolve(context, kernel) {
      const canvas = context.canvas
      const width = canvas.width
      const height = canvas.height

      const size = Math.sqrt(kernel.length)
      const half = Math.floor(size / 2)

      const inputData = context.getImageData(0, 0, width, height).data

      const output = context.createImageData(width, height)
      const outputData = output.data

      for (let pixelY = 0; pixelY < height; ++pixelY) {
        const pixelsAbove = pixelY * width
        for (let pixelX = 0; pixelX < width; ++pixelX) {
          let r = 0,
            g = 0,
            b = 0,
            a = 0
          for (let kernelY = 0; kernelY < size; ++kernelY) {
            for (let kernelX = 0; kernelX < size; ++kernelX) {
              const weight = kernel[kernelY * size + kernelX]
              const neighborY = Math.min(
                height - 1,
                Math.max(0, pixelY + kernelY - half)
              )
              const neighborX = Math.min(
                width - 1,
                Math.max(0, pixelX + kernelX - half)
              )
              const inputIndex = (neighborY * width + neighborX) * 4
              r += inputData[inputIndex] * weight
              g += inputData[inputIndex + 1] * weight
              b += inputData[inputIndex + 2] * weight
              a += inputData[inputIndex + 3] * weight
            }
          }
          const outputIndex = (pixelsAbove + pixelX) * 4
          outputData[outputIndex] = r
          outputData[outputIndex + 1] = g
          outputData[outputIndex + 2] = b
          outputData[outputIndex + 3] = kernel.normalized ? a : 255
        }
      }
      context.putImageData(output, 0, 0)
    }
  },
}
</script>
```

:::

## 4.Image 加载事件

:::demo

```vue
<template>
  <div class="wrapper">
    <div ref="map" class="map"></div>
    <div id="progress"></div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Image: ImageLayer },
      source: { ImageWMS },
    } = ol
    /**
     * Renders a progress bar.
     * @param {HTMLElement} el The target element.
     * @class
     */
    function Progress(el) {
      this.el = el
      this.loading = 0
      this.loaded = 0
    }

    /**
     * Increment the count of loading tiles.
     */
    Progress.prototype.addLoading = function () {
      ++this.loading
      this.update()
    }

    /**
     * Increment the count of loaded tiles.
     */
    Progress.prototype.addLoaded = function () {
      ++this.loaded
      this.update()
    }

    /**
     * Update the progress bar.
     */
    Progress.prototype.update = function () {
      const width = ((this.loaded / this.loading) * 100).toFixed(1) + "%"
      this.el.style.width = width
    }

    /**
     * Show the progress bar.
     */
    Progress.prototype.show = function () {
      this.el.style.visibility = "visible"
    }

    /**
     * Hide the progress bar.
     */
    Progress.prototype.hide = function () {
      const style = this.el.style
      setTimeout(function () {
        style.visibility = "hidden"
        style.width = 0
      }, 250)
    }

    const progress = new Progress(document.getElementById("progress"))

    const source = new ImageWMS({
      url: "https://ahocevar.com/geoserver/wms",
      params: { LAYERS: "topp:states" },
      serverType: "geoserver",
    })

    source.on("imageloadstart", function () {
      progress.addLoading()
    })
    source.on(["imageloadend", "imageloaderror"], function () {
      progress.addLoaded()
    })

    const map = new Map({
      layers: [new ImageLayer({ source: source })],
      target: this.$refs.map,
      view: new View({
        center: [-10997148, 4569099],
        zoom: 4,
      }),
    })

    map.on("loadstart", function () {
      progress.show()
    })
    map.on("loadend", function () {
      progress.hide()
    })
  },
}
</script>
```

:::

## 5.Image 重新投影

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <input type="checkbox" id="interpolate" checked />
    <label for="interpolate">Interpolate</label>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Image: ImageLayer },
      source: { OSM, ImageStatic: Static },
      style: Style,
      proj: { fromLonLat, proj4: register },
      extent: { getCenter },
      // import proj4 from 'proj4';
    } = ol

    proj4.defs(
      "EPSG:27700",
      "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 " +
        "+x_0=400000 +y_0=-100000 +ellps=airy " +
        "+towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 " +
        "+units=m +no_defs"
    )
    register(proj4)

    const imageExtent = [0, 0, 700000, 1300000]
    const imageLayer = new ImageLayer()

    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
        imageLayer,
      ],
      target: "map",
      view: new View({
        center: transform(getCenter(imageExtent), "EPSG:27700", "EPSG:3857"),
        zoom: 4,
      }),
    })

    const interpolate = document.getElementById("interpolate")

    function setSource() {
      const source = new Static({
        url:
          "https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/" +
          "British_National_Grid.svg/2000px-British_National_Grid.svg.png",
        crossOrigin: "",
        projection: "EPSG:27700",
        imageExtent: imageExtent,
        interpolate: interpolate.checked,
      })
      imageLayer.setSource(source)
    }
    setSource()

    interpolate.addEventListener("change", setSource)
  },
}
</script>
```

:::
