---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十五.案例 15

## 1.区域增长

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <label class="input-group">
      Threshold:
      <input id="threshold" type="range" min="1" max="50" value="20" />
      <span id="threshold-value"></span>
    </label>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Raster: RasterSource },
      proj: { fromLonLat },
    } = ol
    function growRegion(inputs, data) {
      const image = inputs[0]
      let seed = data.pixel
      const delta = parseInt(data.delta)
      if (!seed) {
        return image
      }
      seed = seed.map(Math.round)
      const width = image.width
      const height = image.height
      const inputData = image.data
      const outputData = new Uint8ClampedArray(inputData)
      const seedIdx = (seed[1] * width + seed[0]) * 4
      const seedR = inputData[seedIdx]
      const seedG = inputData[seedIdx + 1]
      const seedB = inputData[seedIdx + 2]
      let edge = [seed]
      while (edge.length) {
        const newedge = []
        for (let i = 0, ii = edge.length; i < ii; i++) {
          const next = next4Edges(edge[i])
          for (let j = 0, jj = next.length; j < jj; j++) {
            const s = next[j][0]
            const t = next[j][1]
            if (s >= 0 && s < width && t >= 0 && t < height) {
              const ci = (t * width + s) * 4
              const cr = inputData[ci]
              const cg = inputData[ci + 1]
              const cb = inputData[ci + 2]
              const ca = inputData[ci + 3]
              if (ca === 0) {
                continue
              }
              if (
                Math.abs(seedR - cr) < delta &&
                Math.abs(seedG - cg) < delta &&
                Math.abs(seedB - cb) < delta
              ) {
                outputData[ci] = 255
                outputData[ci + 1] = 0
                outputData[ci + 2] = 0
                outputData[ci + 3] = 255
                newedge.push([s, t])
              }
              inputData[ci + 3] = 0
            }
          }
        }
        edge = newedge
      }
      return { data: outputData, width: width, height: height }
    }
    function next4Edges(edge) {
      const x = edge[0]
      const y = edge[1]
      return [
        [x + 1, y],
        [x - 1, y],
        [x, y + 1],
        [x, y - 1],
      ]
    }
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'
    const imagery = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
          mapkeys.maptiler,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })
    const raster = new RasterSource({
      sources: [imagery.getSource()],
      operationType: "image",
      operation: growRegion,
      lib: {
        next4Edges: next4Edges,
      },
    })
    const rasterImage = new ImageLayer({
      opacity: 0.7,
      source: raster,
    })
    const map = new Map({
      layers: [imagery, rasterImage],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-119.07, 47.65]),
        zoom: 11,
      }),
    })
    let coordinate
    map.on("click", function (event) {
      coordinate = event.coordinate
      raster.changed()
    })
    const thresholdControl = document.getElementById("threshold")
    raster.on("beforeoperations", function (event) {
      const data = event.data
      data.delta = thresholdControl.value
      if (coordinate) {
        data.pixel = map.getPixelFromCoordinate(coordinate)
      }
    })
    function updateControlValue() {
      document.getElementById("threshold-value").innerText =
        thresholdControl.value
    }
    updateControlValue()

    const listener = function () {
      updateControlValue()
      raster.changed()
    }
    thresholdControl.addEventListener("input", listener)
    thresholdControl.addEventListener("change", listener)
  },
}
</script>
```

:::

## 2.常规形状

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Point },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: { Fill, RegularShape, Stroke, Style },
    } = ol

    const stroke = new Stroke({ color: "black", width: 2 })
    const fill = new Fill({ color: "red" })

    const styles = {
      square: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 4,
          radius: 10,
          angle: Math.PI / 4,
        }),
      }),
      rectangle: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          radius: 10 / Math.SQRT2,
          radius2: 10,
          points: 4,
          angle: 0,
          scale: [1, 0.5],
        }),
      }),
      triangle: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 3,
          radius: 10,
          rotation: Math.PI / 4,
          angle: 0,
        }),
      }),
      star: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 5,
          radius: 10,
          radius2: 4,
          angle: 0,
        }),
      }),
      cross: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 4,
          radius: 10,
          radius2: 0,
          angle: 0,
        }),
      }),
      x: new Style({
        image: new RegularShape({
          fill: fill,
          stroke: stroke,
          points: 4,
          radius: 10,
          radius2: 0,
          angle: Math.PI / 4,
        }),
      }),
      stacked: [
        new Style({
          image: new RegularShape({
            fill: fill,
            stroke: stroke,
            points: 4,
            radius: 5,
            angle: Math.PI / 4,
            displacement: [0, 10],
          }),
        }),
        new Style({
          image: new RegularShape({
            fill: fill,
            stroke: stroke,
            points: 4,
            radius: 10,
            angle: Math.PI / 4,
          }),
        }),
      ],
    }

    const styleKeys = [
      "x",
      "cross",
      "star",
      "triangle",
      "square",
      "rectangle",
      "stacked",
    ]
    const count = 250
    const features = new Array(count)
    const e = 4500000
    for (let i = 0; i < count; ++i) {
      const coordinates = [2 * e * Math.random() - e, 2 * e * Math.random() - e]
      features[i] = new Feature(new Point(coordinates))
      features[i].setStyle(
        styles[styleKeys[Math.floor(Math.random() * styleKeys.length)]]
      )
    }

    const source = new VectorSource({
      features: features,
    })

    const vectorLayer = new VectorLayer({
      source: source,
    })

    const map = new Map({
      layers: [vectorLayer],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 3.渲染几何形状到画布

:::demo

```vue
<template>
  <div ref="map" class="map" id="canvas"></div>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { LineString, Point, Polygon },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      render: { toContext },
    } = ol

    const canvas = document.getElementById("canvas")
    const vectorContext = toContext(canvas.getContext("2d"), {
      size: [100, 100],
    })

    const fill = new Fill({ color: "blue" })
    const stroke = new Stroke({ color: "black" })
    const style = new Style({
      fill: fill,
      stroke: stroke,
      image: new CircleStyle({
        radius: 10,
        fill: fill,
        stroke: stroke,
      }),
    })
    vectorContext.setStyle(style)

    vectorContext.drawGeometry(
      new LineString([
        [10, 10],
        [90, 90],
      ])
    )
    vectorContext.drawGeometry(
      new Polygon([
        [
          [2, 2],
          [98, 2],
          [2, 98],
          [2, 2],
        ],
      ])
    )
    vectorContext.drawGeometry(new Point([88, 88]))
  },
}
</script>
```

:::

