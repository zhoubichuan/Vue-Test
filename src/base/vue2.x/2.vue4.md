---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 二.案例 6

## 2.d3 集成

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Layer },
      source: { State: SourceState, Stamen },
      extent: { getCenter, getWidth },
      proj: { fromLonLat, toLonLat },
    } = ol
    class CanvasLayer extends Layer {
      constructor(options) {
        super(options)

        this.features = options.features

        this.svg = d3
          .select(document.createElement("div"))
          .append("svg")
          .style("position", "absolute")

        this.svg.append("path").datum(this.features).attr("class", "boundary")
      }

      getSourceState() {
        return SourceState.READY
      }

      render(frameState) {
        const width = frameState.size[0]
        const height = frameState.size[1]
        const projection = frameState.viewState.projection
        const d3Projection = d3.geoMercator().scale(1).translate([0, 0])
        let d3Path = d3.geoPath().projection(d3Projection)

        const pixelBounds = d3Path.bounds(this.features)
        const pixelBoundsWidth = pixelBounds[1][0] - pixelBounds[0][0]
        const pixelBoundsHeight = pixelBounds[1][1] - pixelBounds[0][1]

        const geoBounds = d3.geoBounds(this.features)
        const geoBoundsLeftBottom = fromLonLat(geoBounds[0], projection)
        const geoBoundsRightTop = fromLonLat(geoBounds[1], projection)
        let geoBoundsWidth = geoBoundsRightTop[0] - geoBoundsLeftBottom[0]
        if (geoBoundsWidth < 0) {
          geoBoundsWidth += getWidth(projection.getExtent())
        }
        const geoBoundsHeight = geoBoundsRightTop[1] - geoBoundsLeftBottom[1]

        const widthResolution = geoBoundsWidth / pixelBoundsWidth
        const heightResolution = geoBoundsHeight / pixelBoundsHeight
        const r = Math.max(widthResolution, heightResolution)
        const scale = r / frameState.viewState.resolution

        const center = toLonLat(getCenter(frameState.extent), projection)
        const angle = (-frameState.viewState.rotation * 180) / Math.PI

        d3Projection
          .scale(scale)
          .center(center)
          .translate([width / 2, height / 2])
          .angle(angle)

        d3Path = d3Path.projection(d3Projection)
        d3Path(this.features)

        this.svg.attr("width", width)
        this.svg.attr("height", height)

        this.svg.select("path").attr("d", d3Path)

        return this.svg.node()
      }
    }

    const map = new Map({
      layers: [
        new TileLayer({
          source: new Stamen({
            layer: "watercolor",
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-97, 38]),
        zoom: 4,
      }),
    })

    /**
     * Load the topojson data and create an ol/layer/Image for that data.
     */
    d3.json("data/topojson/us.json").then(function (us) {
      const layer = new CanvasLayer({
        features: topojson.feature(us, us.objects.counties),
      })

      map.addLayer(layer)
    })
  },
}
</script>
```

:::

## 3.数据瓦片

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { WebGLTile: TileLayer },
      source: { DataTile },
    } = ol
    const size = 256

    const canvas = document.createElement("canvas")
    canvas.width = size
    canvas.height = size

    const context = canvas.getContext("2d")
    context.strokeStyle = "white"
    context.textAlign = "center"
    context.font = "24px sans-serif"
    const lineHeight = 30

    const map = new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          source: new DataTile({
            loader: function (z, x, y) {
              const half = size / 2
              context.clearRect(0, 0, size, size)
              context.fillStyle = "rgba(100, 100, 100, 0.5)"
              context.fillRect(0, 0, size, size)
              context.fillStyle = "black"
              context.fillText(`z: ${z}`, half, half - lineHeight)
              context.fillText(`x: ${x}`, half, half)
              context.fillText(`y: ${y}`, half, half + lineHeight)
              context.strokeRect(0, 0, size, size)
              const data = context.getImageData(0, 0, size, size).data
              // converting to Uint8Array for increased browser compatibility
              return new Uint8Array(data.buffer)
            },
            // disable opacity transition to avoid overlapping labels during tile loading
            transition: 0,
          }),
        }),
      ],
      view: new View({
        center:[12579156, 3274244],
        zoom: 0,
      }),
    })
  },
}
</script>
```

:::

## 4.设备方向

跟踪设备方向的变化

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <ul >
    <li>α : <code ref="alpha"></code></li>
    <li>β : <code ref="beta"></code></li>
    <li>γ : <code ref="gamma"></code></li>
  </ul>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      math: { toRadians },
    } = ol
    const view = new View({
      center:[12579156, 3274244],
      zoom: 2,
    })
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: view,
    })
    function el(id) {
      return this.$refs[id]
    }
    const gn = new GyroNorm()
    gn.init().then(function () {
      gn.start(function (event) {
        const center = view.getCenter()
        const resolution = view.getResolution()
        const alpha = toRadians(event.do.alpha)
        const beta = toRadians(event.do.beta)
        const gamma = toRadians(event.do.gamma)

        el("alpha").innerText = alpha + " [rad]"
        el("beta").innerText = beta + " [rad]"
        el("gamma").innerText = gamma + " [rad]"

        center[0] -= resolution * gamma * 25
        center[1] += resolution * beta * 25

        view.setCenter(center)
      })
    })
  },
}
</script>
```

:::

## 5.拖放

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <label
      ><input type="checkbox" ref="extractstyles" checked />从KML中提取样式
    </label>
  </div>
  <br />
  <div>
    <a ref="download" download></a>
    下载样品
    <button ref="gpx">GPX</button>
    &nbsp;
    <button ref="geojson">GeoJSON</button>
    &nbsp;
    <button ref="igc">IGC</button>
    &nbsp;
    <button ref="kml">KML</button>
    &nbsp;
    <button ref="topojson">TopoJSON</button>
  </div>
  <br />
  <div ref="info">&nbsp;</div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
      format: { GPX, GeoJSON, IGC, KML, TopoJSON },
      interaction: { DragAndDrop },
    } = ol
    const key =
      "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const map = new Map({
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
              key,
            maxZoom: 20,
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    const extractStyles = this.$refs.extractstyles
    let dragAndDropInteraction

    function setInteraction() {
      if (dragAndDropInteraction) {
        map.removeInteraction(dragAndDropInteraction)
      }
      dragAndDropInteraction = new DragAndDrop({
        formatConstructors: [
          GPX,
          GeoJSON,
          IGC,
          // use constructed format to set options
          new KML({ extractStyles: extractStyles.checked }),
          TopoJSON,
        ],
      })
      dragAndDropInteraction.on("addfeatures", function (event) {
        const vectorSource = new VectorSource({
          features: event.features,
        })
        map.addLayer(
          new VectorLayer({
            source: vectorSource,
          })
        )
        map.getView().fit(vectorSource.getExtent())
      })
      map.addInteraction(dragAndDropInteraction)
    }
    setInteraction()

    extractStyles.addEventListener("change", setInteraction)

    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          info.push(features[i].get("name"))
        }
        document.getElementById("info").innerHTML = info.join(", ") || "&nbsp"
      } else {
        document.getElementById("info").innerHTML = "&nbsp;"
      }
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })

    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
    const link = this.$refs.download
    function download(fullpath, filename) {
      fetch(fullpath)
        .then(function (response) {
          return response.blob()
        })
        .then(function (blob) {
          if (navigator.msSaveBlob) {
            navigator.msSaveBlob(blob, filename)
          } else {
            link.href = URL.createObjectURL(blob)
            link.download = filename
            link.click()
          }
        })
    }

    this.$refs.gpx.addEventListener("click", function () {
      download("data/gpx/fells_loop.gpx", "fells_loop.gpx")
    })
    this.$refs.geojson.addEventListener("click", function () {
      download("data/geojson/roads-seoul.geojson", "roads-seoul.geojson")
    })
    this.$refs.igc.addEventListener("click", function () {
      download("data/igc/Ulrich-Prinz.igc", "Ulrich-Prinz.igc")
    })
    this.$refs.kml.addEventListener("click", function () {
      download("data/kml/states.kml", "states.kml")
    })
    this.$refs.topojson.addEventListener("click", function () {
      download("data/topojson/fr-departments.json", "fr-departments.json")
    })
  },
}
</script>
```

:::
