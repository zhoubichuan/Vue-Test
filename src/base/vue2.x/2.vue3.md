---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 二.

## 1.自定互动

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { LineString, Point, Polygon },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { TileJSON, Vector: VectorSource },
      style: { Fill, Icon, Stroke, Style },
      interaction: {
        Pointer: PointerInteraction,
        defaults: defaultInteractions,
      },
    } = ol
    class Drag extends PointerInteraction {
      constructor() {
        super({
          handleDownEvent: handleDownEvent,
          handleDragEvent: handleDragEvent,
          handleMoveEvent: handleMoveEvent,
          handleUpEvent: handleUpEvent,
        })

        /**
         * @type {import("../src/ol/coordinate.js").Coordinate}
         * @private
         */
        this.coordinate_ = null

        /**
         * @type {string|undefined}
         * @private
         */
        this.cursor_ = "pointer"

        /**
         * @type {Feature}
         * @private
         */
        this.feature_ = null

        /**
         * @type {string|undefined}
         * @private
         */
        this.previousCursor_ = undefined
      }
    }

    function handleDownEvent(evt) {
      const map = evt.map

      const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
        return feature
      })

      if (feature) {
        this.coordinate_ = evt.coordinate
        this.feature_ = feature
      }

      return !!feature
    }

    function handleDragEvent(evt) {
      const deltaX = evt.coordinate[0] - this.coordinate_[0]
      const deltaY = evt.coordinate[1] - this.coordinate_[1]

      const geometry = this.feature_.getGeometry()
      geometry.translate(deltaX, deltaY)

      this.coordinate_[0] = evt.coordinate[0]
      this.coordinate_[1] = evt.coordinate[1]
    }

    function handleMoveEvent(evt) {
      if (this.cursor_) {
        const map = evt.map
        const feature = map.forEachFeatureAtPixel(
          evt.pixel,
          function (feature) {
            return feature
          }
        )
        const element = evt.map.getTargetElement()
        if (feature) {
          if (element.style.cursor != this.cursor_) {
            this.previousCursor_ = element.style.cursor
            element.style.cursor = this.cursor_
          }
        } else if (this.previousCursor_ !== undefined) {
          element.style.cursor = this.previousCursor_
          this.previousCursor_ = undefined
        }
      }
    }

    /**
     * @return {boolean} `false` to stop the drag sequence.
     */
    function handleUpEvent() {
      this.coordinate_ = null
      this.feature_ = null
      return false
    }

    const pointFeature = new Feature(new Point([0, 0]))

    const lineFeature = new Feature(
      new LineString([
        [-1e7, 1e6],
        [-1e6, 3e6],
      ])
    )

    const polygonFeature = new Feature(
      new Polygon([
        [
          [-3e6, -1e6],
          [-3e6, 1e6],
          [-1e6, 1e6],
          [-1e6, -1e6],
          [-3e6, -1e6],
        ],
      ])
    )

    const key = "Your Mapbox access token from https://mapbox.com/ here"

    const map = new Map({
      interactions: defaultInteractions().extend([new Drag()]),
      layers: [
        new TileLayer({
          source: new TileJSON({
            url:
              "https://a.tiles.mapbox.com/v4/aj.1x1-degrees.json?secure&access_token=" +
              key,
          }),
        }),
        new VectorLayer({
          source: new VectorSource({
            features: [pointFeature, lineFeature, polygonFeature],
          }),
          style: new Style({
            image: new Icon({
              anchor: [0.5, 46],
              anchorXUnits: "fraction",
              anchorYUnits: "pixels",
              opacity: 0.95,
              src: "data/icon.png",
            }),
            stroke: new Stroke({
              width: 3,
              color: [255, 0, 0, 1],
            }),
            fill: new Fill({
              color: [0, 0, 255, 0.6],
            }),
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 2.自定义地图元素

:::demo

```vue
<template>
  <ol-map id="map" class="map"></ol-map>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
    } = ol
    class OLComponent extends HTMLElement {
      constructor() {
        super()
        this.shadow = this.attachShadow({ mode: "open" })
        const link = document.createElement("link")
        link.setAttribute("rel", "stylesheet")
        link.setAttribute("href", "css/ol.css")
        this.shadow.appendChild(link)
        const style = document.createElement("style")
        style.innerText = `
      :host {
        display: block;
      }
    `
        this.shadow.appendChild(style)
        const div = document.createElement("div")
        div.style.width = "100%"
        div.style.height = "100%"
        this.shadow.appendChild(div)
        this.map = new Map({
          target: div,
          layers: [
            new TileLayer({
              source: new OSM(),
            }),
          ],
          view: new View({
            center: [0, 0],
            zoom: 2,
          }),
        })
      }
    }

    customElements.define("ol-map", OLComponent)
  },
}
</script>
```

:::

## 3.自定义概览地图

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <label
      ><input type="checkbox" id="rotateWithView" /> Rotate with view</label
    >
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      control: { OverviewMap, defaults: defaultControls },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      interaction: { DragRotateAndZoom, defaults: defaultInteractions },
    } = ol
    const rotateWithView = document.getElementById("rotateWithView")

    const overviewMapControl = new OverviewMap({
      // see in overviewmap-custom.html to see the custom CSS used
      className: "ol-overviewmap ol-custom-overviewmap",
      layers: [
        new TileLayer({
          source: new OSM({
            url:
              "https://{a-c}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png" +
              "?apikey=Your API key from https://www.thunderforest.com/docs/apikeys/ here",
          }),
        }),
      ],
      collapseLabel: "\u00BB",
      label: "\u00AB",
      collapsed: false,
    })

    rotateWithView.addEventListener("change", function () {
      overviewMapControl.setRotateWithView(this.checked)
    })

    const map = new Map({
      controls: defaultControls().extend([overviewMapControl]),
      interactions: defaultInteractions().extend([new DragRotateAndZoom()]),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [500000, 6000000],
        zoom: 7,
      }),
    })
  },
}
</script>
```

:::

## 4.自定义多边形样式

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      geom: { MultiPoint },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
    } = ol
    const styles = [
      new Style({
        stroke: new Stroke({
          color: "blue",
          width: 3,
        }),
        fill: new Fill({
          color: "rgba(0, 0, 255, 0.1)",
        }),
      }),
      new Style({
        image: new CircleStyle({
          radius: 5,
          fill: new Fill({
            color: "orange",
          }),
        }),
        geometry: function (feature) {
          // return the coordinates of the first ring of the polygon
          const coordinates = feature.getGeometry().getCoordinates()[0]
          return new MultiPoint(coordinates)
        },
      }),
    ]

    const geojsonObject = {
      type: "FeatureCollection",
      crs: {
        type: "name",
        properties: {
          name: "EPSG:3857",
        },
      },
      features: [
        {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [
              [
                [-5e6, 6e6],
                [-5e6, 8e6],
                [-3e6, 8e6],
                [-3e6, 6e6],
                [-5e6, 6e6],
              ],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [
              [
                [-2e6, 6e6],
                [-2e6, 8e6],
                [0, 8e6],
                [0, 6e6],
                [-2e6, 6e6],
              ],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [
              [
                [1e6, 6e6],
                [1e6, 8e6],
                [3e6, 8e6],
                [3e6, 6e6],
                [1e6, 6e6],
              ],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [
              [
                [-2e6, -1e6],
                [-1e6, 1e6],
                [0, -1e6],
                [-2e6, -1e6],
              ],
            ],
          },
        },
      ],
    }

    const source = new VectorSource({
      features: new GeoJSON().readFeatures(geojsonObject),
    })

    const layer = new VectorLayer({
      source: source,
      style: styles,
    })

    const map = new Map({
      layers: [layer],
      target: this.$refs.map,
      view: new View({
        center: [0, 3000000],
        zoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 5.定制瓷砖 WMS

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { TileWMS },
      control: { ScaleLine, defaults: defaultControls },
      proj: { Projection, addCoordinateTransforms, addProjection, transform },
    } = ol
    const projection = new Projection({
      code: "EPSG:21781",
      // The extent is used to determine zoom level 0. Recommended values for a
      // projection's validity extent can be found at https://epsg.io/.
      extent: [485869.5728, 76443.1884, 837076.5648, 299941.7864],
      units: "m",
    })
    addProjection(projection)

    // We also declare EPSG:21781/EPSG:4326 transform functions. These functions
    // are necessary for the ScaleLine control and when calling ol/proj~transform
    // for setting the view's initial center (see below).

    addCoordinateTransforms(
      "EPSG:4326",
      projection,
      function (coordinate) {
        return [
          WGStoCHy(coordinate[1], coordinate[0]),
          WGStoCHx(coordinate[1], coordinate[0]),
        ]
      },
      function (coordinate) {
        return [
          CHtoWGSlng(coordinate[0], coordinate[1]),
          CHtoWGSlat(coordinate[0], coordinate[1]),
        ]
      }
    )

    const extent = [420000, 30000, 900000, 350000]
    const layers = [
      new TileLayer({
        extent: extent,
        source: new TileWMS({
          url: "https://wms.geo.admin.ch/",
          crossOrigin: "anonymous",
          attributions:
            '© <a href="https://shop.swisstopo.admin.ch/en/products/maps/national/lk1000"' +
            'target="_blank">Pixelmap 1:1000000 / geo.admin.ch</a>',
          params: {
            LAYERS: "ch.swisstopo.pixelkarte-farbe-pk1000.noscale",
            FORMAT: "image/jpeg",
          },
          serverType: "mapserver",
        }),
      }),
      new TileLayer({
        extent: extent,
        source: new TileWMS({
          url: "https://wms.geo.admin.ch/",
          crossOrigin: "anonymous",
          attributions:
            '© <a href="https://www.hydrodaten.admin.ch/en/notes-on-the-flood-alert-maps.html"' +
            'target="_blank">Flood Alert / geo.admin.ch</a>',
          params: { LAYERS: "ch.bafu.hydroweb-warnkarte_national" },
          serverType: "mapserver",
        }),
      }),
    ]

    const map = new Map({
      controls: defaultControls().extend([
        new ScaleLine({
          units: "metric",
        }),
      ]),
      layers: layers,
      target: this.$refs.map,
      view: new View({
        projection: projection,
        center: transform([8.23, 46.86], "EPSG:4326", "EPSG:21781"),
        extent: extent,
        zoom: 2,
      }),
    })

    /*
     * Swiss projection transform functions downloaded from
     * https://www.swisstopo.admin.ch/en/knowledge-facts/surveying-geodesy/reference-systems/map-projections.html
     */

    // Convert WGS lat/long (° dec) to CH y
    function WGStoCHy(lat, lng) {
      // Converts degrees dec to sex
      lat = DECtoSEX(lat)
      lng = DECtoSEX(lng)

      // Converts degrees to seconds (sex)
      lat = DEGtoSEC(lat)
      lng = DEGtoSEC(lng)

      // Axillary values (% Bern)
      const lat_aux = (lat - 169028.66) / 10000
      const lng_aux = (lng - 26782.5) / 10000

      // Process Y
      const y =
        600072.37 +
        211455.93 * lng_aux -
        10938.51 * lng_aux * lat_aux -
        0.36 * lng_aux * Math.pow(lat_aux, 2) -
        44.54 * Math.pow(lng_aux, 3)

      return y
    }

    // Convert WGS lat/long (° dec) to CH x
    function WGStoCHx(lat, lng) {
      // Converts degrees dec to sex
      lat = DECtoSEX(lat)
      lng = DECtoSEX(lng)

      // Converts degrees to seconds (sex)
      lat = DEGtoSEC(lat)
      lng = DEGtoSEC(lng)

      // Axillary values (% Bern)
      const lat_aux = (lat - 169028.66) / 10000
      const lng_aux = (lng - 26782.5) / 10000

      // Process X
      const x =
        200147.07 +
        308807.95 * lat_aux +
        3745.25 * Math.pow(lng_aux, 2) +
        76.63 * Math.pow(lat_aux, 2) -
        194.56 * Math.pow(lng_aux, 2) * lat_aux +
        119.79 * Math.pow(lat_aux, 3)

      return x
    }

    // Convert CH y/x to WGS lat
    function CHtoWGSlat(y, x) {
      // Converts military to civil and to unit = 1000km
      // Axillary values (% Bern)
      const y_aux = (y - 600000) / 1000000
      const x_aux = (x - 200000) / 1000000

      // Process lat
      let lat =
        16.9023892 +
        3.238272 * x_aux -
        0.270978 * Math.pow(y_aux, 2) -
        0.002528 * Math.pow(x_aux, 2) -
        0.0447 * Math.pow(y_aux, 2) * x_aux -
        0.014 * Math.pow(x_aux, 3)

      // Unit 10000" to 1 " and converts seconds to degrees (dec)
      lat = (lat * 100) / 36

      return lat
    }

    // Convert CH y/x to WGS long
    function CHtoWGSlng(y, x) {
      // Converts military to civil and to unit = 1000km
      // Axillary values (% Bern)
      const y_aux = (y - 600000) / 1000000
      const x_aux = (x - 200000) / 1000000

      // Process long
      let lng =
        2.6779094 +
        4.728982 * y_aux +
        0.791484 * y_aux * x_aux +
        0.1306 * y_aux * Math.pow(x_aux, 2) -
        0.0436 * Math.pow(y_aux, 3)

      // Unit 10000" to 1 " and converts seconds to degrees (dec)
      lng = (lng * 100) / 36

      return lng
    }

    // Convert DEC angle to SEX DMS
    function DECtoSEX(angle) {
      // Extract DMS
      const deg = parseInt(angle, 10)
      const min = parseInt((angle - deg) * 60, 10)
      const sec = ((angle - deg) * 60 - min) * 60

      // Result in degrees sex (dd.mmss)
      return deg + min / 100 + sec / 10000
    }

    // Convert Degrees angle to seconds
    function DEGtoSEC(angle) {
      // Extract DMS
      const deg = parseInt(angle, 10)
      let min = parseInt((angle - deg) * 100, 10)
      let sec = ((angle - deg) * 100 - min) * 100

      // Avoid rounding problems with seconds=0
      const parts = String(angle).split(".")
      if (parts.length == 2 && parts[1].length == 2) {
        min = Number(parts[1])
        sec = 0
      }

      // Result in degrees sex (dd.mmss)
      return sec + min * 60 + deg * 3600
    }
  },
}
</script>
```

:::
