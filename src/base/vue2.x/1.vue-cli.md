---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 一.ArcGIS

## 1.瓦片 ArcGIS MapServer

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM, TileArcGISRest },
    } = ol
    const url =
      "https://sampleserver1.arcgisonline.com/ArcGIS/rest/services/" +
      "Specialty/ESRI_StateCityHighway_USA/MapServer"

    const layers = [
      new TileLayer({
        source: new OSM(),
      }),
      new TileLayer({
        extent: [-13884991, 2870341, -7455066, 6338219],
        source: new TileArcGISRest({
          url: url,
        }),
      }),
    ]
    const map = new Map({
      layers: layers,
      target: this.$refs.map,
      view: new View({
        center: [-10997148, 4569099],
        zoom: 4,
      }),
    })
  },
}
</script>
```

:::

## 5.ArcGIS REST 功能服务

:::demo

```vue
<template>
  <div>
    <div ref="map" class="map"></div>
    <div ref="info">&nbsp;</div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { EsriJSON },
      Feature,
      Map,
      Point,
      View,
      tilegrid: { createXYZ },
      proj: { fromLonLat },
      loadingstrategy: { tile: tileStrategy },
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
      style: { Fill, Stroke, Style },
    } = ol

    const serviceUrl =
      "https://sampleserver3.arcgisonline.com/ArcGIS/rest/services/" +
      "Petroleum/KSFields/FeatureServer/"
    const layer = "0"
    const esrijsonFormat = new EsriJSON()
    const styleCache = {
      ABANDONED: new Style({
        fill: new Fill({
          color: "rgba(225, 225, 225, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(0, 0, 0, 255)",
          width: 0.4,
        }),
      }),
      GAS: new Style({
        fill: new Fill({
          color: "rgba(255, 0, 0, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(110, 110, 110, 255)",
          width: 0.4,
        }),
      }),
      OIL: new Style({
        fill: new Fill({
          color: "rgba(56, 168, 0, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(110, 110, 110, 255)",
          width: 0,
        }),
      }),
      OILGAS: new Style({
        fill: new Fill({
          color: "rgba(168, 112, 0, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(110, 110, 110, 255)",
          width: 0.4,
        }),
      }),
    }
    const vectorSource = new VectorSource({
      loader: function (extent, resolution, projection, success, failure) {
        const url =
          serviceUrl +
          layer +
          "/query/?f=json&" +
          "returnGeometry=true&spatialRel=esriSpatialRelIntersects&geometry=" +
          encodeURIComponent(
            '{"xmin":' +
              extent[0] +
              ',"ymin":' +
              extent[1] +
              ',"xmax":' +
              extent[2] +
              ',"ymax":' +
              extent[3] +
              ',"spatialReference":{"wkid":102100}}'
          ) +
          "&geometryType=esriGeometryEnvelope&inSR=102100&outFields=*" +
          "&outSR=102100"
        $.ajax({
          url: url,
          dataType: "jsonp",
          success: function (response) {
            if (response.error) {
              alert(
                response.error.message +
                  "\n" +
                  response.error.details.join("\n")
              )
              failure()
            } else {
              const features = esrijsonFormat.readFeatures(response, {
                featureProjection: projection,
              })
              if (features.length > 0) {
                vectorSource.addFeatures(features)
              }
              success(features)
            }
          },
          error: failure,
        })
      },
      strategy: tileStrategy(
        createXYZ({
          tileSize: 512,
        })
      ),
    })
    const vector = new VectorLayer({
      source: vectorSource,
      style: function (feature) {
        const classify = feature.get("activeprod")
        return styleCache[classify]
      },
    })
    const raster = new TileLayer({
      source: new XYZ({
        attributions:
          'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/' +
          'rest/services/World_Topo_Map/MapServer">ArcGIS</a>',
        url:
          "https://server.arcgisonline.com/ArcGIS/rest/services/" +
          "World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
      }),
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-97.6114, 38.8403]),
        zoom: 7,
      }),
    })
    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          info.push(features[i].get("field_name"))
        }
        this.$refs.info.innerHTML = info.join(", ") || "(unknown)"
        map.getTarget().style.cursor = "pointer"
      } else {
        this.$refs.info.innerHTML = "&nbsp;"
        map.getTarget().style.cursor = ""
      }
    }.bind(this)
    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })
    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
  },
}
</script>
```

:::

## 1.512x512 瓦片图

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
    } = ol
    new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: "Copyright:© 2013 ESRI, i-cubed, GeoEye",
            url:
              "https://services.arcgisonline.com/arcgis/rest/services/" +
              "ESRI_Imagery_World_2D/MapServer/tile/{z}/{y}/{x}",
            maxZoom: 15,
            projection: "EPSG:4326",
            tileSize: 512,
            maxResolution: 180 / 512,
            wrapX: true,
          }),
        }),
      ],
      view: new View({
        center: [12579156, 3274244],
        projection: "EPSG:4326",
        zoom: 2,
        minZoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 3.带对比度拉伸

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div class="controls">
    <label for="red">Red channel</label>
    <select id="red">
      <option value="1" selected>visible red</option>
      <option value="2">visible green</option>
      <option value="3">visible blue</option>
      <option value="4">near infrared</option>
    </select>
    <label
      >max
      <input type="range" id="redMax" value="3000" min="2000" max="5000" />
    </label>
    <label for="green">Green channel</label>
    <select id="green">
      <option value="1">visible red</option>
      <option value="2" selected>visible green</option>
      <option value="3">visible blue</option>
      <option value="4">near infrared</option>
    </select>
    <label
      >max
      <input type="range" id="greenMax" value="3000" min="2000" max="5000" />
    </label>
    <label for="blue">Blue channel</label>
    <select id="blue">
      <option value="1">visible red</option>
      <option value="2">visible green</option>
      <option value="3" selected>visible blue</option>
      <option value="4">near infrared</option>
    </select>
    <label
      >max
      <input type="range" id="blueMax" value="3000" min="2000" max="5000" />
    </label>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { GeoTIFF },
    } = ol
    const channels = ["red", "green", "blue"]
    for (const channel of channels) {
      const selector = document.getElementById(channel)
      selector.addEventListener("change", update)

      const input = document.getElementById(`${channel}Max`)
      input.addEventListener("input", update)
    }
    function getVariables() {
      const variables = {}
      for (const channel of channels) {
        const selector = document.getElementById(channel)
        variables[channel] = parseInt(selector.value, 10)

        const inputId = `${channel}Max`
        const input = document.getElementById(inputId)
        variables[inputId] = parseInt(input.value, 10)
      }
      return variables
    }
    const layer = new TileLayer({
      style: {
        variables: getVariables(),
        color: [
          "array",
          ["/", ["band", ["var", "red"]], ["var", "redMax"]],
          ["/", ["band", ["var", "green"]], ["var", "greenMax"]],
          ["/", ["band", ["var", "blue"]], ["var", "blueMax"]],
          1,
        ],
      },
      source: new GeoTIFF({
        normalize: false,
        sources: [
          {
            url: "https://s2downloads.eox.at/demo/EOxCloudless/2020/rgbnir/s2cloudless2020-16bits_sinlge-file_z0-4.tif",
          },
        ],
      }),
    })
    function update() {
      layer.updateStyleVariables(getVariables())
    }
    const map = new Map({
      target: this.$refs.map,
      layers: [layer],
      view: new View({
        projection: "EPSG:4326",
        center: [12579156, 3274244],
        zoom: 2,
        maxZoom: 6,
      }),
    })
  },
}
</script>
```

:::

## 5.选框

使用 DragBox 交互来选择特征。所选特征被添加到选择交互 ( ol/interaction/Select) 的特征叠加中以突出显示

使用 Ctrl+Drag(Command+Drag 在 Mac 上) 绘制框

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>Selected regions: <span ref="info">None</span></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      interaction: { DragBox, Select },
      style: { Fill, Stroke, Style },
      events: { condition: platformModifierKeyOnly },
    } = ol
    const vectorSource = new VectorSource({
      url: "https://openlayers.org/data/vector/ecoregions.json",
      format: new GeoJSON(),
    })
    const style = new Style({
      fill: new Fill({
        color: "#eeeeee",
      }),
    })
    const map = new Map({
      layers: [
        new VectorLayer({
          source: vectorSource,
          background: "#1a2b39",
          style: function (feature) {
            const color = feature.get("COLOR_BIO") || "#eeeeee"
            style.getFill().setColor(color)
            return style
          },
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
        constrainRotation: 16,
      }),
    })
    const selectedStyle = new Style({
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.6)",
      }),
      stroke: new Stroke({
        color: "rgba(255, 255, 255, 0.7)",
        width: 2,
      }),
    })
    const select = new Select({
      style: function (feature) {
        const color = feature.get("COLOR_BIO") || "#eeeeee"
        selectedStyle.getFill().setColor(color)
        return selectedStyle
      },
    })
    map.addInteraction(select)
    const selectedFeatures = select.getFeatures()
    const dragBox = new DragBox({
      condition: platformModifierKeyOnly,
    })
    map.addInteraction(dragBox)
    dragBox.on("boxend", function () {
      const extent = dragBox.getGeometry().getExtent()
      const boxFeatures = vectorSource
        .getFeaturesInExtent(extent)
        .filter((feature) => feature.getGeometry().intersectsExtent(extent))
      const rotation = map.getView().getRotation()
      const oblique = rotation % (Math.PI / 2) !== 0
      if (oblique) {
        const anchor = [0, 0]
        const geometry = dragBox.getGeometry().clone()
        geometry.rotate(-rotation, anchor)
        const extent = geometry.getExtent()
        boxFeatures.forEach(function (feature) {
          const geometry = feature.getGeometry().clone()
          geometry.rotate(-rotation, anchor)
          if (geometry.intersectsExtent(extent)) {
            selectedFeatures.push(feature)
          }
        })
      } else {
        selectedFeatures.extend(boxFeatures)
      }
    })
    dragBox.on("boxstart", function () {
      selectedFeatures.clear()
    })
    const infoBox = this.$refs.info
    selectedFeatures.on(["add", "remove"], function () {
      const names = selectedFeatures.getArray().map(function (feature) {
        return feature.get("ECO_NAME")
      })
      if (names.length > 0) {
        infoBox.innerHTML = names.join(", ")
      } else {
        infoBox.innerHTML = "None"
      }
    })
  },
}
</script>
```

:::
