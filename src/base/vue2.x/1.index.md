---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
rightAnchor:
  showDepth: 1
  customClass: your-customClass
---

# 综合案例

## 2.高级地图框矢量图

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { MVT },
      Map,
      tilegrid: { TileGrid },
      View,
      layer: { VectorTile: VectorTileLayer },
      source: { VectorTile: VectorTileSource },
      style: { Fill, Icon, Stroke, Style, Text },
      proj: { get: getProjection },
    } = ol
    const key ="pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const resolutions = []
    for (let i = 0; i <= 8; ++i) {
      resolutions.push(156543.03392804097 / Math.pow(2, i * 2))
    }
    function tileUrlFunction(tileCoord) {
      return (
        "https://{a-d}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/" +
        "{z}/{x}/{y}.vector.pbf?access_token=" +
        key
      ).replace("{z}", String(tileCoord[0] * 2 - 1))
        .replace("{x}", String(tileCoord[1]))
        .replace("{y}", String(tileCoord[2]))
        .replace("{a-d}","abcd".substr(((tileCoord[1] << tileCoord[0]) + tileCoord[2]) % 4, 1)
      )
    }
    new Map({
      layers: [
        new VectorTileLayer({
          source: new VectorTileSource({
            attributions:
              '© <a href="https://www.mapbox.com/map-feedback/">Mapbox</a> ' +
              '© <a href="https://www.openstreetmap.org/copyright">' +
              "OpenStreetMap contributors</a>",
            format: new MVT(),
            tileGrid: new TileGrid({
              extent: getProjection("EPSG:3857").getExtent(),
              resolutions: resolutions,
              tileSize: 512,
            }),
            tileUrlFunction: tileUrlFunction,
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        minZoom: 1,
        zoom: 2,
      }),
    })
  },
}
</script>
```

:::

## 3.高级视图定位

:::demo

```vue
<template>
  <div class="mapcontainer">
    <div ref="map" class="map"></div>
    <div class="padding-top"></div>
    <div class="padding-left"></div>
    <div class="padding-right"></div>
    <div class="padding-bottom"></div>
    <div class="center"></div>
  </div>
  <button ref="zoomtoswitzerland">缩放到瑞士</button> 最佳匹配
  <button ref="zoomtolausanne">缩放到洛桑</button> 最小分辨率
  <button ref="centerlausanne">洛桑中心</button>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
    } = ol
    const source = new VectorSource({
      url: "data/geojson/switzerland.geojson",
      format: new GeoJSON(),
    })
    const style = new Style({
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.6)",
      }),
      stroke: new Stroke({
        color: "#319FD3",
        width: 1,
      }),
      image: new CircleStyle({
        radius: 5,
        fill: new Fill({
          color: "rgba(255, 255, 255, 0.6)",
        }),
        stroke: new Stroke({
          color: "#319FD3",
          width: 1,
        }),
      }),
    })
    const vectorLayer = new VectorLayer({
      source: source,
      style: style,
    })
    const view = new View({
      center:[12579156, 3274244],
      zoom: 1,
    })
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
        vectorLayer,
      ],
      target: this.$refs.map,
      view: view,
    })
    this.$refs.zoomtoswitzerland.addEventListener(
      "click",
      function () {
        const feature = source.getFeatures()[0]
        const polygon = feature.getGeometry()
        view.fit(polygon, { padding: [170, 50, 30, 150] })
      },
      false
    )
    this.$refs.zoomtolausanne.addEventListener(
      "click",
      function () {
        const feature = source.getFeatures()[1]
        const point = feature.getGeometry()
        view.fit(point, { padding: [170, 50, 30, 150], minResolution: 50 })
      },
      false
    )
    this.$refs.centerlausanne.addEventListener(
      "click",
      function () {
        const feature = source.getFeatures()[1]
        const point = feature.getGeometry()
        const size = map.getSize()
        view.centerOn(point.getCoordinates(), size, [570, 500])
      },
      false
    )
  },
}
</script>
```

:::

## 4.动画 GIF

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  beforeCreate() {
    function appendJQCDN(src) {
    //   var head = document.head || document.getElementsByTagName("head")[0]
    //   if (src.indexOf("js") == -1) {
    //     //css
    //     var style = document.createElement("style")
    //     style.setAttribute("rel", "stylesheet")
    //     style.setAttribute("href", src)
    //     head.appendChild(style)
    //   } else {
    //     var script = document.createElement("script")
    //     script.type = "text/javascript"
    //     script.setAttribute("src", src)
    //     head.appendChild(script)
    //   }
    // }
    // appendJQCDN("https://unpkg.com/elm-pep@1.0.6/dist/elm-pep.js")
    // appendJQCDN("https://cdn.polyfill.io/v3/polyfill.min.js?features=fetch,requestAnimationFrame,Element.prototype.classList,TextDecoder")
    // appendJQCDN("https://cdnjs.cloudflare.com/ajax/libs/core-js/3.18.3/minified.js")
    // appendJQCDN("https://unpkg.com/gifler@0.1.0/gifler.min.js")
  },
  mounted() {
    let {
      Feature,
      Map,
      Point,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { Stamen, Vector: VectorSource },
      style: { Icon, Style },
    } = ol
    const iconFeature = new Feature({
      geometry: new Point([0, 0]),
    })
    const vectorSource = new VectorSource({
      features: [iconFeature],
    })
    const vectorLayer = new VectorLayer({
      source: vectorSource,
    })
    const rasterLayer = new TileLayer({
      source: new Stamen({
        layer: "toner",
      }),
    })
    const map = new Map({
      layers: [rasterLayer, vectorLayer],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })
    const gifUrl = "data/globe.gif"
    const gif = gifler(gifUrl)
    gif.frames(
      document.createElement("canvas"),
      function (ctx, frame) {
        if (!iconFeature.getStyle()) {
          iconFeature.setStyle(
            new Style({
              image: new Icon({
                img: ctx.canvas,
                imgSize: [frame.width, frame.height],
                opacity: 0.8,
              }),
            })
          )
        }
        ctx.clearRect(0, 0, frame.width, frame.height)
        ctx.drawImage(frame.buffer, frame.x, frame.y)
        map.render()
      },
      true
    )
    map.on("pointermove", function (e) {
      const pixel = map.getEventPixel(e.originalEvent)
      const hit = map.hasFeatureAtPixel(pixel)
      map.getTarget().style.cursor = hit ? "pointer" : ""
    })
  },
}
</script>
```

:::

## 5.ArcGIS REST 功能服务

:::demo

```vue
<template>
  <div>
    <div ref="map" class="map"></div>
    <div ref="info">&nbsp;</div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { EsriJSON },
      Feature,
      Map,
      Point,
      View,
      tilegrid: { createXYZ },
      proj: { fromLonLat },
      loadingstrategy: { tile: tileStrategy },
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
      style: { Fill, Stroke, Style },
    } = ol

    const serviceUrl =
      "https://sampleserver3.arcgisonline.com/ArcGIS/rest/services/" +
      "Petroleum/KSFields/FeatureServer/"
    const layer = "0"
    const esrijsonFormat = new EsriJSON()
    const styleCache = {
      ABANDONED: new Style({
        fill: new Fill({
          color: "rgba(225, 225, 225, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(0, 0, 0, 255)",
          width: 0.4,
        }),
      }),
      GAS: new Style({
        fill: new Fill({
          color: "rgba(255, 0, 0, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(110, 110, 110, 255)",
          width: 0.4,
        }),
      }),
      OIL: new Style({
        fill: new Fill({
          color: "rgba(56, 168, 0, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(110, 110, 110, 255)",
          width: 0,
        }),
      }),
      OILGAS: new Style({
        fill: new Fill({
          color: "rgba(168, 112, 0, 255)",
        }),
        stroke: new Stroke({
          color: "rgba(110, 110, 110, 255)",
          width: 0.4,
        }),
      }),
    }
    const vectorSource = new VectorSource({
      loader: function (extent, resolution, projection, success, failure) {
        const url =
          serviceUrl +
          layer +
          "/query/?f=json&" +
          "returnGeometry=true&spatialRel=esriSpatialRelIntersects&geometry=" +
          encodeURIComponent(
            '{"xmin":' +
              extent[0] +
              ',"ymin":' +
              extent[1] +
              ',"xmax":' +
              extent[2] +
              ',"ymax":' +
              extent[3] +
              ',"spatialReference":{"wkid":102100}}'
          ) +
          "&geometryType=esriGeometryEnvelope&inSR=102100&outFields=*" +
          "&outSR=102100"
        $.ajax({
          url: url,
          dataType: "jsonp",
          success: function (response) {
            if (response.error) {
              alert(
                response.error.message +
                  "\n" +
                  response.error.details.join("\n")
              )
              failure()
            } else {
              const features = esrijsonFormat.readFeatures(response, {
                featureProjection: projection,
              })
              if (features.length > 0) {
                vectorSource.addFeatures(features)
              }
              success(features)
            }
          },
          error: failure,
        })
      },
      strategy: tileStrategy(
        createXYZ({
          tileSize: 512,
        })
      ),
    })
    const vector = new VectorLayer({
      source: vectorSource,
      style: function (feature) {
        const classify = feature.get("activeprod")
        return styleCache[classify]
      },
    })
    const raster = new TileLayer({
      source: new XYZ({
        attributions:
          'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/' +
          'rest/services/World_Topo_Map/MapServer">ArcGIS</a>',
        url:
          "https://server.arcgisonline.com/ArcGIS/rest/services/" +
          "World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
      }),
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-97.6114, 38.8403]),
        zoom: 7,
      }),
    })
    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          info.push(features[i].get("field_name"))
        }
        this.$refs.info.innerHTML = info.join(", ") || "(unknown)"
        map.getTarget().style.cursor = "pointer"
      } else {
        this.$refs.info.innerHTML = "&nbsp;"
        map.getTarget().style.cursor = ""
      }
    }
    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })
    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
  },
}
</script>
```

:::
