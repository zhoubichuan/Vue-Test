---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十六.案例16

## 1.可重复使用的来源

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <button class="switcher" value="0">January</button>
  <button class="switcher" value="1">January (with bathymetry)</button>
  <button class="switcher" value="2">July</button>
  <button class="switcher" value="3">July (with bathymetry)</button>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
    } = ol
    const key = "Your Mapbox access token from https://mapbox.com/ here"
    const baseUrl = "https://{a-c}.tiles.mapbox.com/v4"
    const urls = [
      baseUrl +
        "/mapbox.blue-marble-topo-jan/{z}/{x}/{y}.png?access_token=" +
        key,
      baseUrl +
        "/mapbox.blue-marble-topo-bathy-jan/{z}/{x}/{y}.png?access_token=" +
        key,
      baseUrl +
        "/mapbox.blue-marble-topo-jul/{z}/{x}/{y}.png?access_token=" +
        key,
      baseUrl +
        "/mapbox.blue-marble-topo-bathy-jul/{z}/{x}/{y}.png?access_token=" +
        key,
    ]

    const source = new XYZ()

    const map = new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          source: source,
        }),
      ],
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })

    function updateUrl(index) {
      source.setUrl(urls[index])
    }

    const buttons = document.getElementsByClassName("switcher")
    for (let i = 0, ii = buttons.length; i < ii; ++i) {
      const button = buttons[i]
      button.addEventListener(
        "click",
        updateUrl.bind(null, Number(button.value))
      )
    }

    updateUrl(0)
  },
}
</script>
```

:::

## 2.富文本标签

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: { Fill, Stroke, Style, Text },
    } = ol

    const map = new Map({
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
        extent: [-13882269, 2890586, -7456136, 6340207],
        showFullExtent: true,
      }),
    })

    const labelStyle = new Style({
      text: new Text({
        font: "13px Calibri,sans-serif",
        fill: new Fill({
          color: "#000",
        }),
        stroke: new Stroke({
          color: "#fff",
          width: 4,
        }),
      }),
    })
    const countryStyle = new Style({
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.6)",
      }),
      stroke: new Stroke({
        color: "#319FD3",
        width: 1,
      }),
    })
    const style = [countryStyle, labelStyle]

    const vectorLayer = new VectorLayer({
      background: "white",
      source: new VectorSource({
        url: "https://openlayers.org/data/vector/us-states.json",
        format: new GeoJSON(),
      }),
      style: function (feature) {
        labelStyle
          .getText()
          .setText([
            feature.getId(),
            "bold 13px Calibri,sans-serif",
            ` ${feature.get("name")}`,
            "",
            "\n",
            "",
            `${feature.get("density")} people/mi²`,
            "italic 11px Calibri,sans-serif",
          ])
        return style
      },
    })

    map.addLayer(vectorLayer)
  },
}
</script>
```

:::

## 3.使用修改交互进行缩放和旋转

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">Geometry type &nbsp;</label>
    <select id="type">
      <option value="Point">Point</option>
      <option value="LineString">LineString</option>
      <option value="Polygon" selected>Polygon</option>
      <option value="Circle">Circle</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { MultiPoint, Point },
      interaction: { Draw, Modify, Translate },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      extent: { getCenter, getHeight, getWidth },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })

    const source = new VectorSource()

    const style = new Style({
      geometry: function (feature) {
        const modifyGeometry = feature.get("modifyGeometry")
        return modifyGeometry ? modifyGeometry.geometry : feature.getGeometry()
      },
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.2)",
      }),
      stroke: new Stroke({
        color: "#ffcc33",
        width: 2,
      }),
      image: new CircleStyle({
        radius: 7,
        fill: new Fill({
          color: "#ffcc33",
        }),
      }),
    })

    function calculateCenter(geometry) {
      let center, coordinates, minRadius
      const type = geometry.getType()
      if (type === "Polygon") {
        let x = 0
        let y = 0
        let i = 0
        coordinates = geometry.getCoordinates()[0].slice(1)
        coordinates.forEach(function (coordinate) {
          x += coordinate[0]
          y += coordinate[1]
          i++
        })
        center = [x / i, y / i]
      } else if (type === "LineString") {
        center = geometry.getCoordinateAt(0.5)
        coordinates = geometry.getCoordinates()
      } else {
        center = getCenter(geometry.getExtent())
      }
      let sqDistances
      if (coordinates) {
        sqDistances = coordinates.map(function (coordinate) {
          const dx = coordinate[0] - center[0]
          const dy = coordinate[1] - center[1]
          return dx * dx + dy * dy
        })
        minRadius = Math.sqrt(Math.max.apply(Math, sqDistances)) / 3
      } else {
        minRadius =
          Math.max(
            getWidth(geometry.getExtent()),
            getHeight(geometry.getExtent())
          ) / 3
      }
      return {
        center: center,
        coordinates: coordinates,
        minRadius: minRadius,
        sqDistances: sqDistances,
      }
    }

    const vector = new VectorLayer({
      source: source,
      style: function (feature) {
        const styles = [style]
        const modifyGeometry = feature.get("modifyGeometry")
        const geometry = modifyGeometry
          ? modifyGeometry.geometry
          : feature.getGeometry()
        const result = calculateCenter(geometry)
        const center = result.center
        if (center) {
          styles.push(
            new Style({
              geometry: new Point(center),
              image: new CircleStyle({
                radius: 4,
                fill: new Fill({
                  color: "#ff3333",
                }),
              }),
            })
          )
          const coordinates = result.coordinates
          if (coordinates) {
            const minRadius = result.minRadius
            const sqDistances = result.sqDistances
            const rsq = minRadius * minRadius
            const points = coordinates.filter(function (coordinate, index) {
              return sqDistances[index] > rsq
            })
            styles.push(
              new Style({
                geometry: new MultiPoint(points),
                image: new CircleStyle({
                  radius: 4,
                  fill: new Fill({
                    color: "#33cc33",
                  }),
                }),
              })
            )
          }
        }
        return styles
      },
    })

    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 4,
      }),
    })

    const defaultStyle = new Modify({ source: source })
      .getOverlay()
      .getStyleFunction()

    const modify = new Modify({
      source: source,
      condition: function (event) {
        return primaryAction(event) && !platformModifierKeyOnly(event)
      },
      deleteCondition: never,
      insertVertexCondition: never,
      style: function (feature) {
        feature.get("features").forEach(function (modifyFeature) {
          const modifyGeometry = modifyFeature.get("modifyGeometry")
          if (modifyGeometry) {
            const point = feature.getGeometry().getCoordinates()
            let modifyPoint = modifyGeometry.point
            if (!modifyPoint) {
              // save the initial geometry and vertex position
              modifyPoint = point
              modifyGeometry.point = modifyPoint
              modifyGeometry.geometry0 = modifyGeometry.geometry
              // get anchor and minimum radius of vertices to be used
              const result = calculateCenter(modifyGeometry.geometry0)
              modifyGeometry.center = result.center
              modifyGeometry.minRadius = result.minRadius
            }

            const center = modifyGeometry.center
            const minRadius = modifyGeometry.minRadius
            let dx, dy
            dx = modifyPoint[0] - center[0]
            dy = modifyPoint[1] - center[1]
            const initialRadius = Math.sqrt(dx * dx + dy * dy)
            if (initialRadius > minRadius) {
              const initialAngle = Math.atan2(dy, dx)
              dx = point[0] - center[0]
              dy = point[1] - center[1]
              const currentRadius = Math.sqrt(dx * dx + dy * dy)
              if (currentRadius > 0) {
                const currentAngle = Math.atan2(dy, dx)
                const geometry = modifyGeometry.geometry0.clone()
                geometry.scale(currentRadius / initialRadius, undefined, center)
                geometry.rotate(currentAngle - initialAngle, center)
                modifyGeometry.geometry = geometry
              }
            }
          }
        })
        return defaultStyle(feature)
      },
    })

    modify.on("modifystart", function (event) {
      event.features.forEach(function (feature) {
        feature.set(
          "modifyGeometry",
          { geometry: feature.getGeometry().clone() },
          true
        )
      })
    })

    modify.on("modifyend", function (event) {
      event.features.forEach(function (feature) {
        const modifyGeometry = feature.get("modifyGeometry")
        if (modifyGeometry) {
          feature.setGeometry(modifyGeometry.geometry)
          feature.unset("modifyGeometry", true)
        }
      })
    })

    map.addInteraction(modify)
    map.addInteraction(
      new Translate({
        condition: function (event) {
          return primaryAction(event) && platformModifierKeyOnly(event)
        },
        layers: [vector],
      })
    )

    let draw // global so we can remove it later
    const typeSelect = document.getElementById("type")

    function addInteractions() {
      draw = new Draw({
        source: source,
        type: typeSelect.value,
      })
      map.addInteraction(draw)
    }

    /**
     * Handle change event.
     */
    typeSelect.onchange = function () {
      map.removeInteraction(draw)
      addInteractions()
    }

    addInteractions()
  },
}
</script>
```

:::

## 4.比例线

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      control: { ScaleLine, defaults: defaultControls },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
    } = ol

    const unitsSelect = document.getElementById("units")
    const typeSelect = document.getElementById("type")
    const stepsSelect = document.getElementById("steps")
    const scaleTextCheckbox = document.getElementById("showScaleText")
    const showScaleTextDiv = document.getElementById("showScaleTextDiv")

    let scaleType = "scaleline"
    let scaleBarSteps = 4
    let scaleBarText = true
    let control

    function scaleControl() {
      if (scaleType === "scaleline") {
        control = new ScaleLine({
          units: unitsSelect.value,
        })
        return control
      }
      control = new ScaleLine({
        units: unitsSelect.value,
        bar: true,
        steps: scaleBarSteps,
        text: scaleBarText,
        minWidth: 140,
      })
      return control
    }
    const map = new Map({
      controls: defaultControls().extend([scaleControl()]),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })

    function onChange() {
      control.setUnits(unitsSelect.value)
    }
    function onChangeType() {
      scaleType = typeSelect.value
      if (typeSelect.value === "scalebar") {
        stepsSelect.style.display = "inline"
        showScaleTextDiv.style.display = "inline"
        map.removeControl(control)
        map.addControl(scaleControl())
      } else {
        stepsSelect.style.display = "none"
        showScaleTextDiv.style.display = "none"
        map.removeControl(control)
        map.addControl(scaleControl())
      }
    }
    function onChangeSteps() {
      scaleBarSteps = parseInt(stepsSelect.value, 10)
      map.removeControl(control)
      map.addControl(scaleControl())
    }
    function onChangeScaleText() {
      scaleBarText = scaleTextCheckbox.checked
      map.removeControl(control)
      map.addControl(scaleControl())
    }
    unitsSelect.addEventListener("change", onChange)
    typeSelect.addEventListener("change", onChangeType)
    stepsSelect.addEventListener("change", onChangeSteps)
    scaleTextCheckbox.addEventListener("change", onChangeScaleText)
  },
}
</script>
```

:::

## 5.海平面

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <label>
    Sea level
    <input id="level" type="range" min="0" max="100" value="1" />
    +<span id="output"></span> m
  </label>
  <br />
  Go to
  <a class="location" data-center="-122.3267,37.8377" data-zoom="11"
    >San Francisco</a
  >,
  <a class="location" data-center="-73.9338,40.6861" data-zoom="11">New York</a
  >,
  <a class="location" data-center="72.9481,18.9929" data-zoom="11">Mumbai</a>,
  or
  <a class="location" data-center="120.831,31.160" data-zoom="9">Shanghai</a>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Image: ImageLayer },
      source: { XYZ, Raster: RasterSource },
      proj: { fromLonLat },
    } = ol

    function flood(pixels, data) {
      const pixel = pixels[0]
      if (pixel[3]) {
        const height =
          -10000 + (pixel[0] * 256 * 256 + pixel[1] * 256 + pixel[2]) * 0.1
        if (height <= data.level) {
          pixel[0] = 134
          pixel[1] = 203
          pixel[2] = 249
          pixel[3] = 255
        } else {
          pixel[3] = 0
        }
      }
      return pixel
    }

    const key = "Get your own API key at https://www.maptiler.com/cloud/"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const elevation = new XYZ({
      // The RGB values in the source collectively represent elevation.
      // Interpolation of individual colors would produce incorrect evelations and is disabled.
      url:
        "https://api.maptiler.com/tiles/terrain-rgb/{z}/{x}/{y}.png?key=" + key,
      tileSize: 512,
      maxZoom: 12,
      crossOrigin: "",
      interpolate: false,
    })

    const raster = new RasterSource({
      sources: [elevation],
      operation: flood,
    })

    const map = new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=" +
              key,
            tileSize: 512,
            maxZoom: 22,
          }),
        }),
        new ImageLayer({
          opacity: 0.6,
          source: raster,
        }),
      ],
      view: new View({
        center: fromLonLat([-122.3267, 37.8377]),
        zoom: 11,
      }),
    })

    const control = document.getElementById("level")
    const output = document.getElementById("output")
    const listener = function () {
      output.innerText = control.value
      raster.changed()
    }
    control.addEventListener("input", listener)
    control.addEventListener("change", listener)
    output.innerText = control.value

    raster.on("beforeoperations", function (event) {
      event.data.level = control.value
    })

    const locations = document.getElementsByClassName("location")
    for (let i = 0, ii = locations.length; i < ii; ++i) {
      locations[i].addEventListener("click", relocate)
    }

    function relocate(event) {
      const data = event.target.dataset
      const view = map.getView()
      view.setCenter(fromLonLat(data.center.split(",").map(Number)))
      view.setZoom(Number(data.zoom))
    }
  },
}
</script>
```

:::
