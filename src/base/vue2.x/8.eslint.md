---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 八.案例 12



## 4.geojson-vt 集成

在浏览器中动态地将 GeoJSON 切片成矢量图块。

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  async mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { VectorTile: VectorTileLayer },
      source: { VectorTile: VectorTileSource },
      style: { Fill, Style },
      proj: { Projection },
    } = ol
    const replacer = function (key, value) {
      if (!value || !value.geometry) {
        return value
      }
      let type
      const rawType = value.type
      let geometry = value.geometry
      if (rawType === 1) {
        type = "MultiPoint"
        if (geometry.length == 1) {
          type = "Point"
          geometry = geometry[0]
        }
      } else if (rawType === 2) {
        type = "MultiLineString"
        if (geometry.length == 1) {
          type = "LineString"
          geometry = geometry[0]
        }
      } else if (rawType === 3) {
        type = "Polygon"
        if (geometry.length > 1) {
          type = "MultiPolygon"
          geometry = [geometry]
        }
      }
      return {
        type: "Feature",
        geometry: {
          type: type,
          coordinates: geometry,
        },
        properties: value.tags,
      }
    }
    const style = new Style({
      fill: new Fill({
        color: "#eeeeee",
      }),
    })
    const layer = new VectorTileLayer({
      background: "#1a2b39",
      style: function (feature) {
        const color = feature.get("COLOR") || "#eeeeee"
        style.getFill().setColor(color)
        return style
      },
    })
    const map = new Map({
      layers: [layer],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })
    const url = "https://openlayers.org/data/vector/ecoregions.json"
    let res = await axios.get(url)
    const tileIndex = geojsonvt(res.data, {
      extent: 4096,
      debug: 1,
    })
    const format = new GeoJSON({
      dataProjection: new Projection({
        code: "TILE_PIXELS",
        units: "tile-pixels",
        extent: [0, 0, 4096, 4096],
      }),
    })
    const vectorSource = new VectorTileSource({
      tileUrlFunction: function (tileCoord) {
        return JSON.stringify(tileCoord)
      },
      tileLoadFunction: function (tile, url) {
        const tileCoord = JSON.parse(url)
        const data = tileIndex.getTile(tileCoord[0], tileCoord[1], tileCoord[2])
        const geojson = JSON.stringify(
          {
            type: "FeatureCollection",
            features: data ? data.features : [],
          },
          replacer
        )
        const features = format.readFeatures(geojson, {
          extent: vectorSource.getTileGrid().getTileCoordExtent(tileCoord),
          featureProjection: map.getView().getProjection(),
        })
        tile.setFeatures(features)
      },
    })
    layer.setSource(vectorSource)
  },
}
</script>
```

:::

## 5.地理位置

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div id="info" style="display: none;"></div>
  <label for="track">
    轨道位置
    <input id="track" type="checkbox" />
  </label>
  <p>
    位置精度 : <code id="accuracy"></code>&nbsp;&nbsp; 海拔高度 :
    <code id="altitude"></code>&nbsp;&nbsp; 高度精度 :
    <code id="altitudeAccuracy"></code>&nbsp;&nbsp; 标题 :
    <code id="heading"></code>&nbsp;&nbsp; 速度 : <code id="speed"></code>
  </p>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      Geolocation,
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
    } = ol

    const view = new View({
      center: [12579156, 3274244],
      zoom: 2,
    })
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: view,
    })
    const geolocation = new Geolocation({
      trackingOptions: {
        enableHighAccuracy: true,
      },
      projection: view.getProjection(),
    })
    function el(id) {
      return document.getElementById(id)
    }
    el("track").addEventListener("change", function () {
      geolocation.setTracking(this.checked)
    })
    geolocation.on("change", function () {
      el("accuracy").innerText = geolocation.getAccuracy() + " [m]"
      el("altitude").innerText = geolocation.getAltitude() + " [m]"
      el("altitudeAccuracy").innerText =
        geolocation.getAltitudeAccuracy() + " [m]"
      el("heading").innerText = geolocation.getHeading() + " [rad]"
      el("speed").innerText = geolocation.getSpeed() + " [m/s]"
    })
    geolocation.on("error", function (error) {
      const info = document.getElementById("info")
      info.innerHTML = error.message
      info.style.display = ""
    })
    const accuracyFeature = new Feature()
    geolocation.on("change:accuracyGeometry", function () {
      accuracyFeature.setGeometry(geolocation.getAccuracyGeometry())
    })
    const positionFeature = new Feature()
    positionFeature.setStyle(
      new Style({
        image: new CircleStyle({
          radius: 6,
          fill: new Fill({
            color: "#3399CC",
          }),
          stroke: new Stroke({
            color: "#fff",
            width: 2,
          }),
        }),
      })
    )
    geolocation.on("change:position", function () {
      const coordinates = geolocation.getPosition()
      positionFeature.setGeometry(coordinates ? new Point(coordinates) : null)
    })
    new VectorLayer({
      map: map,
      source: new VectorSource({
        features: [accuracyFeature, positionFeature],
      }),
    })
  },
}
</script>
```

:::
