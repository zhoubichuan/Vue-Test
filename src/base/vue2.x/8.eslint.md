---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 八.案例 12

## 1.地理坐标

:::demo

```vue
<template>
  <div ref="map" class="map">
    <div id="popup"></div>
  </div>
  <div id="info"></div>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { Point },
      Feature,
      Map,
      Overlay,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle, Fill, Style },
      proj: { useGeographic },
    } = ol
    useGeographic()

    const place = [-110, 45]

    const point = new Point(place)

    const map = new Map({
      target: this.$refs.map,
      view: new View({
        center: place,
        zoom: 8,
      }),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
        new VectorLayer({
          source: new VectorSource({
            features: [new Feature(point)],
          }),
          style: new Style({
            image: new Circle({
              radius: 9,
              fill: new Fill({ color: "red" }),
            }),
          }),
        }),
      ],
    })

    const element = document.getElementById("popup")

    const popup = new Overlay({
      element: element,
      positioning: "bottom-center",
      stopEvent: false,
      offset: [0, -10],
    })
    map.addOverlay(popup)

    function formatCoordinate(coordinate) {
      return `
    <table>
      <tbody>
        <tr><th>lon</th><td>${coordinate[0].toFixed(2)}</td></tr>
        <tr><th>lat</th><td>${coordinate[1].toFixed(2)}</td></tr>
      </tbody>
    </table>`
    }

    const info = document.getElementById("info")
    map.on("moveend", function () {
      const view = map.getView()
      const center = view.getCenter()
      info.innerHTML = formatCoordinate(center)
    })

    map.on("click", function (event) {
      $(element).popover("dispose")

      const feature = map.getFeaturesAtPixel(event.pixel)[0]
      if (feature) {
        const coordinate = feature.getGeometry().getCoordinates()
        popup.setPosition([
          coordinate[0] + Math.round(event.coordinate[0] / 360) * 360,
          coordinate[1],
        ])
        $(element).popover({
          container: element.parentElement,
          html: true,
          sanitize: false,
          content: formatCoordinate(coordinate),
          placement: "top",
        })
        $(element).popover("show")
      }
    })

    map.on("pointermove", function (event) {
      if (map.hasFeatureAtPixel(event.pixel)) {
        map.getViewport().style.cursor = "pointer"
      } else {
        map.getViewport().style.cursor = "inherit"
      }
    })
  },
}
</script>
```

:::

## 4.geojson-vt 集成

在浏览器中动态地将 GeoJSON 切片成矢量图块。

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { VectorTile: VectorTileLayer },
      source: { VectorTile: VectorTileSource },
      style: { Fill, Style },
      proj: { Projection },
    } = ol
    const replacer = function (key, value) {
      if (!value || !value.geometry) {
        return value
      }

      let type
      const rawType = value.type
      let geometry = value.geometry
      if (rawType === 1) {
        type = "MultiPoint"
        if (geometry.length == 1) {
          type = "Point"
          geometry = geometry[0]
        }
      } else if (rawType === 2) {
        type = "MultiLineString"
        if (geometry.length == 1) {
          type = "LineString"
          geometry = geometry[0]
        }
      } else if (rawType === 3) {
        type = "Polygon"
        if (geometry.length > 1) {
          type = "MultiPolygon"
          geometry = [geometry]
        }
      }

      return {
        type: "Feature",
        geometry: {
          type: type,
          coordinates: geometry,
        },
        properties: value.tags,
      }
    }

    const style = new Style({
      fill: new Fill({
        color: "#eeeeee",
      }),
    })

    const layer = new VectorTileLayer({
      background: "#1a2b39",
      style: function (feature) {
        const color = feature.get("COLOR") || "#eeeeee"
        style.getFill().setColor(color)
        return style
      },
    })
    const map = new Map({
      layers: [layer],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })
    const url = "https://openlayers.org/data/vector/ecoregions.json"
    fetch(url)
      .then(function (response) {
        return response.json()
      })
      .then(function (json) {
        const tileIndex = geojsonvt(json, {
          extent: 4096,
          debug: 1,
        })
        const format = new GeoJSON({
          dataProjection: new Projection({
            code: "TILE_PIXELS",
            units: "tile-pixels",
            extent: [0, 0, 4096, 4096],
          }),
        })
        const vectorSource = new VectorTileSource({
          tileUrlFunction: function (tileCoord) {
            return JSON.stringify(tileCoord)
          },
          tileLoadFunction: function (tile, url) {
            const tileCoord = JSON.parse(url)
            const data = tileIndex.getTile(
              tileCoord[0],
              tileCoord[1],
              tileCoord[2]
            )
            const geojson = JSON.stringify(
              {
                type: "FeatureCollection",
                features: data ? data.features : [],
              },
              replacer
            )
            const features = format.readFeatures(geojson, {
              extent: vectorSource.getTileGrid().getTileCoordExtent(tileCoord),
              featureProjection: map.getView().getProjection(),
            })
            tile.setFeatures(features)
          },
        })
        layer.setSource(vectorSource)
      })
  },
}
</script>
```

:::

## 5.地理位置

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div id="info" style="display: none;"></div>
  <label for="track">
    轨道位置
    <input id="track" type="checkbox" />
  </label>
  <p>
    位置精度 : <code id="accuracy"></code>&nbsp;&nbsp; 海拔高度 :
    <code id="altitude"></code>&nbsp;&nbsp; 高度精度 :
    <code id="altitudeAccuracy"></code>&nbsp;&nbsp; 标题 :
    <code id="heading"></code>&nbsp;&nbsp; 速度 : <code id="speed"></code>
  </p>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      Geolocation,
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
    } = ol

    const view = new View({
      center: [12579156, 3274244],
      zoom: 2,
    })
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: view,
    })
    const geolocation = new Geolocation({
      trackingOptions: {
        enableHighAccuracy: true,
      },
      projection: view.getProjection(),
    })
    function el(id) {
      return document.getElementById(id)
    }
    el("track").addEventListener("change", function () {
      geolocation.setTracking(this.checked)
    })
    geolocation.on("change", function () {
      el("accuracy").innerText = geolocation.getAccuracy() + " [m]"
      el("altitude").innerText = geolocation.getAltitude() + " [m]"
      el("altitudeAccuracy").innerText =
        geolocation.getAltitudeAccuracy() + " [m]"
      el("heading").innerText = geolocation.getHeading() + " [rad]"
      el("speed").innerText = geolocation.getSpeed() + " [m/s]"
    })
    geolocation.on("error", function (error) {
      const info = document.getElementById("info")
      info.innerHTML = error.message
      info.style.display = ""
    })
    const accuracyFeature = new Feature()
    geolocation.on("change:accuracyGeometry", function () {
      accuracyFeature.setGeometry(geolocation.getAccuracyGeometry())
    })
    const positionFeature = new Feature()
    positionFeature.setStyle(
      new Style({
        image: new CircleStyle({
          radius: 6,
          fill: new Fill({
            color: "#3399CC",
          }),
          stroke: new Stroke({
            color: "#fff",
            width: 2,
          }),
        }),
      })
    )
    geolocation.on("change:position", function () {
      const coordinates = geolocation.getPosition()
      positionFeature.setGeometry(coordinates ? new Point(coordinates) : null)
    })
    new VectorLayer({
      map: map,
      source: new VectorSource({
        features: [accuracyFeature, positionFeature],
      }),
    })
  },
}
</script>
```

:::
