---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 六.案例10

## 1.互动程度

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { Extent: ExtentInteraction },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      events: { condition: shiftKeyOnly },
    } = ol
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })

    const extent = new ExtentInteraction({ condition: shiftKeyOnly })
    map.addInteraction(extent)
  },
}
</script>
```

:::

## 2.外部地图

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <input id="external-map-button" type="button" value="Open external map"></input>
    <span id="blocker-notice" hidden>Could not open map in external window. If you are using a popup or ad blocker you may need to disable it for this example.</span>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      proj: { fromLonLat },
      control: { Control, FullScreen, defaults: defaultControls },
    } = ol
    class UnusableMask extends Control {
      constructor() {
        super({
          element: document.createElement("div"),
        })
        this.element.setAttribute("hidden", "hidden")
        this.element.className = "ol-mask"
        this.element.innerHTML = "<div>Map not usable</div>"
      }
    }

    const map = new Map({
      target: this.$refs.map,
      controls: defaultControls().extend([
        new FullScreen(),
        new UnusableMask(),
      ]),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      view: new View({
        center: fromLonLat([37.41, 8.82]),
        zoom: 4,
      }),
    })

    let mapWindow
    function closeMapWindow() {
      if (mapWindow) {
        mapWindow.close()
        mapWindow = undefined
      }
    }
    // Close external window in case the main page is closed or reloaded
    window.addEventListener("pagehide", closeMapWindow)

    const button = document.getElementById("external-map-button")

    function resetMapTarget() {
      localMapTarget.style.height = ""
      map.setTarget(localMapTarget)
      button.disabled = false
    }

    function updateOverlay() {
      if (!mapWindow) {
        return
      }
      const externalMapTarget = mapWindow.document.getElementById("map")
      if (!externalMapTarget) {
        return
      }
      if (document.visibilityState === "visible") {
        // Show controls and enable keyboard input
        externalMapTarget.classList.remove("unusable")
        externalMapTarget.setAttribute("tabindex", "0")
        externalMapTarget.focus()
      } else {
        // Hide all controls and disable keyboard input
        externalMapTarget.removeAttribute("tabindex")
        externalMapTarget.classList.add("unusable")
      }
    }
    window.addEventListener("visibilitychange", updateOverlay)

    button.addEventListener("click", function () {
      const blockerNotice = document.getElementById("blocker-notice")
      blockerNotice.setAttribute("hidden", "hidden")
      button.disabled = true

      // Reset button and map target in case window did not load or open
      let timeoutKey = setTimeout(function () {
        closeMapWindow()
        resetMapTarget()
        blockerNotice.removeAttribute("hidden")
        timeoutKey = undefined
      }, 3000)

      mapWindow = window.open(
        "resources/external-map-map.html",
        "MapWindow",
        "toolbar=0,location=0,menubar=0,width=800,height=600"
      )
      mapWindow.addEventListener("DOMContentLoaded", function () {
        const externalMapTarget = mapWindow.document.getElementById("map")
        localMapTarget.style.height = "0px"
        map.setTarget(externalMapTarget)

        if (timeoutKey) {
          timeoutKey = clearTimeout(timeoutKey)
        }
        mapWindow.addEventListener("pagehide", function () {
          resetMapTarget()
          // Close window in case user does a page reload
          closeMapWindow()
        })

        updateOverlay()
      })
    })
  },
}
</script>
```

:::

## 3.使用 WebGL 过滤功能

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form>
    <div id="status">
      Show impacts between <span class="min-year"></span> and
      <span class="max-year"></span>
    </div>

    <label for="min-year">Minimum year:</label>
    <input
      id="min-year"
      type="range"
      min="1850"
      max="2015"
      step="1"
      value="1850"
    />
    <label for="max-year">Maximum year:</label>
    <input
      id="max-year"
      type="range"
      min="1850"
      max="2015"
      step="1"
      value="2015"
    />
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, WebGLPoints: WebGLPointsLayer },
      source: { Stamen, Vector: VectorSource },
      proj: { fromLonLat },
    } = ol
    const vectorSource = new Vector({
      attributions: "NASA",
    })

    const oldColor = "rgba(242,56,22,0.61)"
    const newColor = "#ffe52c"
    const period = 12 // animation period in seconds
    const animRatio = [
      "^",
      [
        "/",
        [
          "%",
          [
            "+",
            ["time"],
            ["interpolate", ["linear"], ["get", "year"], 1850, 0, 2015, period],
          ],
          period,
        ],
        period,
      ],
      0.5,
    ]

    const style = {
      variables: {
        minYear: 1850,
        maxYear: 2015,
      },
      filter: [
        "between",
        ["get", "year"],
        ["var", "minYear"],
        ["var", "maxYear"],
      ],
      symbol: {
        symbolType: "circle",
        size: [
          "*",
          ["interpolate", ["linear"], ["get", "mass"], 0, 8, 200000, 26],
          ["-", 1.75, ["*", animRatio, 0.75]],
        ],
        color: ["interpolate", ["linear"], animRatio, 0, newColor, 1, oldColor],
        opacity: ["-", 1.0, ["*", animRatio, 0.75]],
      },
    }

    // handle input values & events
    const minYearInput = document.getElementById("min-year")
    const maxYearInput = document.getElementById("max-year")

    function updateMinYear() {
      style.variables.minYear = parseInt(minYearInput.value)
      updateStatusText()
    }
    function updateMaxYear() {
      style.variables.maxYear = parseInt(maxYearInput.value)
      updateStatusText()
    }
    function updateStatusText() {
      const div = document.getElementById("status")
      div.querySelector("span.min-year").textContent = minYearInput.value
      div.querySelector("span.max-year").textContent = maxYearInput.value
    }

    minYearInput.addEventListener("input", updateMinYear)
    minYearInput.addEventListener("change", updateMinYear)
    maxYearInput.addEventListener("input", updateMaxYear)
    maxYearInput.addEventListener("change", updateMaxYear)
    updateStatusText()

    // load data
    const client = new XMLHttpRequest()
    client.open("GET", "data/csv/meteorite_landings.csv")
    client.onload = function () {
      const csv = client.responseText
      const features = []

      let prevIndex = csv.indexOf("\n") + 1 // scan past the header line

      let curIndex
      while ((curIndex = csv.indexOf("\n", prevIndex)) != -1) {
        const line = csv.substr(prevIndex, curIndex - prevIndex).split(",")
        prevIndex = curIndex + 1

        const coords = fromLonLat([parseFloat(line[4]), parseFloat(line[3])])
        if (isNaN(coords[0]) || isNaN(coords[1])) {
          // guard against bad data
          continue
        }

        features.push(
          new Feature({
            mass: parseFloat(line[1]) || 0,
            year: parseInt(line[2]) || 0,
            geometry: new Point(coords),
          })
        )
      }

      vectorSource.addFeatures(features)
    }
    client.send()

    const map = new Map({
      layers: [
        new TileLayer({
          source: new Stamen({
            layer: "toner",
          }),
        }),
        new WebGLPointsLayer({
          style: style,
          source: vectorSource,
          disableHitDetection: true,
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 2,
      }),
    })

    // animate the map
    function animate() {
      map.render()
      window.requestAnimationFrame(animate)
    }
    animate()
  },
}
</script>
```

:::

## 4.飞行动画

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { LineString },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { Stamen, Vector: VectorSource },
      style: { Stroke, Style },
      render: { getVectorContext },
      extent: { getWidth },
    } = ol
    const tileLayer = new TileLayer({
      source: new Stamen({
        layer: "toner",
      }),
    })

    const map = new Map({
      layers: [tileLayer],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 2,
      }),
    })

    const style = new Style({
      stroke: new Stroke({
        color: "#EAE911",
        width: 2,
      }),
    })

    const flightsSource = new VectorSource({
      attributions:
        "Flight data by " +
        '<a href="https://openflights.org/data.html">OpenFlights</a>,',
      loader: function () {
        const url = "data/openflights/flights.json"
        fetch(url)
          .then(function (response) {
            return response.json()
          })
          .then(function (json) {
            const flightsData = json.flights
            for (let i = 0; i < flightsData.length; i++) {
              const flight = flightsData[i]
              const from = flight[0]
              const to = flight[1]

              // create an arc circle between the two locations
              const arcGenerator = new arc.GreatCircle(
                { x: from[1], y: from[0] },
                { x: to[1], y: to[0] }
              )

              const arcLine = arcGenerator.Arc(100, { offset: 10 })
              // paths which cross the -180°/+180° meridian are split
              // into two sections which will be animated sequentially
              const features = []
              arcLine.geometries.forEach(function (geometry) {
                const line = new LineString(geometry.coords)
                line.transform("EPSG:4326", "EPSG:3857")

                features.push(
                  new Feature({
                    geometry: line,
                    finished: false,
                  })
                )
              })
              // add the features with a delay so that the animation
              // for all features does not start at the same time
              addLater(features, i * 50)
            }
            tileLayer.on("postrender", animateFlights)
          })
      },
    })

    const flightsLayer = new VectorLayer({
      source: flightsSource,
      style: function (feature) {
        // if the animation is still active for a feature, do not
        // render the feature with the layer style
        if (feature.get("finished")) {
          return style
        } else {
          return null
        }
      },
    })

    map.addLayer(flightsLayer)

    const pointsPerMs = 0.02
    function animateFlights(event) {
      const vectorContext = getVectorContext(event)
      const frameState = event.frameState
      vectorContext.setStyle(style)

      const features = flightsSource.getFeatures()
      for (let i = 0; i < features.length; i++) {
        const feature = features[i]
        if (!feature.get("finished")) {
          // only draw the lines for which the animation has not finished yet
          const coords = feature.getGeometry().getCoordinates()
          const elapsedTime = frameState.time - feature.get("start")
          if (elapsedTime >= 0) {
            const elapsedPoints = elapsedTime * pointsPerMs

            if (elapsedPoints >= coords.length) {
              feature.set("finished", true)
            }

            const maxIndex = Math.min(elapsedPoints, coords.length)
            const currentLine = new LineString(coords.slice(0, maxIndex))

            // animation is needed in the current and nearest adjacent wrapped world
            const worldWidth = getWidth(
              map.getView().getProjection().getExtent()
            )
            const offset = Math.floor(map.getView().getCenter()[0] / worldWidth)

            // directly draw the lines with the vector context
            currentLine.translate(offset * worldWidth, 0)
            vectorContext.drawGeometry(currentLine)
            currentLine.translate(worldWidth, 0)
            vectorContext.drawGeometry(currentLine)
          }
        }
      }
      // tell OpenLayers to continue the animation
      map.render()
    }

    function addLater(features, timeout) {
      window.setTimeout(function () {
        let start = Date.now()
        features.forEach(function (feature) {
          feature.set("start", start)
          flightsSource.addFeature(feature)
          const duration =
            (feature.getGeometry().getCoordinates().length - 1) / pointsPerMs
          start += duration
        })
      }, timeout)
    }
  },
}
</script>
```

:::

## 5.分形渲染

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <label for="depth">
    depth:&nbsp;
    <input id="depth" type="range" min="0" max="9" step="1" value="5" />
    &nbsp;(<span id="count">#</span> points)
  </label>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { LineString },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: Style,
      proj: { fromLonLat },
    } = ol
    const radius = 10e6
    const cos30 = Math.cos(Math.PI / 6)
    const sin30 = Math.sin(Math.PI / 6)
    const rise = radius * sin30
    const run = radius * cos30

    const triangle = new LineString([
      [0, radius],
      [run, -rise],
      [-run, -rise],
      [0, radius],
    ])

    const feature = new Feature(triangle)

    const layer = new VectorLayer({
      source: new VectorSource({
        features: [feature],
      }),
    })

    const map = new Map({
      layers: [layer],
      target: this.$refs.map,
      view: new View({
        center: [0, 0],
        zoom: 1,
      }),
    })

    function makeFractal(depth) {
      const geometry = triangle.clone()
      const graph = coordsToGraph(geometry.getCoordinates())
      for (let i = 0; i < depth; ++i) {
        let node = graph
        while (node.next) {
          const next = node.next
          injectNodes(node)
          node = next
        }
      }
      const coordinates = graphToCoords(graph)
      document.getElementById("count").innerHTML = coordinates.length
      geometry.setCoordinates(coordinates)
      feature.setGeometry(geometry)
    }

    function injectNodes(startNode) {
      const endNode = startNode.next

      const start = startNode.point
      const end = startNode.next.point
      const dx = end[0] - start[0]
      const dy = end[1] - start[1]

      // first point at 1/3 along the segment
      const firstNode = {
        point: [start[0] + dx / 3, start[1] + dy / 3],
      }

      // second point at peak of _/\_
      const r = Math.sqrt(dx * dx + dy * dy) / (2 * cos30)
      const a = Math.atan2(dy, dx) + Math.PI / 6
      const secondNode = {
        point: [start[0] + r * Math.cos(a), start[1] + r * Math.sin(a)],
      }

      // third point at 2/3 along the segment
      const thirdNode = {
        point: [end[0] - dx / 3, end[1] - dy / 3],
      }

      startNode.next = firstNode
      firstNode.next = secondNode
      secondNode.next = thirdNode
      thirdNode.next = endNode
    }

    function coordsToGraph(coordinates) {
      const graph = {
        point: coordinates[0],
      }
      const length = coordinates.length
      for (let level = 0, node = graph; level < length - 1; ++level) {
        node.next = {
          point: coordinates[level + 1],
        }
        node = node.next
      }
      return graph
    }

    function graphToCoords(graph) {
      const coordinates = [graph.point]
      for (let node = graph, i = 1; node.next; node = node.next, ++i) {
        coordinates[i] = node.next.point
      }
      return coordinates
    }

    const depthInput = document.getElementById("depth")

    function update() {
      makeFractal(Number(depthInput.value))
    }

    let updateTimer

    /**
     * Regenerate fractal on depth change.  Change events are debounced so updates
     * only occur every 200ms.
     */
    depthInput.onchange = function () {
      window.clearTimeout(updateTimer)
      updateTimer = window.setTimeout(update, 200)
    }

    update()
  },
}
</script>
```

:::
