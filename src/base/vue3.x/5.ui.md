---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 七.数据格式

## 2.GeoJSON

:::demo

```vue {118}
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">选择数据源 &nbsp;</label>
    <select @change="getDataSource" v-model="selected">
      <option value="line-samples.geojson">线类型</option>
      <option value="all.geojson">所有类型</option>
      <option value="photovoltaic.json">绘制</option>
      <option value="point-samples.geojson">点类型</option>
      <option value="polygon-samples.geojson">绘制</option>
      <option value="roads-seoul.geojson">修改</option>
      <option value="switzerland.geojson">修改</option>
      <option value="vienna-streets.geojson">绘制</option>
      <option value="world-cities.geojson">修改</option>
    </select>
  </form>
</template>

<script>
export default {
  data() {
    return {
      selected: $localStorage().geojson || "line-samples.geojson",
    }
  },
  async mounted() {
    let {
      Feature,
      geom: { Circle },
      format: { GeoJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
    } = ol
    // 获取轨迹点
    let res = await axios.get(
      this.$withBase(
        `/data/geojson/${$localStorage().geojson || "line-samples.geojson"}`
      )
    )
    const geojsonObject = res.data
    const image = new CircleStyle({
      radius: 5,
      fill: null,
      stroke: new Stroke({ color: "red", width: 1 }),
    })

    const styles = {
      Point: new Style({
        image: image,
      }),
      LineString: new Style({
        stroke: new Stroke({
          color: "green",
          width: 1,
        }),
      }),
      MultiLineString: new Style({
        stroke: new Stroke({
          color: "green",
          width: 1,
        }),
      }),
      MultiPoint: new Style({
        image: image,
      }),
      MultiPolygon: new Style({
        stroke: new Stroke({
          color: "yellow",
          width: 1,
        }),
        fill: new Fill({
          color: "rgba(255, 255, 0, 0.1)",
        }),
      }),
      Polygon: new Style({
        stroke: new Stroke({
          color: "blue",
          lineDash: [4],
          width: 3,
        }),
        fill: new Fill({
          color: "rgba(0, 0, 255, 0.1)",
        }),
      }),
      GeometryCollection: new Style({
        stroke: new Stroke({
          color: "magenta",
          width: 2,
        }),
        fill: new Fill({
          color: "magenta",
        }),
        image: new CircleStyle({
          radius: 10,
          fill: null,
          stroke: new Stroke({
            color: "magenta",
          }),
        }),
      }),
      Circle: new Style({
        stroke: new Stroke({
          color: "red",
          width: 2,
        }),
        fill: new Fill({
          color: "rgba(255,0,0,0.2)",
        }),
      }),
    }

    const styleFunction = function (feature) {
      return styles[feature.getGeometry().getType()]
    }

    const vectorSource = new VectorSource({
      features: new GeoJSON().readFeatures(geojsonObject), // geojson --> feature
    })

    vectorSource.addFeature(new Feature(new Circle([5e6, 7e6], 1e6)))

    const vectorLayer = new VectorLayer({
      source: vectorSource,
      style: styleFunction,
    })

    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
        vectorLayer,
      ],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })
  },
  methods: {
    getDataSource(e) {
      this.selected = $localStorage().geojson = e.target.value
    },
  },
}
</script>
```

:::

## 3.EsriJSON

:::demo

```vue {62}
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">绘制或修改 &nbsp;</label>
    <select ref="type">
      <option value="DRAW">绘制</option>
      <option value="MODIFY">修改</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      format: { EsriJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
      tilegrid: { createXYZ },
      proj: { fromLonLat },
      loadingstrategy: { tile: tileStrategy },
      interaction: { Draw, Modify, Select, defaults: defaultInteractions },
    } = ol
    const serviceUrl =
      "https://sampleserver6.arcgisonline.com/arcgis/rest/services/Wildfire/FeatureServer/"
    const layer = "2"
    const esrijsonFormat = new EsriJSON()
    const vectorSource = new VectorSource({
      loader: function (extent, resolution, projection) {
        const url =
          serviceUrl +
          layer +
          "/query/?f=json&" +
          "returnGeometry=true&spatialRel=esriSpatialRelIntersects&geometry=" +
          encodeURIComponent(
            '{"xmin":' +
              extent[0] +
              ',"ymin":' +
              extent[1] +
              ',"xmax":' +
              extent[2] +
              ',"ymax":' +
              extent[3] +
              ',"spatialReference":{"wkid":102100}}'
          ) +
          "&geometryType=esriGeometryEnvelope&inSR=102100&outFields=*" +
          "&outSR=102100"
        $.ajax({
          url: url,
          dataType: "jsonp",
          success: function (response) {
            if (response.error) {
              alert(
                response.error.message +
                  "\n" +
                  response.error.details.join("\n")
              )
            } else {
              const projection = { featureProjection: projection }
              const features = esrijsonFormat.readFeatures(response, projection) // esrijson --> feature
              if (features.length > 0) {
                vectorSource.addFeatures(features)
              }
            }
          },
        })
      },
      strategy: tileStrategy(
        createXYZ({
          tileSize: 512,
        })
      ),
    })
    const vector = new VectorLayer({
      source: vectorSource,
    })
    const raster = new TileLayer({
      source: new XYZ({
        attributions:
          'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/' +
          'rest/services/World_Topo_Map/MapServer">ArcGIS</a>',
        url:
          "https://server.arcgisonline.com/ArcGIS/rest/services/" +
          "World_Topo_Map/MapServer/tile/{z}/{y}/{x}",
      }),
    })
    const draw = new Draw({
      source: vectorSource,
      type: "Polygon",
    })
    const select = new Select()
    select.setActive(false)
    const selected = select.getFeatures()
    const modify = new Modify({
      features: selected,
    })
    modify.setActive(false)
    const map = new Map({
      interactions: defaultInteractions().extend([draw, select, modify]),
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-110.875, 37.345]),
        zoom: 5,
      }),
    })
    const typeSelect = this.$refs.type
    typeSelect.onchange = function () {
      draw.setActive(typeSelect.value === "DRAW")
      select.setActive(typeSelect.value === "MODIFY")
      modify.setActive(typeSelect.value === "MODIFY")
    }
    const dirty = {}
    selected.on("add", function (evt) {
      const feature = evt.element
      feature.on("change", function (evt) {
        dirty[evt.target.get("objectid")] = true
      })
    })
    selected.on("remove", function (evt) {
      const feature = evt.element
      const fid = feature.get("objectid")
      if (dirty[fid] === true) {
        const payload =
          "[" +
          esrijsonFormat.writeFeature(feature, {
            featureProjection: map.getView().getProjection(),
          }) +
          "]"
        const url = serviceUrl + layer + "/updateFeatures"
        $.post(url, { f: "json", features: payload }).done(function (data) {
          const result = typeof data === "string" ? JSON.parse(data) : data
          if (result.updateResults && result.updateResults.length > 0) {
            if (result.updateResults[0].success !== true) {
              const error = result.updateResults[0].error
              alert(error.description + " (" + error.code + ")")
            } else {
              delete dirty[fid]
            }
          }
        })
      }
    })
    draw.on("drawend", function (evt) {
      const feature = evt.feature
      const payload =
        "[" +
        esrijsonFormat.writeFeature(feature, {
          featureProjection: map.getView().getProjection(),
        }) +
        "]"
      const url = serviceUrl + layer + "/addFeatures"
      $.post(url, { f: "json", features: payload }).done(function (data) {
        const result = typeof data === "string" ? JSON.parse(data) : data
        if (result.addResults && result.addResults.length > 0) {
          if (result.addResults[0].success === true) {
            feature.set("objectid", result.addResults[0]["objectId"])
          } else {
            const error = result.addResults[0].error
            alert(error.description + " (" + error.code + ")")
          }
        }
      })
    })
  },
}
</script>
```

:::

## 1.WMTSCapabilities

WMTS 源有一个 tilePixelRatio 选项。支持 HiDPI 的 WMTS 可以提供具有 512x512 像素图块的图块，但在 256x256 像素图块网格中使用它们。在这种情况下 tilePixelRatio 需要设置为 2
:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  async mounted() {
    let {
      format: { WMTSCapabilities },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { WMTS },
      has: { DEVICE_PIXEL_RATIO },
    } = ol
    const capabilitiesUrl = "https://basemap.at/wmts/1.0.0/WMTSCapabilities.xml"
    const hiDPI = DEVICE_PIXEL_RATIO > 1
    const layer = hiDPI ? "bmaphidpi" : "geolandbasemap"
    const tilePixelRatio = hiDPI ? 2 : 1

    const map = new Map({
      target: this.$refs.map,
      view: new View({
        center: [1823849, 6143760],
        zoom: 11,
      }),
    })
    let res = await axios.get(capabilitiesUrl)
    const result = new WMTSCapabilities().read(res.data)
    const options = WMTS.optionsFromCapabilities(result, {
      layer: layer,
      matrixSet: "google3857",
      style: "normal",
    })
    options.tilePixelRatio = tilePixelRatio
    options.attributions =
      'Grundkarte: <a target="_blank" href="https://basemap.at/">basemap.at</a>'
    map.addLayer(
      new TileLayer({
        source: new WMTS(options),
      })
    )
  },
}
</script>
```

:::

## 1.IIIFInfo

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div class="controls">
    <div id="iiif-notification">&nbsp;</div>
    <label for="imageInfoUrl">Enter <code>info.json</code> URL:</label>
    <input
      type="text"
      id="imageInfoUrl"
      value="https://iiif.ub.uni-leipzig.de/iiif/j2k/0000/0107/0000010732/00000072.jpx/info.json"
    />
    <button id="display">Display image</button>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { IIIFInfo },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { IIIF },
    } = ol

    const layer = new TileLayer(),
      map = new Map({
        layers: [layer],
        target: this.$refs.map,
      }),
      notifyDiv = document.getElementById("iiif-notification"),
      urlInput = document.getElementById("imageInfoUrl"),
      displayButton = document.getElementById("display")

    function refreshMap(imageInfoUrl) {
      fetch(imageInfoUrl)
        .then(function (response) {
          response
            .json()
            .then(function (imageInfo) {
              const options = new IIIFInfo(imageInfo).getTileSourceOptions()
              if (options === undefined || options.version === undefined) {
                notifyDiv.textContent =
                  "Data seems to be no valid IIIF image information."
                return
              }
              options.zDirection = -1
              const iiifTileSource = new IIIF(options)
              layer.setSource(iiifTileSource)
              map.setView(
                new View({
                  resolutions: iiifTileSource.getTileGrid().getResolutions(),
                  extent: iiifTileSource.getTileGrid().getExtent(),
                  constrainOnlyCenter: true,
                })
              )
              map.getView().fit(iiifTileSource.getTileGrid().getExtent())
              notifyDiv.textContent = ""
            })
            .catch(function (body) {
              notifyDiv.textContent = "Could not read image info json. " + body
            })
        })
        .catch(function () {
          notifyDiv.textContent = "Could not read data from URL."
        })
    }

    displayButton.addEventListener("click", function () {
      refreshMap(urlInput.value)
    })

    refreshMap(urlInput.value)
  },
}
</script>
```

:::
