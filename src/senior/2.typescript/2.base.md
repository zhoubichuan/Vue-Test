---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 二.案例2

## 1.图标比例尺

:::demo

```vue
<template>
  <div ref="map" class="map"><div id="popup"></div></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      Overlay,
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { TileJSON, Vector: VectorSource },
      style: { Icon, Style, Text },
      proj: { fromLonLat },
      render: { getVectorContext },
    } = ol
    const rasterLayer = new TileLayer({
      source: new TileJSON({
        url: "https://a.tiles.mapbox.com/v3/aj.1x1-degrees.json?secure=1",
        crossOrigin: "",
      }),
    })

    const iconFeature = new Feature({
      geometry: new Point(fromLonLat([0, -10])),
      name: "Fish.1",
    })

    const feature1 = new Feature({
      geometry: new Point(fromLonLat([0, -10])),
      name: "Fish.1 Island",
    })

    const feature2 = new Feature({
      geometry: new Point(fromLonLat([-30, 10])),
      name: "Fish.2 Island",
    })

    const iconStyle = new Style({
      image: new Icon({
        anchor: [0.5, 0.9],
        src: "data/fish.png",
        crossOrigin: "",
        scale: [0, 0],
        rotation: Math.PI / 4,
      }),
      text: new Text({
        text: "FISH\nTEXT",
        scale: [0, 0],
        rotation: Math.PI / 4,
        textAlign: "center",
        textBaseline: "top",
      }),
    })

    let i = 0
    let j = 45

    iconFeature.setStyle(function () {
      const x = Math.sin((i * Math.PI) / 180) * 3
      const y = Math.sin((j * Math.PI) / 180) * 4
      iconStyle.getImage().setScale([x, y])
      iconStyle.getText().setScale([x, y])
      return iconStyle
    })

    rasterLayer.on("postrender", function (event) {
      const vectorContext = getVectorContext(event)
      const x = Math.cos((i * Math.PI) / 180) * 3
      const y = Math.cos((j * Math.PI) / 180) * 4
      iconStyle.getImage().setScale([x, y])
      iconStyle.getText().setScale([x, y])
      vectorContext.drawFeature(feature2, iconStyle)
    })

    const vectorSource = new VectorSource({
      features: [iconFeature, feature1, feature2],
    })

    const vectorLayer = new VectorLayer({
      source: vectorSource,
    })

    const map = new Map({
      layers: [rasterLayer, vectorLayer],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-15, 0]),
        zoom: 3,
      }),
    })

    setInterval(function () {
      i = (i + 4) % 360
      j = (j + 5) % 360
      vectorSource.changed()
    }, 1000)

    const element = document.getElementById("popup")

    const popup = new Overlay({
      element: element,
      positioning: "bottom-center",
      stopEvent: false,
    })
    map.addOverlay(popup)

    // display popup on click
    map.on("click", function (evt) {
      const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
        return feature
      })
      $(element).popover("dispose")
      if (feature) {
        popup.setPosition(evt.coordinate)
        $(element).popover({
          placement: "top",
          html: true,
          animation: false,
          content: feature.get("name"),
        })
        $(element).popover("show")
      }
    })

    // change mouse cursor when over marker
    map.on("pointermove", function (e) {
      const pixel = map.getEventPixel(e.originalEvent)
      const hit = map.hasFeatureAtPixel(pixel)
      map.getTarget().style.cursor = hit ? "pointer" : ""
    })
    // Close the popup when the map is moved
    map.on("movestart", function () {
      $(element).popover("dispose")
    })
  },
}
</script>
```

:::

## 2.图标精灵与 WebGL

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>Current sighting: <span id="info"></span></div>
  <div>
    <label for="shape-filter">Filter by UFO shape:</label>
    <select id="shape-filter"></select>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, WebGLPoints: WebGLPointsLayer },
      source: { XYZ, Vector },
      proj: { fromLonLat },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const map = new Map({
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
              key,
            tileSize: 512,
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [0, 4000000],
        zoom: 2,
      }),
    })

    const vectorSource = new Vector({
      features: [],
      attributions: "National UFO Reporting Center",
    })

    const oldColor = [255, 160, 110]
    const newColor = [180, 255, 200]
    const size = 16

    const style = {
      variables: {
        filterShape: "all",
      },
      filter: [
        "case",
        ["!=", ["var", "filterShape"], "all"],
        ["==", ["get", "shape"], ["var", "filterShape"]],
        true,
      ],
      symbol: {
        symbolType: "image",
        src: "data/ufo_shapes.png",
        size: size,
        color: [
          "interpolate",
          ["linear"],
          ["get", "year"],
          1950,
          oldColor,
          2013,
          newColor,
        ],
        rotateWithView: false,
        offset: [0, 0],
        textureCoord: [
          "match",
          ["get", "shape"],
          "light",
          [0, 0, 0.25, 0.5],
          "sphere",
          [0.25, 0, 0.5, 0.5],
          "circle",
          [0.25, 0, 0.5, 0.5],
          "disc",
          [0.5, 0, 0.75, 0.5],
          "oval",
          [0.5, 0, 0.75, 0.5],
          "triangle",
          [0.75, 0, 1, 0.5],
          "fireball",
          [0, 0.5, 0.25, 1],
          [0.75, 0.5, 1, 1],
        ],
      },
    }

    // key is shape name, value is sightings count
    const shapeTypes = {
      all: 0,
    }
    const shapeSelect = document.getElementById("shape-filter")
    shapeSelect.addEventListener("input", function () {
      style.variables.filterShape =
        shapeSelect.options[shapeSelect.selectedIndex].value
      map.render()
    })
    function fillShapeSelect() {
      Object.keys(shapeTypes)
        .sort(function (a, b) {
          return shapeTypes[b] - shapeTypes[a]
        })
        .forEach(function (shape) {
          const option = document.createElement("option")
          option.text = `${shape} (${shapeTypes[shape]} sightings)`
          option.value = shape
          shapeSelect.appendChild(option)
        })
    }

    const client = new XMLHttpRequest()
    client.open("GET", "data/csv/ufo_sighting_data.csv")
    client.onload = function () {
      const csv = client.responseText
      const features = []

      let prevIndex = csv.indexOf("\n") + 1 // scan past the header line

      let curIndex
      while ((curIndex = csv.indexOf("\n", prevIndex)) != -1) {
        const line = csv.substr(prevIndex, curIndex - prevIndex).split(",")
        prevIndex = curIndex + 1

        const coords = fromLonLat([parseFloat(line[5]), parseFloat(line[4])])

        // only keep valid points
        if (isNaN(coords[0]) || isNaN(coords[1])) {
          continue
        }

        const shape = line[2]
        shapeTypes[shape] = (shapeTypes[shape] ? shapeTypes[shape] : 0) + 1
        shapeTypes["all"]++

        features.push(
          new Feature({
            datetime: line[0],
            year: parseInt(/[0-9]{4}/.exec(line[0])[0]), // extract the year as int
            shape: shape,
            duration: line[3],
            geometry: new Point(coords),
          })
        )
      }
      vectorSource.addFeatures(features)
      fillShapeSelect()
    }
    client.send()

    map.addLayer(
      new WebGLPointsLayer({
        source: vectorSource,
        style: style,
      })
    )

    const info = document.getElementById("info")
    map.on("pointermove", function (evt) {
      if (map.getView().getInteracting() || map.getView().getAnimating()) {
        return
      }
      const pixel = evt.pixel
      info.innerText = ""
      map.forEachFeatureAtPixel(pixel, function (feature) {
        const datetime = feature.get("datetime")
        const duration = feature.get("duration")
        const shape = feature.get("shape")
        info.innerText =
          "On " +
          datetime +
          ", lasted " +
          duration +
          ' seconds and had a "' +
          shape +
          '" shape.'
      })
    })
  },
}
</script>
```

:::

## 3.图标符号

:::demo

```vue
<template>
  <div ref="map" class="map"><div id="popup"></div></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      Overlay,
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { TileJSON, Vector: VectorSource },
      style: { Icon, Style },
    } = ol

    const iconFeature = new Feature({
      geometry: new Point([0, 0]),
      name: "Null Island",
      population: 4000,
      rainfall: 500,
    })

    const iconStyle = new Style({
      image: new Icon({
        anchor: [0.5, 46],
        anchorXUnits: "fraction",
        anchorYUnits: "pixels",
        src: "data/icon.png",
      }),
    })

    iconFeature.setStyle(iconStyle)

    const vectorSource = new VectorSource({
      features: [iconFeature],
    })

    const vectorLayer = new VectorLayer({
      source: vectorSource,
    })

    const rasterLayer = new TileLayer({
      source: new TileJSON({
        url: "https://a.tiles.mapbox.com/v3/aj.1x1-degrees.json?secure=1",
        crossOrigin: "",
      }),
    })

    const map = new Map({
      layers: [rasterLayer, vectorLayer],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 3,
      }),
    })

    const element = document.getElementById("popup")

    const popup = new Overlay({
      element: element,
      positioning: "bottom-center",
      stopEvent: false,
    })
    map.addOverlay(popup)

    // display popup on click
    map.on("click", function (evt) {
      const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
        return feature
      })
      if (feature) {
        popup.setPosition(evt.coordinate)
        $(element).popover({
          placement: "top",
          html: true,
          content: feature.get("name"),
        })
        $(element).popover("show")
      } else {
        $(element).popover("dispose")
      }
    })

    // change mouse cursor when over marker
    map.on("pointermove", function (e) {
      const pixel = map.getEventPixel(e.originalEvent)
      const hit = map.hasFeatureAtPixel(pixel)
      map.getTarget().style.cursor = hit ? "pointer" : ""
    })
    // Close the popup when the map is moved
    map.on("movestart", function () {
      $(element).popover("dispose")
    })
  },
}
</script>
```

:::

## 4.IGC 数据

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      tilegrid: { WMTS: WMTSTileGrid },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { WMTS },
      proj: { fromLonLat, get: getProjection },
      extent: { getWidth },
    } = ol

    const map = new Map({
      target: this.$refs.map,
      view: new View({
        zoom: 5,
        center: fromLonLat([5, 45]),
      }),
    })

    const resolutions = []
    const matrixIds = []
    const proj3857 = getProjection("EPSG:3857")
    const maxResolution = getWidth(proj3857.getExtent()) / 256

    for (let i = 0; i < 20; i++) {
      matrixIds[i] = i.toString()
      resolutions[i] = maxResolution / Math.pow(2, i)
    }

    const tileGrid = new WMTSTileGrid({
      origin: [-20037508, 20037508],
      resolutions: resolutions,
      matrixIds: matrixIds,
    })

    // For more information about the IGN API key see
    // https://geoservices.ign.fr/blog/2021/01/29/Maj_Cles_Geoservices.html

    const ign_source = new WMTS({
      url: "https://wxs.ign.fr/choisirgeoportail/geoportail/wmts",
      layer: "GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2",
      matrixSet: "PM",
      format: "image/png",
      projection: "EPSG:3857",
      tileGrid: tileGrid,
      style: "normal",
      attributions:
        '<a href="https://www.ign.fr/" target="_blank">' +
        '<img src="https://wxs.ign.fr/static/logos/IGN/IGN.gif" title="Institut national de l\'' +
        'information géographique et forestière" alt="IGN"></a>',
    })

    const ign = new TileLayer({
      source: ign_source,
    })

    map.addLayer(ign)
  },
}
</script>
```

:::

## 5.IGN WMTS

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      tilegrid: { WMTS: WMTSTileGrid },
      layer: { Tile: TileLayer },
      source: { WMTS },
      proj: { fromLonLat, get: getProjection },
      extent: { getWidth },
    } = ol
    const map = new Map({
      target: this.$refs.map,
      view: new View({
        zoom: 5,
        center: fromLonLat([5, 45]),
      }),
    })

    const resolutions = []
    const matrixIds = []
    const proj3857 = getProjection("EPSG:3857")
    const maxResolution = getWidth(proj3857.getExtent()) / 256

    for (let i = 0; i < 20; i++) {
      matrixIds[i] = i.toString()
      resolutions[i] = maxResolution / Math.pow(2, i)
    }

    const tileGrid = new WMTSTileGrid({
      origin: [-20037508, 20037508],
      resolutions: resolutions,
      matrixIds: matrixIds,
    })

    // For more information about the IGN API key see
    // https://geoservices.ign.fr/blog/2021/01/29/Maj_Cles_Geoservices.html

    const ign_source = new WMTS({
      url: "https://wxs.ign.fr/choisirgeoportail/geoportail/wmts",
      layer: "GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2",
      matrixSet: "PM",
      format: "image/png",
      projection: "EPSG:3857",
      tileGrid: tileGrid,
      style: "normal",
      attributions:
        '<a href="https://www.ign.fr/" target="_blank">' +
        '<img src="https://wxs.ign.fr/static/logos/IGN/IGN.gif" title="Institut national de l\'' +
        'information géographique et forestière" alt="IGN"></a>',
    })

    const ign = new TileLayer({
      source: ign_source,
    })

    map.addLayer(ign)
  },
}
</script>
```

:::
