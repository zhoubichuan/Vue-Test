---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 六.案例 10

## 1.互动程度

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { Extent: ExtentInteraction },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      events: { condition: shiftKeyOnly },
    } = ol
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    const extent = new ExtentInteraction({ condition: shiftKeyOnly })
    map.addInteraction(extent)
  },
}
</script>
```

:::

## 2.外部地图

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <input id="external-map-button" type="button" value="Open external map"></input>
    <span id="blocker-notice" hidden>Could not open map in external window. If you are using a popup or ad blocker you may need to disable it for this example.</span>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      proj: { fromLonLat },
      control: { Control, FullScreen, defaults: defaultControls },
    } = ol
    class UnusableMask extends Control {
      constructor() {
        super({
          element: document.createElement("div"),
        })
        this.element.setAttribute("hidden", "hidden")
        this.element.className = "ol-mask"
        this.element.innerHTML = "<div>Map not usable</div>"
      }
    }

    const map = new Map({
      target: this.$refs.map,
      controls: defaultControls().extend([
        new FullScreen(),
        new UnusableMask(),
      ]),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      view: new View({
        center: fromLonLat([37.41, 8.82]),
        zoom: 4,
      }),
    })

    let mapWindow
    function closeMapWindow() {
      if (mapWindow) {
        mapWindow.close()
        mapWindow = undefined
      }
    }
    // Close external window in case the main page is closed or reloaded
    window.addEventListener("pagehide", closeMapWindow)

    const button = document.getElementById("external-map-button")

    function resetMapTarget() {
      localMapTarget.style.height = ""
      map.setTarget(localMapTarget)
      button.disabled = false
    }

    function updateOverlay() {
      if (!mapWindow) {
        return
      }
      const externalMapTarget = mapWindow.document.getElementById("map")
      if (!externalMapTarget) {
        return
      }
      if (document.visibilityState === "visible") {
        // Show controls and enable keyboard input
        externalMapTarget.classList.remove("unusable")
        externalMapTarget.setAttribute("tabindex", "0")
        externalMapTarget.focus()
      } else {
        // Hide all controls and disable keyboard input
        externalMapTarget.removeAttribute("tabindex")
        externalMapTarget.classList.add("unusable")
      }
    }
    window.addEventListener("visibilitychange", updateOverlay)

    button.addEventListener("click", function () {
      const blockerNotice = document.getElementById("blocker-notice")
      blockerNotice.setAttribute("hidden", "hidden")
      button.disabled = true

      // Reset button and map target in case window did not load or open
      let timeoutKey = setTimeout(function () {
        closeMapWindow()
        resetMapTarget()
        blockerNotice.removeAttribute("hidden")
        timeoutKey = undefined
      }, 3000)

      mapWindow = window.open(
        "resources/external-map-map.html",
        "MapWindow",
        "toolbar=0,location=0,menubar=0,width=800,height=600"
      )
      mapWindow.addEventListener("DOMContentLoaded", function () {
        const externalMapTarget = mapWindow.document.getElementById("map")
        localMapTarget.style.height = "0px"
        map.setTarget(externalMapTarget)

        if (timeoutKey) {
          timeoutKey = clearTimeout(timeoutKey)
        }
        mapWindow.addEventListener("pagehide", function () {
          resetMapTarget()
          // Close window in case user does a page reload
          closeMapWindow()
        })

        updateOverlay()
      })
    })
  },
}
</script>
```

:::

## 3.使用 WebGL 过滤功能

这个例子展示了如何使用 ol/layer/WebGLPoints 文字样式来动态过滤大量的点几何图形。上面的地图基于 NASA 的数据集，其中包含 45k 记录的陨石着陆点。每颗陨石在地图上都用一个圆圈标记（圆圈越大，物体越重）。增加了一个脉冲效应，它被影响的年份稍微抵消了。

调整滑块会导致日期范围之外的对象从地图中过滤掉。这是通过改变 style 提供给 WebGL 层的对象中的变量来完成的。另请注意，最后一段代码是确保地图在每一帧都刷新自身所必需的。

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form>
    <div id="status">
      显示 <span class="min-year"></span> 到
      <span class="max-year"></span>之间的范围
    </div>

    <label for="min-year">最低年份:</label>
    <input
      id="min-year"
      type="range"
      min="1850"
      max="2015"
      step="1"
      value="1850"
    />
    <label for="max-year">最高年份:</label>
    <input
      id="max-year"
      type="range"
      min="1850"
      max="2015"
      step="1"
      value="2015"
    />
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, WebGLPoints: WebGLPointsLayer },
      source: { Stamen, Vector: VectorSource },
      proj: { fromLonLat },
    } = ol
    const vectorSource = new VectorSource({
      attributions: "NASA",
    })

    const oldColor = "rgba(242,56,22,0.61)"
    const newColor = "#ffe52c"
    const period = 12 // animation period in seconds
    const animRatio = [
      "^",
      [
        "/",
        [
          "%",
          [
            "+",
            ["time"],
            ["interpolate", ["linear"], ["get", "year"], 1850, 0, 2015, period],
          ],
          period,
        ],
        period,
      ],
      0.5,
    ]

    const style = {
      variables: {
        minYear: 1850,
        maxYear: 2015,
      },
      filter: [
        "between",
        ["get", "year"],
        ["var", "minYear"],
        ["var", "maxYear"],
      ],
      symbol: {
        symbolType: "circle",
        size: [
          "*",
          ["interpolate", ["linear"], ["get", "mass"], 0, 8, 200000, 26],
          ["-", 1.75, ["*", animRatio, 0.75]],
        ],
        color: ["interpolate", ["linear"], animRatio, 0, newColor, 1, oldColor],
        opacity: ["-", 1.0, ["*", animRatio, 0.75]],
      },
    }

    // handle input values & events
    const minYearInput = document.getElementById("min-year")
    const maxYearInput = document.getElementById("max-year")

    function updateMinYear() {
      style.variables.minYear = parseInt(minYearInput.value)
      updateStatusText()
    }
    function updateMaxYear() {
      style.variables.maxYear = parseInt(maxYearInput.value)
      updateStatusText()
    }
    function updateStatusText() {
      const div = document.getElementById("status")
      div.querySelector("span.min-year").textContent = minYearInput.value
      div.querySelector("span.max-year").textContent = maxYearInput.value
    }

    minYearInput.addEventListener("input", updateMinYear)
    minYearInput.addEventListener("change", updateMinYear)
    maxYearInput.addEventListener("input", updateMaxYear)
    maxYearInput.addEventListener("change", updateMaxYear)
    updateStatusText()

    // load data
    const client = new XMLHttpRequest()
    client.open("GET", this.$withBase("/data/csv/meteorite_landings.csv"))
    client.onload = function () {
      const csv = client.responseText
      const features = []

      let prevIndex = csv.indexOf("\n") + 1 // scan past the header line

      let curIndex
      while ((curIndex = csv.indexOf("\n", prevIndex)) != -1) {
        const line = csv.substr(prevIndex, curIndex - prevIndex).split(",")
        prevIndex = curIndex + 1

        const coords = fromLonLat([parseFloat(line[4]), parseFloat(line[3])])
        if (isNaN(coords[0]) || isNaN(coords[1])) {
          // guard against bad data
          continue
        }

        features.push(
          new Feature({
            mass: parseFloat(line[1]) || 0,
            year: parseInt(line[2]) || 0,
            geometry: new Point(coords),
          })
        )
      }

      vectorSource.addFeatures(features)
    }
    client.send()

    const map = new Map({
      layers: [
        new TileLayer({
          source: new Stamen({
            layer: "toner",
          }),
        }),
        new WebGLPointsLayer({
          style: style,
          source: vectorSource,
          disableHitDetection: true,
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    // animate the map
    function animate() {
      map.render()
      window.requestAnimationFrame(animate)
    }
    animate()
  },
}
</script>
```

:::

## 5.分形渲染

如何有效地渲染具有许多顶点的特征

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <label for="depth">
    depth:&nbsp;
    <input id="depth" type="range" min="0" max="9" step="1" value="5" />
    &nbsp;(<span id="count">#</span> points)
  </label>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { LineString },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: Style,
      proj: { fromLonLat },
    } = ol
    const radius = 10e6
    const cos30 = Math.cos(Math.PI / 6)
    const sin30 = Math.sin(Math.PI / 6)
    const rise = radius * sin30
    const run = radius * cos30

    const triangle = new LineString([
      [0, radius],
      [run, -rise],
      [-run, -rise],
      [0, radius],
    ])

    const feature = new Feature(triangle)

    const layer = new VectorLayer({
      source: new VectorSource({
        features: [feature],
      }),
    })

    const map = new Map({
      layers: [layer],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 1,
      }),
    })

    function makeFractal(depth) {
      const geometry = triangle.clone()
      const graph = coordsToGraph(geometry.getCoordinates())
      for (let i = 0; i < depth; ++i) {
        let node = graph
        while (node.next) {
          const next = node.next
          injectNodes(node)
          node = next
        }
      }
      const coordinates = graphToCoords(graph)
      document.getElementById("count").innerHTML = coordinates.length
      geometry.setCoordinates(coordinates)
      feature.setGeometry(geometry)
    }

    function injectNodes(startNode) {
      const endNode = startNode.next

      const start = startNode.point
      const end = startNode.next.point
      const dx = end[0] - start[0]
      const dy = end[1] - start[1]

      // first point at 1/3 along the segment
      const firstNode = {
        point: [start[0] + dx / 3, start[1] + dy / 3],
      }

      // second point at peak of _/\_
      const r = Math.sqrt(dx * dx + dy * dy) / (2 * cos30)
      const a = Math.atan2(dy, dx) + Math.PI / 6
      const secondNode = {
        point: [start[0] + r * Math.cos(a), start[1] + r * Math.sin(a)],
      }

      // third point at 2/3 along the segment
      const thirdNode = {
        point: [end[0] - dx / 3, end[1] - dy / 3],
      }

      startNode.next = firstNode
      firstNode.next = secondNode
      secondNode.next = thirdNode
      thirdNode.next = endNode
    }

    function coordsToGraph(coordinates) {
      const graph = {
        point: coordinates[0],
      }
      const length = coordinates.length
      for (let level = 0, node = graph; level < length - 1; ++level) {
        node.next = {
          point: coordinates[level + 1],
        }
        node = node.next
      }
      return graph
    }

    function graphToCoords(graph) {
      const coordinates = [graph.point]
      for (let node = graph, i = 1; node.next; node = node.next, ++i) {
        coordinates[i] = node.next.point
      }
      return coordinates
    }

    const depthInput = document.getElementById("depth")

    function update() {
      makeFractal(Number(depthInput.value))
    }

    let updateTimer

    /**
     * Regenerate fractal on depth change.  Change events are debounced so updates
     * only occur every 200ms.
     */
    depthInput.onchange = function () {
      window.clearTimeout(updateTimer)
      updateTimer = window.setTimeout(update, 200)
    }

    update()
  },
}
</script>
```

:::
