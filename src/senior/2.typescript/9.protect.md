---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 九.案例 9

## 1.标记动画

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <label for="speed">
    speed:&nbsp;
    <input id="speed" type="range" min="10" max="999" step="10" value="60" />
  </label>
  <button id="start-animation">Start Animation</button>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Point },
      format: { Polyline },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Icon, Stroke, Style },
      render: { getVectorContext },
    } = ol

    const key = "ebmPcf5wTgRus4imoGrg"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const center = [-5639523.95, -3501274.52]
    const map = new Map({
      target: this.$refs.map,
      view: new View({
        center: center,
        zoom: 10,
        minZoom: 2,
        maxZoom: 19,
      }),
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/maps/hybrid/{z}/{x}/{y}.jpg?key=" + key,
            tileSize: 512,
          }),
        }),
      ],
    })

    fetch(this.$withBase("/data/polyline/route.json")).then(function (response) {
      response.json().then(function (result) {
        const polyline = result.routes[0].geometry

        const route = new Polyline({
          factor: 1e6,
        }).readGeometry(polyline, {
          dataProjection: "EPSG:4326",
          featureProjection: "EPSG:3857",
        })

        const routeFeature = new Feature({
          type: "route",
          geometry: route,
        })
        const startMarker = new Feature({
          type: "icon",
          geometry: new Point(route.getFirstCoordinate()),
        })
        const endMarker = new Feature({
          type: "icon",
          geometry: new Point(route.getLastCoordinate()),
        })
        const position = startMarker.getGeometry().clone()
        const geoMarker = new Feature({
          type: "geoMarker",
          geometry: position,
        })

        const styles = {
          route: new Style({
            stroke: new Stroke({
              width: 6,
              color: [237, 212, 0, 0.8],
            }),
          }),
          icon: new Style({
            image: new Icon({
              anchor: [0.5, 1],
              src: this.$withBase("/data/icon.png"),
            }),
          }),
          geoMarker: new Style({
            image: new CircleStyle({
              radius: 7,
              fill: new Fill({ color: "black" }),
              stroke: new Stroke({
                color: "white",
                width: 2,
              }),
            }),
          }),
        }

        const vectorLayer = new VectorLayer({
          source: new VectorSource({
            features: [routeFeature, geoMarker, startMarker, endMarker],
          }),
          style: function (feature) {
            return styles[feature.get("type")]
          },
        })

        map.addLayer(vectorLayer)

        const speedInput = document.getElementById("speed")
        const startButton = document.getElementById("start-animation")
        let animating = false
        let distance = 0
        let lastTime

        function moveFeature(event) {
          const speed = Number(speedInput.value)
          const time = event.frameState.time
          const elapsedTime = time - lastTime
          distance = (distance + (speed * elapsedTime) / 1e6) % 2
          lastTime = time

          const currentCoordinate = route.getCoordinateAt(
            distance > 1 ? 2 - distance : distance
          )
          position.setCoordinates(currentCoordinate)
          const vectorContext = getVectorContext(event)
          vectorContext.setStyle(styles.geoMarker)
          vectorContext.drawGeometry(position)
          // tell OpenLayers to continue the postrender animation
          map.render()
        }

        function startAnimation() {
          animating = true
          lastTime = Date.now()
          startButton.textContent = "Stop Animation"
          vectorLayer.on("postrender", moveFeature)
          // hide geoMarker and trigger map render through change event
          geoMarker.setGeometry(null)
        }

        function stopAnimation() {
          animating = false
          startButton.textContent = "Start Animation"

          // Keep marker at current animation position
          geoMarker.setGeometry(position)
          vectorLayer.un("postrender", moveFeature)
        }

        startButton.addEventListener("click", function () {
          if (animating) {
            stopAnimation()
          } else {
            startAnimation()
          }
        })
      })
    })
  },
}
</script>
```

:::

## 2.测量

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">Measurement type &nbsp;</label>
    <select id="type">
      <option value="length">Length (LineString)</option>
      <option value="area">Area (Polygon)</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { Draw },
      Overlay,
      geom: { LineString, Polygon },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      sphere: { getArea, getLength },
      Observable: { unByKey },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource()
    const vector = new VectorLayer({
      source: source,
      style: new Style({
        fill: new Fill({
          color: "rgba(255, 255, 255, 0.2)",
        }),
        stroke: new Stroke({
          color: "#ffcc33",
          width: 2,
        }),
        image: new CircleStyle({
          radius: 7,
          fill: new Fill({
            color: "#ffcc33",
          }),
        }),
      }),
    })
    let sketch
    let helpTooltipElement
    let helpTooltip
    let measureTooltipElement
    let measureTooltip
    const continuePolygonMsg = "Click to continue drawing the polygon"
    const continueLineMsg = "Click to continue drawing the line"
    const pointerMoveHandler = function (evt) {
      if (evt.dragging) {
        return
      }
      let helpMsg = "Click to start drawing"
      if (sketch) {
        const geom = sketch.getGeometry()
        if (geom instanceof Polygon) {
          helpMsg = continuePolygonMsg
        } else if (geom instanceof LineString) {
          helpMsg = continueLineMsg
        }
      }
      helpTooltipElement.innerHTML = helpMsg
      helpTooltip.setPosition(evt.coordinate)
      helpTooltipElement.classList.remove("hidden")
    }
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 15,
      }),
    })
    map.on("pointermove", pointerMoveHandler)
    map.getViewport().addEventListener("mouseout", function () {
      helpTooltipElement.classList.add("hidden")
    })
    const typeSelect = document.getElementById("type")
    let draw
    const formatLength = function (line) {
      const length = getLength(line)
      let output
      if (length > 100) {
        output = Math.round((length / 1000) * 100) / 100 + " " + "km"
      } else {
        output = Math.round(length * 100) / 100 + " " + "m"
      }
      return output
    }
    const formatArea = function (polygon) {
      const area = getArea(polygon)
      let output
      if (area > 10000) {
        output =
          Math.round((area / 1000000) * 100) / 100 + " " + "km<sup>2</sup>"
      } else {
        output = Math.round(area * 100) / 100 + " " + "m<sup>2</sup>"
      }
      return output
    }
    function addInteraction() {
      const type = typeSelect.value == "area" ? "Polygon" : "LineString"
      draw = new Draw({
        source: source,
        type: type,
        style: new Style({
          fill: new Fill({
            color: "rgba(255, 255, 255, 0.2)",
          }),
          stroke: new Stroke({
            color: "rgba(0, 0, 0, 0.5)",
            lineDash: [10, 10],
            width: 2,
          }),
          image: new CircleStyle({
            radius: 5,
            stroke: new Stroke({
              color: "rgba(0, 0, 0, 0.7)",
            }),
            fill: new Fill({
              color: "rgba(255, 255, 255, 0.2)",
            }),
          }),
        }),
      })
      map.addInteraction(draw)
      createMeasureTooltip()
      createHelpTooltip()
      let listener
      draw.on("drawstart", function (evt) {
        sketch = evt.feature
        let tooltipCoord = evt.coordinate
        listener = sketch.getGeometry().on("change", function (evt) {
          const geom = evt.target
          let output
          if (geom instanceof Polygon) {
            output = formatArea(geom)
            tooltipCoord = geom.getInteriorPoint().getCoordinates()
          } else if (geom instanceof LineString) {
            output = formatLength(geom)
            tooltipCoord = geom.getLastCoordinate()
          }
          measureTooltipElement.innerHTML = output
          measureTooltip.setPosition(tooltipCoord)
        })
      })
      draw.on("drawend", function () {
        measureTooltipElement.className = "ol-tooltip ol-tooltip-static"
        measureTooltip.setOffset([0, -7])
        sketch = null
        measureTooltipElement = null
        createMeasureTooltip()
        unByKey(listener)
      })
    }
    function createHelpTooltip() {
      if (helpTooltipElement) {
        helpTooltipElement.parentNode.removeChild(helpTooltipElement)
      }
      helpTooltipElement = document.createElement("div")
      helpTooltipElement.className = "ol-tooltip hidden"
      helpTooltip = new Overlay({
        element: helpTooltipElement,
        offset: [15, 0],
        positioning: "center-left",
      })
      map.addOverlay(helpTooltip)
    }
    function createMeasureTooltip() {
      if (measureTooltipElement) {
        measureTooltipElement.parentNode.removeChild(measureTooltipElement)
      }
      measureTooltipElement = document.createElement("div")
      measureTooltipElement.className = "ol-tooltip ol-tooltip-measure"
      measureTooltip = new Overlay({
        element: measureTooltipElement,
        offset: [0, -15],
        positioning: "bottom-center",
        stopEvent: false,
        insertFirst: false,
      })
      map.addOverlay(measureTooltip)
    }
    typeSelect.onchange = function () {
      map.removeInteraction(draw)
      addInteraction()
    }
    addInteraction()
  },
}
</script>
```

:::

## 3.使用矢量样式进行测量

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">Measurement type &nbsp;</label>
    <select id="type">
      <option value="LineString">Length (LineString)</option>
      <option value="Polygon">Area (Polygon)</option>
    </select>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <label for="segments">Show segment lengths:&nbsp;</label>
    <input type="checkbox" id="segments" checked />
    &nbsp;&nbsp;&nbsp;&nbsp;
    <label for="clear">Clear previous measure:&nbsp;</label>
    <input type="checkbox" id="clear" checked />
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { Draw, Modify },
      geom: { LineString, Point },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, RegularShape, Stroke, Style, Text },
      sphere: { getArea, getLength },
    } = ol
    const typeSelect = document.getElementById("type")
    const showSegments = document.getElementById("segments")
    const clearPrevious = document.getElementById("clear")
    const style = new Style({
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.2)",
      }),
      stroke: new Stroke({
        color: "rgba(0, 0, 0, 0.5)",
        lineDash: [10, 10],
        width: 2,
      }),
      image: new CircleStyle({
        radius: 5,
        stroke: new Stroke({
          color: "rgba(0, 0, 0, 0.7)",
        }),
        fill: new Fill({
          color: "rgba(255, 255, 255, 0.2)",
        }),
      }),
    })
    const labelStyle = new Style({
      text: new Text({
        font: "14px Calibri,sans-serif",
        fill: new Fill({
          color: "rgba(255, 255, 255, 1)",
        }),
        backgroundFill: new Fill({
          color: "rgba(0, 0, 0, 0.7)",
        }),
        padding: [3, 3, 3, 3],
        textBaseline: "bottom",
        offsetY: -15,
      }),
      image: new RegularShape({
        radius: 8,
        points: 3,
        angle: Math.PI,
        displacement: [0, 10],
        fill: new Fill({
          color: "rgba(0, 0, 0, 0.7)",
        }),
      }),
    })
    const tipStyle = new Style({
      text: new Text({
        font: "12px Calibri,sans-serif",
        fill: new Fill({
          color: "rgba(255, 255, 255, 1)",
        }),
        backgroundFill: new Fill({
          color: "rgba(0, 0, 0, 0.4)",
        }),
        padding: [2, 2, 2, 2],
        textAlign: "left",
        offsetX: 15,
      }),
    })
    const modifyStyle = new Style({
      image: new CircleStyle({
        radius: 5,
        stroke: new Stroke({
          color: "rgba(0, 0, 0, 0.7)",
        }),
        fill: new Fill({
          color: "rgba(0, 0, 0, 0.4)",
        }),
      }),
      text: new Text({
        text: "Drag to modify",
        font: "12px Calibri,sans-serif",
        fill: new Fill({
          color: "rgba(255, 255, 255, 1)",
        }),
        backgroundFill: new Fill({
          color: "rgba(0, 0, 0, 0.7)",
        }),
        padding: [2, 2, 2, 2],
        textAlign: "left",
        offsetX: 15,
      }),
    })
    const segmentStyle = new Style({
      text: new Text({
        font: "12px Calibri,sans-serif",
        fill: new Fill({
          color: "rgba(255, 255, 255, 1)",
        }),
        backgroundFill: new Fill({
          color: "rgba(0, 0, 0, 0.4)",
        }),
        padding: [2, 2, 2, 2],
        textBaseline: "bottom",
        offsetY: -12,
      }),
      image: new RegularShape({
        radius: 6,
        points: 3,
        angle: Math.PI,
        displacement: [0, 8],
        fill: new Fill({
          color: "rgba(0, 0, 0, 0.4)",
        }),
      }),
    })
    const segmentStyles = [segmentStyle]
    const formatLength = function (line) {
      const length = getLength(line)
      let output
      if (length > 100) {
        output = Math.round((length / 1000) * 100) / 100 + " km"
      } else {
        output = Math.round(length * 100) / 100 + " m"
      }
      return output
    }
    const formatArea = function (polygon) {
      const area = getArea(polygon)
      let output
      if (area > 10000) {
        output = Math.round((area / 1000000) * 100) / 100 + " km\xB2"
      } else {
        output = Math.round(area * 100) / 100 + " m\xB2"
      }
      return output
    }
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource()
    const modify = new Modify({ source: source, style: modifyStyle })
    let tipPoint
    function styleFunction(feature, segments, drawType, tip) {
      const styles = [style]
      const geometry = feature.getGeometry()
      const type = geometry.getType()
      let point, label, line
      if (!drawType || drawType === type) {
        if (type === "Polygon") {
          point = geometry.getInteriorPoint()
          label = formatArea(geometry)
          line = new LineString(geometry.getCoordinates()[0])
        } else if (type === "LineString") {
          point = new Point(geometry.getLastCoordinate())
          label = formatLength(geometry)
          line = geometry
        }
      }
      if (segments && line) {
        let count = 0
        line.forEachSegment(function (a, b) {
          const segment = new LineString([a, b])
          const label = formatLength(segment)
          if (segmentStyles.length - 1 < count) {
            segmentStyles.push(segmentStyle.clone())
          }
          const segmentPoint = new Point(segment.getCoordinateAt(0.5))
          segmentStyles[count].setGeometry(segmentPoint)
          segmentStyles[count].getText().setText(label)
          styles.push(segmentStyles[count])
          count++
        })
      }
      if (label) {
        labelStyle.setGeometry(point)
        labelStyle.getText().setText(label)
        styles.push(labelStyle)
      }
      if (
        tip &&
        type === "Point" &&
        !modify.getOverlay().getSource().getFeatures().length
      ) {
        tipPoint = geometry
        tipStyle.getText().setText(tip)
        styles.push(tipStyle)
      }
      return styles
    }
    const vector = new VectorLayer({
      source: source,
      style: function (feature) {
        return styleFunction(feature, showSegments.checked)
      },
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 15,
      }),
    })
    map.addInteraction(modify)
    let draw
    function addInteraction() {
      const drawType = typeSelect.value
      const activeTip =
        "Click to continue drawing the " +
        (drawType === "Polygon" ? "polygon" : "line")
      const idleTip = "Click to start measuring"
      let tip = idleTip
      draw = new Draw({
        source: source,
        type: drawType,
        style: function (feature) {
          return styleFunction(feature, showSegments.checked, drawType, tip)
        },
      })
      draw.on("drawstart", function () {
        if (clearPrevious.checked) {
          source.clear()
        }
        modify.setActive(false)
        tip = activeTip
      })
      draw.on("drawend", function () {
        modifyStyle.setGeometry(tipPoint)
        modify.setActive(true)
        map.once("pointermove", function () {
          modifyStyle.setGeometry()
        })
        tip = idleTip
      })
      modify.setActive(true)
      map.addInteraction(draw)
    }
    typeSelect.onchange = function () {
      map.removeInteraction(draw)
      addInteraction()
    }
    addInteraction()
    showSegments.onchange = function () {
      vector.changed()
      draw.getOverlay().changed()
    }
  },
}
</script>
```

:::

## 4.修改功能

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      interaction: { Modify, Select, defaults: defaultInteractions },
      style: Style,
    } = ol
    const vector = new VectorLayer({
      background: "white",
      source: new VectorSource({
        url: "https://openlayers.org/data/vector/us-states.json",
        format: new GeoJSON(),
        wrapX: false,
      }),
    })
    const select = new Select({
      wrapX: false,
    })
    const modify = new Modify({
      features: select.getFeatures(),
    })
    const map = new Map({
      interactions: defaultInteractions().extend([select, modify]),
      layers: [vector],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-100, 38.5]),
        zoom: 4,
      }),
    })
  },
}
</script>
```

:::

## 5.修改功能测试

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      interaction: { Modify, Select, defaults: defaultInteractions },
    } = ol
    const styleFunction = (function () {
      const styles = {}
      const image = new CircleStyle({
        radius: 5,
        fill: null,
        stroke: new Stroke({ color: "orange", width: 2 }),
      })
      styles["Point"] = new Style({ image: image })
      styles["Polygon"] = new Style({
        stroke: new Stroke({
          color: "blue",
          width: 3,
        }),
        fill: new Fill({
          color: "rgba(0, 0, 255, 0.1)",
        }),
      })
      styles["MultiLineString"] = new Style({
        stroke: new Stroke({
          color: "green",
          width: 3,
        }),
      })
      styles["MultiPolygon"] = new Style({
        stroke: new Stroke({
          color: "yellow",
          width: 1,
        }),
        fill: new Fill({
          color: "rgba(255, 255, 0, 0.1)",
        }),
      })
      styles["default"] = new Style({
        stroke: new Stroke({
          color: "red",
          width: 3,
        }),
        fill: new Fill({
          color: "rgba(255, 0, 0, 0.1)",
        }),
        image: image,
      })
      return function (feature) {
        return styles[feature.getGeometry().getType()] || styles["default"]
      }
    })()
    const geojsonObject = {
      type: "FeatureCollection",
      crs: {
        type: "name",
        properties: {
          name: "EPSG:3857",
        },
      },
      features: [
        {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [0, 0],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "MultiPoint",
            coordinates: [
              [-2e6, 0],
              [0, -2e6],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: [
              [4e6, -2e6],
              [8e6, 2e6],
              [9e6, 2e6],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: [
              [4e6, -2e6],
              [8e6, 2e6],
              [8e6, 3e6],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: [
              [
                [-5e6, -1e6],
                [-4e6, 1e6],
                [-3e6, -1e6],
                [-5e6, -1e6],
              ],
              [
                [-4.5e6, -0.5e6],
                [-3.5e6, -0.5e6],
                [-4e6, 0.5e6],
                [-4.5e6, -0.5e6],
              ],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "MultiLineString",
            coordinates: [
              [
                [-1e6, -7.5e5],
                [-1e6, 7.5e5],
              ],
              [
                [-1e6, -7.5e5],
                [-1e6, 7.5e5],
                [-5e5, 0],
                [-1e6, -7.5e5],
              ],
              [
                [1e6, -7.5e5],
                [15e5, 0],
                [15e5, 0],
                [1e6, 7.5e5],
              ],
              [
                [-7.5e5, -1e6],
                [7.5e5, -1e6],
              ],
              [
                [-7.5e5, 1e6],
                [7.5e5, 1e6],
              ],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "MultiPolygon",
            coordinates: [
              [
                [
                  [-5e6, 6e6],
                  [-5e6, 8e6],
                  [-3e6, 8e6],
                  [-3e6, 6e6],
                  [-5e6, 6e6],
                ],
              ],
              [
                [
                  [-3e6, 6e6],
                  [-2e6, 8e6],
                  [0, 8e6],
                  [0, 6e6],
                  [-3e6, 6e6],
                ],
              ],
              [
                [
                  [1e6, 6e6],
                  [1e6, 8e6],
                  [3e6, 8e6],
                  [3e6, 6e6],
                  [1e6, 6e6],
                ],
              ],
            ],
          },
        },
        {
          type: "Feature",
          geometry: {
            type: "GeometryCollection",
            geometries: [
              {
                type: "LineString",
                coordinates: [
                  [-5e6, -5e6],
                  [0, -5e6],
                ],
              },
              {
                type: "Point",
                coordinates: [4e6, -5e6],
              },
              {
                type: "Polygon",
                coordinates: [
                  [
                    [1e6, -5e6],
                    [2e6, -3.5e6],
                    [3e6, -5e6],
                    [1e6, -5e6],
                  ],
                ],
              },
              {
                type: "Polygon",
                coordinates: [
                  [
                    [1e6, -5e6],
                    [2e6, -6.5e6],
                    [3e6, -5e6],
                    [1e6, -5e6],
                  ],
                ],
              },
            ],
          },
        },
      ],
    }
    const source = new VectorSource({
      features: new GeoJSON().readFeatures(geojsonObject),
    })
    const layer = new VectorLayer({
      source: source,
      style: styleFunction,
    })
    const overlayStyle = (function () {
      const styles = {}
      styles["Polygon"] = [
        new Style({
          fill: new Fill({
            color: [255, 255, 255, 0.5],
          }),
        }),
        new Style({
          stroke: new Stroke({
            color: [255, 255, 255, 1],
            width: 5,
          }),
        }),
        new Style({
          stroke: new Stroke({
            color: [0, 153, 255, 1],
            width: 3,
          }),
        }),
      ]
      styles["MultiPolygon"] = styles["Polygon"]

      styles["LineString"] = [
        new Style({
          stroke: new Stroke({
            color: [255, 255, 255, 1],
            width: 5,
          }),
        }),
        new Style({
          stroke: new Stroke({
            color: [0, 153, 255, 1],
            width: 3,
          }),
        }),
      ]
      styles["MultiLineString"] = styles["LineString"]

      styles["Point"] = [
        new Style({
          image: new CircleStyle({
            radius: 7,
            fill: new Fill({
              color: [0, 153, 255, 1],
            }),
            stroke: new Stroke({
              color: [255, 255, 255, 0.75],
              width: 1.5,
            }),
          }),
          zIndex: 100000,
        }),
      ]
      styles["MultiPoint"] = styles["Point"]
      styles["GeometryCollection"] = styles["Polygon"].concat(styles["Point"])
      return function (feature) {
        return styles[feature.getGeometry().getType()]
      }
    })()
    const select = new Select({
      style: overlayStyle,
    })
    const modify = new Modify({
      features: select.getFeatures(),
      style: overlayStyle,
      insertVertexCondition: function () {
        return !select
          .getFeatures()
          .getArray()
          .every(function (feature) {
            return feature
              .getGeometry()
              .getType()
              .match(/Polygon/)
          })
      },
    })
    const map = new Map({
      interactions: defaultInteractions().extend([select, modify]),
      layers: [layer],
      target: this.$refs.map,
      view: new View({
        center: [0, 1000000],
        zoom: 2,
        multiWorld: true,
      }),
    })
  },
}
</script>
```

:::
