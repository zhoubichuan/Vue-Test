---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 一.案例1

## 1.合成线

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { LineString },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: { Stroke, Style },
    } = ol
    const count = 10000
    const features = new Array(count)

    let startPoint = [0, 0]
    let endPoint

    let delta, deltaX, deltaY
    let signX = 1
    let signY = -1

    // Create a square spiral.
    let i
    for (i = 0; i < count; ++i) {
      delta = (i + 1) * 2500
      if (i % 2 === 0) {
        signY *= -1
      } else {
        signX *= -1
      }
      deltaX = delta * signX
      deltaY = delta * signY
      endPoint = [startPoint[0] + deltaX, startPoint[1] + deltaY]
      features[i] = new Feature({
        geometry: new LineString([startPoint, endPoint]),
      })
      startPoint = endPoint
    }

    const vector = new VectorLayer({
      source: new VectorSource({
        features: features,
        wrapX: false,
      }),
      style: new Style({
        stroke: new Stroke({
          color: "#666666",
          width: 1,
        }),
      }),
    })

    const view = new View({
      center:[12579156, 3274244],
      zoom: 0,
    })

    const map = new Map({
      layers: [vector],
      target: this.$refs.map,
      view: view,
    })
  },
}
</script>
```

:::

## 2.合成点

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      geom: { LineString, Point },
      render: { getVectorContext },
    } = ol

    const count = 20000
    const features = new Array(count)
    const e = 18000000
    for (let i = 0; i < count; ++i) {
      features[i] = new Feature({
        geometry: new Point([
          2 * e * Math.random() - e,
          2 * e * Math.random() - e,
        ]),
        i: i,
        size: i % 2 ? 10 : 20,
      })
    }

    const styles = {
      10: new Style({
        image: new CircleStyle({
          radius: 5,
          fill: new Fill({ color: "#666666" }),
          stroke: new Stroke({ color: "#bada55", width: 1 }),
        }),
      }),
      20: new Style({
        image: new CircleStyle({
          radius: 10,
          fill: new Fill({ color: "#666666" }),
          stroke: new Stroke({ color: "#bada55", width: 1 }),
        }),
      }),
    }

    const vectorSource = new VectorSource({
      features: features,
      wrapX: false,
    })
    const vector = new VectorLayer({
      source: vectorSource,
      style: function (feature) {
        return styles[feature.get("size")]
      },
    })

    const map = new Map({
      layers: [vector],
      target: document.getElementById("map"),
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    let point = null
    let line = null
    const displaySnap = function (coordinate) {
      const closestFeature =
        vectorSource.getClosestFeatureToCoordinate(coordinate)
      if (closestFeature === null) {
        point = null
        line = null
      } else {
        const geometry = closestFeature.getGeometry()
        const closestPoint = geometry.getClosestPoint(coordinate)
        if (point === null) {
          point = new Point(closestPoint)
        } else {
          point.setCoordinates(closestPoint)
        }
        if (line === null) {
          line = new LineString([coordinate, closestPoint])
        } else {
          line.setCoordinates([coordinate, closestPoint])
        }
      }
      map.render()
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const coordinate = map.getEventCoordinate(evt.originalEvent)
      displaySnap(coordinate)
    })

    map.on("click", function (evt) {
      displaySnap(evt.coordinate)
    })

    const stroke = new Stroke({
      color: "rgba(255,255,0,0.9)",
      width: 3,
    })
    const style = new Style({
      stroke: stroke,
      image: new CircleStyle({
        radius: 10,
        stroke: stroke,
      }),
    })

    vector.on("postrender", function (evt) {
      const vectorContext = getVectorContext(evt)
      vectorContext.setStyle(style)
      if (point !== null) {
        vectorContext.drawGeometry(point)
      }
      if (line !== null) {
        vectorContext.drawGeometry(line)
      }
    })

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      const hit = map.hasFeatureAtPixel(pixel)
      if (hit) {
        map.getTarget().style.cursor = "pointer"
      } else {
        map.getTarget().style.cursor = ""
      }
    })
  },
}
</script>
```

:::

## 3.传送地图

:::demo

```vue
<template>
  <div id="map1" class="map"></div>
  <div id="map2" class="map"></div>
  <button id="teleport">Teleport</button>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
    } = ol
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    map.setTarget("map1")

    const teleportButton = document.getElementById("teleport")

    teleportButton.addEventListener(
      "click",
      function () {
        const target = map.getTarget() === "map1" ? "map2" : "map1"
        map.setTarget(target)
      },
      false
    )
  },
}
</script>
```

:::

## 4.瓦片加载事件

:::demo

```vue
<template>
  <div class="wrapper">
    <div ref="map" class="map"></div>
    <div id="progress"></div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
    } = ol
    function Progress(el) {
      this.el = el
      this.loading = 0
      this.loaded = 0
    }

    /**
     * Increment the count of loading tiles.
     */
    Progress.prototype.addLoading = function () {
      ++this.loading
      this.update()
    }

    /**
     * Increment the count of loaded tiles.
     */
    Progress.prototype.addLoaded = function () {
      ++this.loaded
      this.update()
    }

    /**
     * Update the progress bar.
     */
    Progress.prototype.update = function () {
      const width = ((this.loaded / this.loading) * 100).toFixed(1) + "%"
      this.el.style.width = width
    }

    /**
     * Show the progress bar.
     */
    Progress.prototype.show = function () {
      this.el.style.visibility = "visible"
    }

    /**
     * Hide the progress bar.
     */
    Progress.prototype.hide = function () {
      const style = this.el.style
      setTimeout(function () {
        style.visibility = "hidden"
        style.width = 0
      }, 250)
    }

    const progress = new Progress(document.getElementById("progress"))

    const key = "get_your_own_D6rA4zTHduk6KOKTXzGB"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const source = new XYZ({
      attributions: attributions,
      url: "https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=" + key,
      tileSize: 512,
    })

    source.on("tileloadstart", function () {
      progress.addLoading()
    })
    source.on(["tileloadend", "tileloaderror"], function () {
      progress.addLoaded()
    })

    const map = new Map({
      layers: [new TileLayer({ source: source })],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    map.on("loadstart", function () {
      progress.show()
    })
    map.on("loadend", function () {
      progress.hide()
    })
  },
}
</script>
```

:::

## 5.瓦片过渡

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <label>
    render with an opacity transition
    <input id="transition" type="checkbox" checked />
  </label>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const url =
      "https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=" + key

    const withTransition = new TileLayer({
      source: new XYZ({ url: url, tileSize: 512, attributions: attributions }),
    })

    const withoutTransition = new TileLayer({
      source: new XYZ({
        url: url,
        transition: 0,
        tileSize: 512,
        attributions: attributions,
      }),
      visible: false,
    })

    const map = new Map({
      layers: [withTransition, withoutTransition],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
        maxZoom: 11,
      }),
    })

    document
      .getElementById("transition")
      .addEventListener("change", function (event) {
        const transition = event.target.checked
        withTransition.setVisible(transition)
        withoutTransition.setVisible(!transition)
      })
  },
}
</script>
```

:::
