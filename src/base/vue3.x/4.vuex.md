---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 六.地图绘制

- 场景
  - 电子围栏

## 1.绘制和修改功能

将 ol/interaction/Draw 交互与 ol/interaction/Modify 交互一起使用的示例。

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">几何类型 &nbsp;</label>
    <select ref="type">
      <option value="Point">点</option>
      <option value="LineString">直线</option>
      <option value="Polygon">多边形</option>
      <option value="Circle">圆</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      interaction: { Draw, Modify, Snap },
      proj: { get },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource()
    const vector = new VectorLayer({
      source: source,
      style: new Style({
        fill: new Fill({
          color: "rgba(255, 255, 255, 0.2)",
        }),
        stroke: new Stroke({
          color: "#ffcc33",
          width: 2,
        }),
        image: new CircleStyle({
          radius: 7,
          fill: new Fill({
            color: "#ffcc33",
          }),
        }),
      }),
    })
    const extent = get("EPSG:3857").getExtent().slice()
    extent[0] += extent[0]
    extent[2] += extent[2]
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 3,
        extent,
      }),
    })
    const modify = new Modify({ source: source })
    map.addInteraction(modify)
    let draw, snap
    const typeSelect = this.$refs.type
    function addInteractions() {
      draw = new Draw({
        source: source,
        type: typeSelect.value,
      })
      map.addInteraction(draw)
      snap = new Snap({ source: source })
      map.addInteraction(snap)
    }
    typeSelect.onchange = function () {
      map.removeInteraction(draw)
      map.removeInteraction(snap)
      addInteractions()
    }
    addInteractions()
  },
}
</script>
```

:::

## 2.绘制和修改测地线圆

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">几何类型 &nbsp;</label>
    <select ref="type">
      <option value="Point">点</option>
      <option value="LineString">直线</option>
      <option value="Polygon">多边形</option>
      <option value="Circle">圆</option>
      <option value="Geodesic" selected>测地线圆</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { GeometryCollection, Point, Polygon, Polygon: circular },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      interaction: { Draw, Modify, Snap },
      proj: { transform },
      sphere: { getDistance },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource()
    const style = new Style({
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.2)",
      }),
      stroke: new Stroke({
        color: "#33cc33",
        width: 2,
      }),
      image: new CircleStyle({
        radius: 7,
        fill: new Fill({
          color: "#ffcc33",
        }),
      }),
    })
    const geodesicStyle = new Style({
      geometry: function (feature) {
        return feature.get("modifyGeometry") || feature.getGeometry()
      },
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.2)",
      }),
      stroke: new Stroke({
        color: "#ff3333",
        width: 2,
      }),
      image: new CircleStyle({
        radius: 7,
        fill: new Fill({
          color: "rgba(0, 0, 0, 0)",
        }),
      }),
    })
    const vector = new VectorLayer({
      source: source,
      style: function (feature) {
        const geometry = feature.getGeometry()
        return geometry.getType() === "GeometryCollection"
          ? geodesicStyle
          : style
      },
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 3,
      }),
    })
    const defaultStyle = new Modify({ source: source })
      .getOverlay()
      .getStyleFunction()
    const modify = new Modify({
      source: source,
      style: function (feature) {
        feature.get("features").forEach(function (modifyFeature) {
          const modifyGeometry = modifyFeature.get("modifyGeometry")
          if (modifyGeometry) {
            const modifyPoint = feature.getGeometry().getCoordinates()
            const geometries = modifyFeature.getGeometry().getGeometries()
            const polygon = geometries[0].getCoordinates()[0]
            const center = geometries[1].getCoordinates()
            const projection = map.getView().getProjection()
            let first, last, radius
            if (modifyPoint[0] === center[0] && modifyPoint[1] === center[1]) {
              first = transform(polygon[0], projection, "EPSG:4326")
              last = transform(
                polygon[(polygon.length - 1) / 2],
                projection,
                "EPSG:4326"
              )
              radius = getDistance(first, last) / 2
            } else {
              first = transform(center, projection, "EPSG:4326")
              last = transform(modifyPoint, projection, "EPSG:4326")
              radius = getDistance(first, last)
            }
            const circle = circular(
              transform(center, projection, "EPSG:4326"),
              radius,
              128
            )
            circle.transform("EPSG:4326", projection)
            geometries[0].setCoordinates(circle.getCoordinates())
            modifyGeometry.setGeometries(geometries)
          }
        })
        return defaultStyle(feature)
      },
    })
    modify.on("modifystart", function (event) {
      event.features.forEach(function (feature) {
        const geometry = feature.getGeometry()
        if (geometry.getType() === "GeometryCollection") {
          feature.set("modifyGeometry", geometry.clone(), true)
        }
      })
    })
    modify.on("modifyend", function (event) {
      event.features.forEach(function (feature) {
        const modifyGeometry = feature.get("modifyGeometry")
        if (modifyGeometry) {
          feature.setGeometry(modifyGeometry)
          feature.unset("modifyGeometry", true)
        }
      })
    })
    map.addInteraction(modify)
    let draw, snap
    const typeSelect = this.$refs.type
    function addInteractions() {
      let value = typeSelect.value
      let geometryFunction
      if (value === "Geodesic") {
        value = "Circle"
        geometryFunction = function (coordinates, geometry, projection) {
          if (!geometry) {
            geometry = new GeometryCollection([
              new Polygon([]),
              new Point(coordinates[0]),
            ])
          }
          const geometries = geometry.getGeometries()
          const center = transform(coordinates[0], projection, "EPSG:4326")
          const last = transform(coordinates[1], projection, "EPSG:4326")
          const radius = getDistance(center, last)
          const circle = circular(center, radius, 128)
          circle.transform("EPSG:4326", projection)
          geometries[0].setCoordinates(circle.getCoordinates())
          geometry.setGeometries(geometries)
          return geometry
        }
      }
      draw = new Draw({
        source: source,
        type: value,
        geometryFunction: geometryFunction,
      })
      map.addInteraction(draw)
      snap = new Snap({ source: source })
      map.addInteraction(snap)
    }
    typeSelect.onchange = function () {
      map.removeInteraction(draw)
      map.removeInteraction(snap)
      addInteractions()
    }
    addInteractions()
  },
}
</script>
```

:::

## 3.snap

将 snap 交互与绘制和修改交互一起使用

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form ref="optionsform" autocomplete="off">
    <div class="radio">
      <label>
        <input type="radio" name="interaction" value="draw" id="draw" checked />
        编辑 &nbsp;
      </label>
      <select name="draw-type" id="draw-type">
        <option value="Point">点</option>
        <option value="LineString">直线</option>
        <option value="Polygon">多边形</option>
        <option value="Circle">圆</option>
      </select>
    </div>
    <div class="radio">
      <label>
        <input type="radio" name="interaction" value="modify" />
        查看 &nbsp;
      </label>
    </div>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { Draw, Modify, Select, Snap },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
    } = ol

    const raster = new TileLayer({
      source: new OSM(),
    })

    const vector = new VectorLayer({
      source: new VectorSource(),
      style: new Style({
        fill: new Fill({
          color: "rgba(255, 255, 255, 0.2)",
        }),
        stroke: new Stroke({
          color: "#ffcc33",
          width: 2,
        }),
        image: new CircleStyle({
          radius: 7,
          fill: new Fill({
            color: "#ffcc33",
          }),
        }),
      }),
    })

    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 3,
      }),
    })

    const ExampleModify = {
      init: function () {
        this.select = new Select()
        map.addInteraction(this.select)

        this.modify = new Modify({
          features: this.select.getFeatures(),
        })
        map.addInteraction(this.modify)

        this.setEvents()
      },
      setEvents: function () {
        const selectedFeatures = this.select.getFeatures()

        this.select.on("change:active", function () {
          selectedFeatures.forEach(function (each) {
            selectedFeatures.remove(each)
          })
        })
      },
      setActive: function (active) {
        this.select.setActive(active)
        this.modify.setActive(active)
      },
    }
    ExampleModify.init()

    const optionsForm = this.$refs.optionsform

    const ExampleDraw = {
      init: function () {
        map.addInteraction(this.Point)
        this.Point.setActive(false)
        map.addInteraction(this.LineString)
        this.LineString.setActive(false)
        map.addInteraction(this.Polygon)
        this.Polygon.setActive(false)
        map.addInteraction(this.Circle)
        this.Circle.setActive(false)
      },
      Point: new Draw({
        source: vector.getSource(),
        type: "Point",
      }),
      LineString: new Draw({
        source: vector.getSource(),
        type: "LineString",
      }),
      Polygon: new Draw({
        source: vector.getSource(),
        type: "Polygon",
      }),
      Circle: new Draw({
        source: vector.getSource(),
        type: "Circle",
      }),
      activeDraw: null,
      setActive: function (active) {
        if (this.activeDraw) {
          this.activeDraw.setActive(false)
          this.activeDraw = null
        }
        if (active) {
          const type = optionsForm.elements["draw-type"].value
          this.activeDraw = this[type]
          this.activeDraw.setActive(true)
        }
      },
    }
    ExampleDraw.init()
    optionsForm.onchange = function (e) {
      const type = e.target.getAttribute("name")
      if (type == "draw-type") {
        ExampleModify.setActive(false)
        ExampleDraw.setActive(true)
        optionsForm.elements["interaction"].value = "draw"
      } else if (type == "interaction") {
        const interactionType = e.target.value
        if (interactionType == "modify") {
          ExampleDraw.setActive(false)
          ExampleModify.setActive(true)
        } else if (interactionType == "draw") {
          ExampleDraw.setActive(true)
          ExampleModify.setActive(false)
        }
      }
    }

    ExampleDraw.setActive(true)
    ExampleModify.setActive(false)
    const snap = new Snap({
      source: vector.getSource(),
    })
    map.addInteraction(snap)
  },
}
</script>
```

:::

## 4.地理编辑

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <select ref="mode">
    <option value="modify">选择要修改的特征</option>
    <option value="draw">画一个新的特征</option>
  </select>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Vector: VectorLayer },
      source: { Vector: VectorSource },
      interaction: { Draw, Modify, Select, Snap },
      proj: { useGeographic },
    } = ol
    useGeographic()

    const source = new VectorSource({
      url: "https://openlayers.org/data/vector/us-states.json",
      format: new GeoJSON(),
    })

    const map = new Map({
      target: this.$refs.map,
      layers: [
        new VectorLayer({
          background: "white",
          source: source,
        }),
      ],
      view: new View({
        center: [-100, 38.5],
        zoom: 4,
      }),
    })

    const select = new Select()

    const modify = new Modify({
      features: select.getFeatures(),
    })

    const draw = new Draw({
      type: "Polygon",
      source: source,
    })

    const snap = new Snap({
      source: source,
    })

    function removeInteractions() {
      map.removeInteraction(modify)
      map.removeInteraction(select)
      map.removeInteraction(draw)
      map.removeInteraction(select)
    }

    const mode = this.$refs.mode
    function onChange() {
      removeInteractions()
      switch (mode.value) {
        case "draw": {
          map.addInteraction(draw)
          map.addInteraction(snap)
          break
        }
        case "modify": {
          map.addInteraction(select)
          map.addInteraction(modify)
          map.addInteraction(snap)
          break
        }
        default: {
          // pass
        }
      }
    }
    mode.addEventListener("change", onChange)
    onChange()
  },
}
</script>
```

:::

## 5.手绘

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">几何类型 &nbsp;</label>
    <select ref="type">
      <option value="LineString">线条</option>
      <option value="Polygon">多边形</option>
      <option value="Circle">圆圈</option>
      <option value="None">无</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      interaction: { Draw },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource({ wrapX: false })
    const vector = new VectorLayer({
      source: source,
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 3,
      }),
    })
    const typeSelect = this.$refs.type
    let draw
    function addInteraction() {
      const value = typeSelect.value
      if (value !== "None") {
        draw = new Draw({
          source: source,
          type: typeSelect.value,
          freehand: true,
        })
        map.addInteraction(draw)
      }
    }
    typeSelect.onchange = function () {
      map.removeInteraction(draw)
      addInteraction()
    }
    addInteraction()
  },
}
</script>
```

:::

## 3.使用修改交互进行缩放和旋转

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">几何类型 &nbsp;</label>
    <select id="type">
      <option value="Point">点</option>
      <option value="LineString">直线</option>
      <option value="Polygon" selected>多边形</option>
      <option value="Circle">圆</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { MultiPoint, Point },
      interaction: { Draw, Modify, Translate },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      extent: { getCenter, getHeight, getWidth },
      events: {
        condition: { never, platformModifierKeyOnly, primaryAction },
      },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource()
    const style = new Style({
      geometry: function (feature) {
        const modifyGeometry = feature.get("modifyGeometry")
        return modifyGeometry ? modifyGeometry.geometry : feature.getGeometry()
      },
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.2)",
      }),
      stroke: new Stroke({
        color: "#ffcc33",
        width: 2,
      }),
      image: new CircleStyle({
        radius: 7,
        fill: new Fill({
          color: "#ffcc33",
        }),
      }),
    })
    function calculateCenter(geometry) {
      let center, coordinates, minRadius
      const type = geometry.getType()
      if (type === "Polygon") {
        let x = 0
        let y = 0
        let i = 0
        coordinates = geometry.getCoordinates()[0].slice(1)
        coordinates.forEach(function (coordinate) {
          x += coordinate[0]
          y += coordinate[1]
          i++
        })
        center = [x / i, y / i]
      } else if (type === "LineString") {
        center = geometry.getCoordinateAt(0.5)
        coordinates = geometry.getCoordinates()
      } else {
        center = getCenter(geometry.getExtent())
      }
      let sqDistances
      if (coordinates) {
        sqDistances = coordinates.map(function (coordinate) {
          const dx = coordinate[0] - center[0]
          const dy = coordinate[1] - center[1]
          return dx * dx + dy * dy
        })
        minRadius = Math.sqrt(Math.max.apply(Math, sqDistances)) / 3
      } else {
        minRadius =
          Math.max(
            getWidth(geometry.getExtent()),
            getHeight(geometry.getExtent())
          ) / 3
      }
      return {
        center: center,
        coordinates: coordinates,
        minRadius: minRadius,
        sqDistances: sqDistances,
      }
    }
    const vector = new VectorLayer({
      source: source,
      style: function (feature) {
        const styles = [style]
        const modifyGeometry = feature.get("modifyGeometry")
        const geometry = modifyGeometry
          ? modifyGeometry.geometry
          : feature.getGeometry()
        const result = calculateCenter(geometry)
        const center = result.center
        if (center) {
          styles.push(
            new Style({
              geometry: new Point(center),
              image: new CircleStyle({
                radius: 4,
                fill: new Fill({
                  color: "#ff3333",
                }),
              }),
            })
          )
          const coordinates = result.coordinates
          if (coordinates) {
            const minRadius = result.minRadius
            const sqDistances = result.sqDistances
            const rsq = minRadius * minRadius
            const points = coordinates.filter(function (coordinate, index) {
              return sqDistances[index] > rsq
            })
            styles.push(
              new Style({
                geometry: new MultiPoint(points),
                image: new CircleStyle({
                  radius: 4,
                  fill: new Fill({
                    color: "#33cc33",
                  }),
                }),
              })
            )
          }
        }
        return styles
      },
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 4,
      }),
    })
    const defaultStyle = new Modify({ source: source })
      .getOverlay()
      .getStyleFunction()
    const modify = new Modify({
      source: source,
      condition: function (event) {
        return primaryAction(event) && !platformModifierKeyOnly(event)
      },
      deleteCondition: never,
      insertVertexCondition: never,
      style: function (feature) {
        feature.get("features").forEach(function (modifyFeature) {
          const modifyGeometry = modifyFeature.get("modifyGeometry")
          if (modifyGeometry) {
            const point = feature.getGeometry().getCoordinates()
            let modifyPoint = modifyGeometry.point
            if (!modifyPoint) {
              modifyPoint = point
              modifyGeometry.point = modifyPoint
              modifyGeometry.geometry0 = modifyGeometry.geometry
              const result = calculateCenter(modifyGeometry.geometry0)
              modifyGeometry.center = result.center
              modifyGeometry.minRadius = result.minRadius
            }
            const center = modifyGeometry.center
            const minRadius = modifyGeometry.minRadius
            let dx, dy
            dx = modifyPoint[0] - center[0]
            dy = modifyPoint[1] - center[1]
            const initialRadius = Math.sqrt(dx * dx + dy * dy)
            if (initialRadius > minRadius) {
              const initialAngle = Math.atan2(dy, dx)
              dx = point[0] - center[0]
              dy = point[1] - center[1]
              const currentRadius = Math.sqrt(dx * dx + dy * dy)
              if (currentRadius > 0) {
                const currentAngle = Math.atan2(dy, dx)
                const geometry = modifyGeometry.geometry0.clone()
                geometry.scale(currentRadius / initialRadius, undefined, center)
                geometry.rotate(currentAngle - initialAngle, center)
                modifyGeometry.geometry = geometry
              }
            }
          }
        })
        return defaultStyle(feature)
      },
    })
    modify.on("modifystart", function (event) {
      event.features.forEach(function (feature) {
        feature.set(
          "modifyGeometry",
          { geometry: feature.getGeometry().clone() },
          true
        )
      })
    })
    modify.on("modifyend", function (event) {
      event.features.forEach(function (feature) {
        const modifyGeometry = feature.get("modifyGeometry")
        if (modifyGeometry) {
          feature.setGeometry(modifyGeometry.geometry)
          feature.unset("modifyGeometry", true)
        }
      })
    })
    map.addInteraction(modify)
    map.addInteraction(
      new Translate({
        condition: function (event) {
          return primaryAction(event) && platformModifierKeyOnly(event)
        },
        layers: [vector],
      })
    )
    let draw
    const typeSelect = document.getElementById("type")
    function addInteractions() {
      draw = new Draw({
        source: source,
        type: typeSelect.value,
      })
      map.addInteraction(draw)
    }
    typeSelect.onchange = function () {
      map.removeInteraction(draw)
      addInteractions()
    }
    addInteractions()
  },
}
</script>
```

:::
