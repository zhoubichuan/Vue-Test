---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-主题
  - name: keywords
    content: geom
---

# 九.geom

## 7.Point

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { Draw },
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Icon, Stroke, Style },
      proj: { get },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource()
    let that = this
    const styleFunction = function (feature) {
      const geometry = feature.getGeometry()
      const styles = [
        new Style({
          stroke: new Stroke({
            color: "#ffcc33",
            width: 2,
          }),
        }),
      ]
      geometry.forEachSegment(function (start, end) {
        const dx = end[0] - start[0]
        const dy = end[1] - start[1]
        const rotation = Math.atan2(dy, dx)
        styles.push(
          new Style({
            geometry: new Point(end),
            image: new Icon({
              src: that.$withBase("/data/arrow.png"),
              anchor: [0.75, 0.5],
              rotateWithView: true,
              rotation: -rotation,
            }),
          })
        )
      })
      return styles
    }
    const vector = new VectorLayer({
      source: source,
      style: styleFunction,
    })
    const extent = get("EPSG:3857").getExtent().slice()
    extent[0] += extent[0]
    extent[2] += extent[2]
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 4,
        extent,
      }),
    })
    map.addInteraction(
      new Draw({
        source: source,
        type: "LineString",
      })
    )
  },
}
</script>
```

:::

## 9.LineString

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">几何类型 &nbsp;</label>
    <select ref="type">
      <option value="Polygon">多边形</option>
      <option value="LineString">直线</option>
      <option value="None">无</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      interaction: { Draw, Snap },
      geom: { LineString },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Fill, Stroke, Style },
      format: { GeoJSON },
    } = ol
    function length(a, b) {
      return Math.sqrt(
        (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1])
      )
    }
    function isOnSegment(c, a, b) {
      const lengthAc = length(a, c)
      const lengthAb = length(a, b)
      const dot =
        ((c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])) /
        lengthAb
      return Math.abs(lengthAc - dot) < 1e-6 && lengthAc < lengthAb
    }
    function mod(a, b) {
      return ((a % b) + b) % b
    }
    function getPartialRingCoords(feature, startPoint, endPoint) {
      let polygon = feature.getGeometry()
      if (polygon.getType() === "MultiPolygon") {
        polygon = polygon.getPolygon(0)
      }
      const ringCoords = polygon.getLinearRing().getCoordinates()
      let i,
        pointA,
        pointB,
        startSegmentIndex = -1
      for (i = 0; i < ringCoords.length; i++) {
        pointA = ringCoords[i]
        pointB = ringCoords[mod(i + 1, ringCoords.length)]
        if (isOnSegment(startPoint, pointA, pointB)) {
          startSegmentIndex = i
          break
        }
      }
      const cwCoordinates = []
      let cwLength = 0
      const ccwCoordinates = []
      let ccwLength = 0
      for (i = 0; i < ringCoords.length; i++) {
        pointA =
          i === 0
            ? startPoint
            : ringCoords[mod(i + startSegmentIndex, ringCoords.length)]
        pointB = ringCoords[mod(i + startSegmentIndex + 1, ringCoords.length)]
        cwCoordinates.push(pointA)
        if (isOnSegment(endPoint, pointA, pointB)) {
          cwCoordinates.push(endPoint)
          cwLength += length(pointA, endPoint)
          break
        } else {
          cwLength += length(pointA, pointB)
        }
      }
      for (i = 0; i < ringCoords.length; i++) {
        pointA = ringCoords[mod(startSegmentIndex - i, ringCoords.length)]
        pointB =
          i === 0
            ? startPoint
            : ringCoords[mod(startSegmentIndex - i + 1, ringCoords.length)]
        ccwCoordinates.push(pointB)

        if (isOnSegment(endPoint, pointA, pointB)) {
          ccwCoordinates.push(endPoint)
          ccwLength += length(endPoint, pointB)
          break
        } else {
          ccwLength += length(pointA, pointB)
        }
      }
      return ccwLength < cwLength ? ccwCoordinates : cwCoordinates
    }
    const raster = new TileLayer({
      source: new OSM(),
    })
    const baseVector = new VectorLayer({
      source: new VectorSource({
        format: new GeoJSON(),
        url: "https://ahocevar.com/geoserver/wfs?service=wfs&request=getfeature&typename=topp:states&cql_filter=STATE_NAME='Idaho'&outputformat=application/json",
      }),
    })
    const drawVector = new VectorLayer({
      source: new VectorSource(),
      style: new Style({
        stroke: new Stroke({
          color: "rgba(100, 255, 0, 1)",
          width: 2,
        }),
        fill: new Fill({
          color: "rgba(100, 255, 0, 0.3)",
        }),
      }),
    })
    const previewLine = new Feature({
      geometry: new LineString([]),
    })
    const previewVector = new VectorLayer({
      source: new VectorSource({
        features: [previewLine],
      }),
      style: new Style({
        stroke: new Stroke({
          color: "rgba(255, 0, 0, 1)",
          width: 2,
        }),
      }),
    })
    const map = new Map({
      layers: [raster, baseVector, drawVector, previewVector],
      target: this.$refs.map,
      view: new View({
        center: [-12986427, 5678422],
        zoom: 5,
      }),
    })
    let drawInteraction, tracingFeature, startPoint, endPoint
    let drawing = false
    const getFeatureOptions = {
      hitTolerance: 10,
      layerFilter: (layer) => {
        return layer === baseVector
      },
    }
    map.on("click", (event) => {
      if (!drawing) {
        return
      }
      let hit = false
      map.forEachFeatureAtPixel(
        event.pixel,
        (feature) => {
          if (tracingFeature && feature !== tracingFeature) {
            return
          }
          hit = true
          const coord = map.getCoordinateFromPixel(event.pixel)
          if (feature === tracingFeature) {
            endPoint = tracingFeature.getGeometry().getClosestPoint(coord)
            const appendCoords = getPartialRingCoords(
              tracingFeature,
              startPoint,
              endPoint
            )
            drawInteraction.removeLastPoint()
            drawInteraction.appendCoordinates(appendCoords)
            tracingFeature = null
          }
          tracingFeature = feature
          startPoint = tracingFeature.getGeometry().getClosestPoint(coord)
        },
        getFeatureOptions
      )
      if (!hit) {
        previewLine.getGeometry().setCoordinates([])
        tracingFeature = null
      }
    })
    map.on("pointermove", (event) => {
      if (tracingFeature && drawing) {
        let coord = null
        map.forEachFeatureAtPixel(
          event.pixel,
          (feature) => {
            if (tracingFeature === feature) {
              coord = map.getCoordinateFromPixel(event.pixel)
            }
          },
          getFeatureOptions
        )
        let previewCoords = []
        if (coord) {
          endPoint = tracingFeature.getGeometry().getClosestPoint(coord)
          previewCoords = getPartialRingCoords(
            tracingFeature,
            startPoint,
            endPoint
          )
        }
        previewLine.getGeometry().setCoordinates(previewCoords)
      }
    })
    const snapInteraction = new Snap({
      source: baseVector.getSource(),
    })
    const typeSelect = this.$refs.type
    function addInteraction() {
      const value = typeSelect.value
      if (value !== "None") {
        drawInteraction = new Draw({
          source: drawVector.getSource(),
          type: typeSelect.value,
        })
        drawInteraction.on("drawstart", () => {
          drawing = true
        })
        drawInteraction.on("drawend", () => {
          drawing = false
          previewLine.getGeometry().setCoordinates([])
          tracingFeature = null
        })
        map.addInteraction(drawInteraction)
        map.addInteraction(snapInteraction)
      }
    }
    typeSelect.onchange = function () {
      map.removeInteraction(drawInteraction)
      map.removeInteraction(snapInteraction)
      addInteraction()
    }
    addInteraction()
  },
}
</script>
```

:::

## 5.MultiPoint

使用修改交互进行缩放和旋转

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <form class="form-inline">
    <label for="type">几何类型 &nbsp;</label>
    <select ref="type">
      <option value="Point">点</option>
      <option value="LineString">直线</option>
      <option value="Polygon" selected>多边形</option>
      <option value="Circle">圆</option>
    </select>
  </form>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { MultiPoint, Point },
      interaction: { Draw, Modify, Translate },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style },
      extent: { getCenter, getHeight, getWidth },
      events: {
        condition: { never, platformModifierKeyOnly, primaryAction },
      },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const source = new VectorSource()
    const style = new Style({
      geometry: function (feature) {
        const modifyGeometry = feature.get("modifyGeometry")
        return modifyGeometry ? modifyGeometry.geometry : feature.getGeometry()
      },
      fill: new Fill({
        color: "rgba(255, 255, 255, 0.2)",
      }),
      stroke: new Stroke({
        color: "#ffcc33",
        width: 2,
      }),
      image: new CircleStyle({
        radius: 7,
        fill: new Fill({
          color: "#ffcc33",
        }),
      }),
    })
    function calculateCenter(geometry) {
      let center, coordinates, minRadius
      const type = geometry.getType()
      if (type === "Polygon") {
        let x = 0
        let y = 0
        let i = 0
        coordinates = geometry.getCoordinates()[0].slice(1)
        coordinates.forEach(function (coordinate) {
          x += coordinate[0]
          y += coordinate[1]
          i++
        })
        center = [x / i, y / i]
      } else if (type === "LineString") {
        center = geometry.getCoordinateAt(0.5)
        coordinates = geometry.getCoordinates()
      } else {
        center = getCenter(geometry.getExtent())
      }
      let sqDistances
      if (coordinates) {
        sqDistances = coordinates.map(function (coordinate) {
          const dx = coordinate[0] - center[0]
          const dy = coordinate[1] - center[1]
          return dx * dx + dy * dy
        })
        minRadius = Math.sqrt(Math.max.apply(Math, sqDistances)) / 3
      } else {
        minRadius =
          Math.max(
            getWidth(geometry.getExtent()),
            getHeight(geometry.getExtent())
          ) / 3
      }
      return {
        center: center,
        coordinates: coordinates,
        minRadius: minRadius,
        sqDistances: sqDistances,
      }
    }
    const vector = new VectorLayer({
      source: source,
      style: function (feature) {
        const styles = [style]
        const modifyGeometry = feature.get("modifyGeometry")
        const geometry = modifyGeometry
          ? modifyGeometry.geometry
          : feature.getGeometry()
        const result = calculateCenter(geometry)
        const center = result.center
        if (center) {
          styles.push(
            new Style({
              geometry: new Point(center),
              image: new CircleStyle({
                radius: 4,
                fill: new Fill({
                  color: "#ff3333",
                }),
              }),
            })
          )
          const coordinates = result.coordinates
          if (coordinates) {
            const minRadius = result.minRadius
            const sqDistances = result.sqDistances
            const rsq = minRadius * minRadius
            const points = coordinates.filter(function (coordinate, index) {
              return sqDistances[index] > rsq
            })
            styles.push(
              new Style({
                geometry: new MultiPoint(points),
                image: new CircleStyle({
                  radius: 4,
                  fill: new Fill({
                    color: "#33cc33",
                  }),
                }),
              })
            )
          }
        }
        return styles
      },
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 4,
      }),
    })
    const defaultStyle = new Modify({ source: source })
      .getOverlay()
      .getStyleFunction()
    const modify = new Modify({
      source: source,
      condition: function (event) {
        return primaryAction(event) && !platformModifierKeyOnly(event)
      },
      deleteCondition: never,
      insertVertexCondition: never,
      style: function (feature) {
        feature.get("features").forEach(function (modifyFeature) {
          const modifyGeometry = modifyFeature.get("modifyGeometry")
          if (modifyGeometry) {
            const point = feature.getGeometry().getCoordinates()
            let modifyPoint = modifyGeometry.point
            if (!modifyPoint) {
              modifyPoint = point
              modifyGeometry.point = modifyPoint
              modifyGeometry.geometry0 = modifyGeometry.geometry
              const result = calculateCenter(modifyGeometry.geometry0)
              modifyGeometry.center = result.center
              modifyGeometry.minRadius = result.minRadius
            }
            const center = modifyGeometry.center
            const minRadius = modifyGeometry.minRadius
            let dx, dy
            dx = modifyPoint[0] - center[0]
            dy = modifyPoint[1] - center[1]
            const initialRadius = Math.sqrt(dx * dx + dy * dy)
            if (initialRadius > minRadius) {
              const initialAngle = Math.atan2(dy, dx)
              dx = point[0] - center[0]
              dy = point[1] - center[1]
              const currentRadius = Math.sqrt(dx * dx + dy * dy)
              if (currentRadius > 0) {
                const currentAngle = Math.atan2(dy, dx)
                const geometry = modifyGeometry.geometry0.clone()
                geometry.scale(currentRadius / initialRadius, undefined, center)
                geometry.rotate(currentAngle - initialAngle, center)
                modifyGeometry.geometry = geometry
              }
            }
          }
        })
        return defaultStyle(feature)
      },
    })
    modify.on("modifystart", function (event) {
      event.features.forEach(function (feature) {
        feature.set(
          "modifyGeometry",
          { geometry: feature.getGeometry().clone() },
          true
        )
      })
    })
    modify.on("modifyend", function (event) {
      event.features.forEach(function (feature) {
        const modifyGeometry = feature.get("modifyGeometry")
        if (modifyGeometry) {
          feature.setGeometry(modifyGeometry.geometry)
          feature.unset("modifyGeometry", true)
        }
      })
    })
    map.addInteraction(modify)
    map.addInteraction(
      new Translate({
        condition: function (event) {
          return primaryAction(event) && platformModifierKeyOnly(event)
        },
        layers: [vector],
      })
    )
    let draw
    const typeSelect = this.$refs.type
    function addInteractions() {
      draw = new Draw({
        source: source,
        type: typeSelect.value,
      })
      map.addInteraction(draw)
    }
    typeSelect.addEventListener("change", function () {
      map.removeInteraction(draw)
      addInteractions()
    })
    addInteractions()
  },
}
</script>
```

:::
