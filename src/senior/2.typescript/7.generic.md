---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 七.案例7

## 1.LineString 箭头

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { Draw },
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Icon, Stroke, Style },
      proj: { get },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })

    const source = new VectorSource()

    const styleFunction = function (feature) {
      const geometry = feature.getGeometry()
      const styles = [
        // linestring
        new Style({
          stroke: new Stroke({
            color: "#ffcc33",
            width: 2,
          }),
        }),
      ]

      geometry.forEachSegment(function (start, end) {
        const dx = end[0] - start[0]
        const dy = end[1] - start[1]
        const rotation = Math.atan2(dy, dx)
        // arrows
        styles.push(
          new Style({
            geometry: new Point(end),
            image: new Icon({
              src: this.$withBase("/data/arrow.png"),
              anchor: [0.75, 0.5],
              rotateWithView: true,
              rotation: -rotation,
            }),
          })
        )
      })

      return styles
    }
    const vector = new VectorLayer({
      source: source,
      style: styleFunction,
    })

    // Limit multi-world panning to one world east and west of the real world.
    // Geometry coordinates have to be within that range.
    const extent = get("EPSG:3857").getExtent().slice()
    extent[0] += extent[0]
    extent[2] += extent[2]

    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 4,
        extent,
      }),
    })

    map.addInteraction(
      new Draw({
        source: source,
        type: "LineString",
      })
    )
  },
}
</script>
```

:::



## 3.本地化的 OpenStreetMap

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: {
        OSM: { ATTRIBUTION },
      },
    } = ol
    const openCycleMapLayer = new TileLayer({
      source: new ol.source.OSM({
        attributions: [
          'All maps © <a href="https://www.opencyclemap.org/">OpenCycleMap</a>',
          ATTRIBUTION,
        ],
        url:
          "https://{a-c}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png" +
          "?apikey=Your API key from https://www.thunderforest.com/docs/apikeys/ here",
      }),
    })

    const openSeaMapLayer = new TileLayer({
      source: new ol.source.OSM({
        attributions: [
          'All maps © <a href="https://www.openseamap.org/">OpenSeaMap</a>',
          ATTRIBUTION,
        ],
        opaque: false,
        url: "https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png",
      }),
    })

    const map = new Map({
      layers: [openCycleMapLayer, openSeaMapLayer],
      target: this.$refs.map,
      view: new View({
        maxZoom: 18,
        center: [-244780.24508882355, 5986452.183179816],
        zoom: 15,
      }),
    })
  },
}
</script>
```

:::

## 4.放大

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
      proj: { fromLonLat },
      render: { getRenderPixel },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const imagery = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })

    const container = this.$refs.map

    const map = new Map({
      layers: [imagery],
      target: container,
      view: new View({
        center: fromLonLat([-109, 46.5]),
        zoom: 6,
      }),
    })

    let radius = 75
    document.addEventListener("keydown", function (evt) {
      if (evt.which === 38) {
        radius = Math.min(radius + 5, 150)
        map.render()
        evt.preventDefault()
      } else if (evt.which === 40) {
        radius = Math.max(radius - 5, 25)
        map.render()
        evt.preventDefault()
      }
    })

    // get the pixel position with every move
    let mousePosition = null

    container.addEventListener("mousemove", function (event) {
      mousePosition = map.getEventPixel(event)
      map.render()
    })

    container.addEventListener("mouseout", function () {
      mousePosition = null
      map.render()
    })

    // after rendering the layer, show an oversampled version around the pointer
    imagery.on("postrender", function (event) {
      if (mousePosition) {
        const pixel = getRenderPixel(event, mousePosition)
        const offset = getRenderPixel(event, [
          mousePosition[0] + radius,
          mousePosition[1],
        ])
        const half = Math.sqrt(
          Math.pow(offset[0] - pixel[0], 2) + Math.pow(offset[1] - pixel[1], 2)
        )
        const context = event.context
        const centerX = pixel[0]
        const centerY = pixel[1]
        const originX = centerX - half
        const originY = centerY - half
        const size = Math.round(2 * half + 1)
        const sourceData = context.getImageData(
          originX,
          originY,
          size,
          size
        ).data
        const dest = context.createImageData(size, size)
        const destData = dest.data
        for (let j = 0; j < size; ++j) {
          for (let i = 0; i < size; ++i) {
            const dI = i - half
            const dJ = j - half
            const dist = Math.sqrt(dI * dI + dJ * dJ)
            let sourceI = i
            let sourceJ = j
            if (dist < half) {
              sourceI = Math.round(half + dI / 2)
              sourceJ = Math.round(half + dJ / 2)
            }
            const destOffset = (j * size + i) * 4
            const sourceOffset = (sourceJ * size + sourceI) * 4
            destData[destOffset] = sourceData[sourceOffset]
            destData[destOffset + 1] = sourceData[sourceOffset + 1]
            destData[destOffset + 2] = sourceData[sourceOffset + 2]
            destData[destOffset + 3] = sourceData[sourceOffset + 3]
          }
        }
        context.beginPath()
        context.arc(centerX, centerY, half, 0, 2 * Math.PI)
        context.lineWidth = (3 * half) / radius
        context.strokeStyle = "rgba(255,255,255,0.5)"
        context.putImageData(dest, originX, originY)
        context.stroke()
        context.restore()
      }
    })
  },
}
</script>
```

:::

## 5.地图导出

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <a id="export-png" class="btn btn-default"
    ><i class="fa fa-download"></i> Download PNG</a
  >
  <a id="image-download" download="map.png"></a>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Heatmap: HeatmapLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Fill, Style },
      color: { asArray },
    } = ol
    const style = new Style({
      fill: new Fill({
        color: "#eeeeee",
      }),
    })

    const map = new Map({
      layers: [
        new VectorLayer({
          source: new VectorSource({
            url: "https://openlayers.org/data/vector/ecoregions.json",
            format: new GeoJSON(),
          }),
          background: "white",
          style: function (feature) {
            const color = asArray(feature.get("COLOR_NNH") || "#eeeeee")
            color[3] = 0.75
            style.getFill().setColor(color)
            return style
          },
        }),
        new HeatmapLayer({
          source: new VectorSource({
            url: this.$withBase("/data/geojson/world-cities.geojson"),
            format: new GeoJSON(),
          }),
          weight: function (feature) {
            return feature.get("population") / 1e7
          },
          radius: 15,
          blur: 15,
          opacity: 0.75,
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    document
      .getElementById("export-png")
      .addEventListener("click", function () {
        map.once("rendercomplete", function () {
          const mapCanvas = document.createElement("canvas")
          const size = map.getSize()
          mapCanvas.width = size[0]
          mapCanvas.height = size[1]
          const mapContext = mapCanvas.getContext("2d")
          Array.prototype.forEach.call(
            map
              .getViewport()
              .querySelectorAll(".ol-layer canvas, canvas.ol-layer"),
            function (canvas) {
              if (canvas.width > 0) {
                const opacity =
                  canvas.parentNode.style.opacity || canvas.style.opacity
                mapContext.globalAlpha = opacity === "" ? 1 : Number(opacity)

                const backgroundColor = canvas.parentNode.style.backgroundColor
                if (backgroundColor) {
                  mapContext.fillStyle = backgroundColor
                  mapContext.fillRect(0, 0, canvas.width, canvas.height)
                }

                let matrix
                const transform = canvas.style.transform
                if (transform) {
                  // Get the transform parameters from the style's transform matrix
                  matrix = transform
                    .match(/^matrix\(([^\(]*)\)$/)[1]
                    .split(",")
                    .map(Number)
                } else {
                  matrix = [
                    parseFloat(canvas.style.width) / canvas.width,
                    0,
                    0,
                    parseFloat(canvas.style.height) / canvas.height,
                    0,
                    0,
                  ]
                }
                // Apply the transform to the export map context
                CanvasRenderingContext2D.prototype.setTransform.apply(
                  mapContext,
                  matrix
                )
                mapContext.drawImage(canvas, 0, 0)
              }
            }
          )
          mapContext.globalAlpha = 1
          if (navigator.msSaveBlob) {
            // link download attribute does not work on MS browsers
            navigator.msSaveBlob(mapCanvas.msToBlob(), "map.png")
          } else {
            const link = document.getElementById("image-download")
            link.href = mapCanvas.toDataURL()
            link.click()
          }
        })
        map.renderSync()
      })
  },
}
</script>
```

:::
