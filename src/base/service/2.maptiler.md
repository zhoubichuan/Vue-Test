---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 二.maptiler

## 3.变焦受限

视图限制在缩放级别 9 和 13 之间

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
    } = ol

    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const map = new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
              mapkeys.maptiler,
          }),
        }),
      ],
      view: new View({
        center: [-13553864, 5918250],
        zoom: 11,
        minZoom: 9,
        maxZoom: 13,
      }),
    })
  },
}
</script>
```

:::

## 5.拖放

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <label
      ><input type="checkbox" ref="extractstyles" checked />从KML中提取样式
    </label>
  </div>
  <br />
  <div>
    <a ref="download" download></a>
    下载样品
    <button ref="gpx">GPX</button>
    &nbsp;
    <button ref="geojson">GeoJSON</button>
    &nbsp;
    <button ref="igc">IGC</button>
    &nbsp;
    <button ref="kml">KML</button>
    &nbsp;
    <button ref="topojson">TopoJSON</button>
  </div>
  <br />
  <div ref="info">&nbsp;</div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
      format: { GPX, GeoJSON, IGC, KML, TopoJSON },
      interaction: { DragAndDrop },
    } = ol
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const map = new Map({
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
              mapkeys.maptiler,
            maxZoom: 20,
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    const extractStyles = this.$refs.extractstyles
    let dragAndDropInteraction

    function setInteraction() {
      if (dragAndDropInteraction) {
        map.removeInteraction(dragAndDropInteraction)
      }
      dragAndDropInteraction = new DragAndDrop({
        formatConstructors: [
          GPX,
          GeoJSON,
          IGC,
          // use constructed format to set options
          new KML({ extractStyles: extractStyles.checked }),
          TopoJSON,
        ],
      })
      dragAndDropInteraction.on("addfeatures", function (event) {
        const vectorSource = new VectorSource({
          features: event.features,
        })
        map.addLayer(
          new VectorLayer({
            source: vectorSource,
          })
        )
        map.getView().fit(vectorSource.getExtent())
      })
      map.addInteraction(dragAndDropInteraction)
    }
    setInteraction()

    extractStyles.addEventListener("change", setInteraction)

    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          info.push(features[i].get("name"))
        }
        document.getElementById("info").innerHTML = info.join(", ") || "&nbsp"
      } else {
        document.getElementById("info").innerHTML = "&nbsp;"
      }
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })

    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
    const link = this.$refs.download
    function download(fullpath, filename) {
      fetch(fullpath)
        .then(function (response) {
          return response.blob()
        })
        .then(function (blob) {
          if (navigator.msSaveBlob) {
            navigator.msSaveBlob(blob, filename)
          } else {
            link.href = URL.createObjectURL(blob)
            link.download = filename
            link.click()
          }
        })
    }

    this.$refs.gpx.addEventListener("click", function () {
      download(this.$withBase("/data/gpx/fells_loop.gpx"), "fells_loop.gpx")
    })
    this.$refs.geojson.addEventListener("click", function () {
      download(
        this.$withBase("/data/geojson/roads-seoul.geojson"),
        "roads-seoul.geojson"
      )
    })
    this.$refs.igc.addEventListener("click", function () {
      download(this.$withBase("/data/igc/Ulrich-Prinz.igc"), "Ulrich-Prinz.igc")
    })
    this.$refs.kml.addEventListener("click", function () {
      download(this.$withBase("/data/kml/states.kml"), "states.kml")
    })
    this.$refs.topojson.addEventListener("click", function () {
      download(
        this.$withBase("/data/topojson/fr-departments.json"),
        "fr-departments.json"
      )
    })
  },
}
</script>
```

:::

## 1. 拖放图像矢量

使用拖放交互与图像矢量渲染的示例。

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div id="info">&nbsp;</div>
</template>

<script>
export default {
  mounted() {
    let {
      interaction: { DragAndDrop, defaults: defaultInteractions },
      Map,
      View,
      layer: { Tile: TileLayer, VectorImage: VectorImageLayer },
      source: { XYZ, Vector: VectorSource },
      format: { GPX, GeoJSON, IGC, KML, TopoJSON },
    } = ol
    const dragAndDropInteraction = new DragAndDrop({
      formatConstructors: [GPX, GeoJSON, IGC, KML, TopoJSON],
    })

    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const map = new Map({
      interactions: defaultInteractions().extend([dragAndDropInteraction]),
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
              mapkeys.maptiler,
            maxZoom: 20,
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    dragAndDropInteraction.on("addfeatures", function (event) {
      const vectorSource = new VectorSource({
        features: event.features,
      })
      map.addLayer(
        new VectorImageLayer({
          source: vectorSource,
        })
      )
      map.getView().fit(vectorSource.getExtent())
    })

    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          info.push(features[i].get("name"))
        }
        document.getElementById("info").innerHTML = info.join(", ") || "&nbsp"
      } else {
        document.getElementById("info").innerHTML = "&nbsp;"
      }
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })

    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
  },
}
</script>
```

:::

## 4.全屏拖动、旋转和缩放

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
      control: { FullScreen, defaults: defaultControls },
      interaction: { DragRotateAndZoom, defaults: defaultInteractions },
    } = ol
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const map = new Map({
      controls: defaultControls().extend([new FullScreen()]),
      interactions: defaultInteractions().extend([new DragRotateAndZoom()]),
      layers: [
        new TileLayer({
          source: new XYZ({
            attributions: attributions,
            url:
              "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
              mapkeys.maptiler,
            maxZoom: 20,
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [-33519607, 5616436],
        rotation: -Math.PI / 8,
        zoom: 8,
      }),
    })
  },
}
</script>
```

:::

## 3.图像滤镜

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <select id="kernel" name="kernel">
    <option>none</option>
    <option selected>sharpen</option>
    <option value="sharpenless">sharpen less</option>
    <option>blur</option>
    <option>shadow</option>
    <option>emboss</option>
    <option value="edge">edge detect</option>
  </select>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
      proj: { fromLonLat },
    } = ol

    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const imagery = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
          mapkeys.maptiler,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })

    const map = new Map({
      layers: [imagery],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-120, 50]),
        zoom: 6,
      }),
    })

    const kernels = {
      none: [0, 0, 0, 0, 1, 0, 0, 0, 0],
      sharpen: [0, -1, 0, -1, 5, -1, 0, -1, 0],
      sharpenless: [0, -1, 0, -1, 10, -1, 0, -1, 0],
      blur: [1, 1, 1, 1, 1, 1, 1, 1, 1],
      shadow: [1, 2, 1, 0, 1, 0, -1, -2, -1],
      emboss: [-2, 1, 0, -1, 1, 1, 0, 1, 2],
      edge: [0, 1, 0, 1, -4, 1, 0, 1, 0],
    }

    function normalize(kernel) {
      const len = kernel.length
      const normal = new Array(len)
      let i,
        sum = 0
      for (i = 0; i < len; ++i) {
        sum += kernel[i]
      }
      if (sum <= 0) {
        normal.normalized = false
        sum = 1
      } else {
        normal.normalized = true
      }
      for (i = 0; i < len; ++i) {
        normal[i] = kernel[i] / sum
      }
      return normal
    }

    const select = document.getElementById("kernel")
    let selectedKernel = normalize(kernels[select.value])

    /**
     * Update the kernel and re-render on change.
     */
    select.onchange = function () {
      selectedKernel = normalize(kernels[select.value])
      map.render()
    }

    /**
     * Apply a filter on "postrender" events.
     */
    imagery.on("postrender", function (event) {
      convolve(event.context, selectedKernel)
    })

    /**
     * Apply a convolution kernel to canvas.  This works for any size kernel, but
     * performance starts degrading above 3 x 3.
     * @param {CanvasRenderingContext2D} context Canvas 2d context.
     * @param {Array<number>} kernel Kernel.
     */
    function convolve(context, kernel) {
      const canvas = context.canvas
      const width = canvas.width
      const height = canvas.height

      const size = Math.sqrt(kernel.length)
      const half = Math.floor(size / 2)

      const inputData = context.getImageData(0, 0, width, height).data

      const output = context.createImageData(width, height)
      const outputData = output.data

      for (let pixelY = 0; pixelY < height; ++pixelY) {
        const pixelsAbove = pixelY * width
        for (let pixelX = 0; pixelX < width; ++pixelX) {
          let r = 0,
            g = 0,
            b = 0,
            a = 0
          for (let kernelY = 0; kernelY < size; ++kernelY) {
            for (let kernelX = 0; kernelX < size; ++kernelX) {
              const weight = kernel[kernelY * size + kernelX]
              const neighborY = Math.min(
                height - 1,
                Math.max(0, pixelY + kernelY - half)
              )
              const neighborX = Math.min(
                width - 1,
                Math.max(0, pixelX + kernelX - half)
              )
              const inputIndex = (neighborY * width + neighborX) * 4
              r += inputData[inputIndex] * weight
              g += inputData[inputIndex + 1] * weight
              b += inputData[inputIndex + 2] * weight
              a += inputData[inputIndex + 3] * weight
            }
          }
          const outputIndex = (pixelsAbove + pixelX) * 4
          outputData[outputIndex] = r
          outputData[outputIndex + 1] = g
          outputData[outputIndex + 2] = b
          outputData[outputIndex + 3] = kernel.normalized ? a : 255
        }
      }
      context.putImageData(output, 0, 0)
    }
  },
}
</script>
```

:::

## 4.KML

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div id="info">&nbsp;</div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { KML },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
    } = ol
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'
    const raster = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
          mapkeys.maptiler,
        maxZoom: 20,
      }),
    })
    const vector = new VectorLayer({
      source: new VectorSource({
        url: this.$withBase("/data/kml/2012-02-10.kml"),
        format: new KML(),
      }),
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [876970.8463461736, 5859807.853963373],
        projection: "EPSG:3857",
        zoom: 10,
      }),
    })
    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          info.push(features[i].get("name"))
        }
        document.getElementById("info").innerHTML =
          info.join(", ") || "(unknown)"
        map.getTarget().style.cursor = "pointer"
      } else {
        document.getElementById("info").innerHTML = "&nbsp;"
        map.getTarget().style.cursor = ""
      }
    }
    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })
    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
  },
}
</script>
```

:::

## 2.插值

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
    } = ol
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const notInterpolated = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/terrain-rgb/{z}/{x}/{y}.png?key=" +
          mapkeys.maptiler,
        tileSize: 512,
        maxZoom: 12,
        crossOrigin: "",
        interpolate: false,
      }),
    })

    const interpolated = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/terrain-rgb/{z}/{x}/{y}.png?key=" +
          mapkeys.maptiler,
        tileSize: 512,
        maxZoom: 12,
        crossOrigin: "",
      }),
    })

    const view = new View({
      center: [6.893, 45.8295],
      zoom: 16,
      projection: "EPSG:4326",
    })

    const map1 = new Map({
      target: "map1",
      layers: [notInterpolated],
      view: view,
    })

    const map2 = new Map({
      target: "map2",
      layers: [interpolated],
      view: view,
    })

    function getHeight(rgba) {
      return -10000 + (rgba[0] * 256 * 256 + rgba[1] * 256 + rgba[2]) * 0.1
    }

    const info1 = document.getElementById("info1")
    const info2 = document.getElementById("info2")
    const showElevations = function (evt) {
      if (evt.dragging) {
        return
      }
      const notInterpolatedPixel = notInterpolated.getData(evt.pixel)
      info1.innerText = notInterpolatedPixel
        ? getHeight(notInterpolatedPixel).toFixed(1)
        : "-"

      const interpolatedPixel = interpolated.getData(evt.pixel)
      info2.innerText = interpolatedPixel
        ? getHeight(interpolatedPixel).toFixed(1)
        : "-"
    }

    map1.on("pointermove", showElevations)
    map2.on("pointermove", showElevations)
  },
}
</script>
```

:::

## 3.层不透明度

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <label>
    Layer opacity
    <input
      id="opacity-input"
      type="range"
      min="0"
      max="1"
      step="0.01"
      value="1"
    />
    <span id="opacity-output"></span>
  </label>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { WebGLTile: TileLayer },
      source: { XYZ, OSM },
      style: Style,
      proj: { fromLonLat },
    } = ol

    const imagery = new TileLayer({
      className: "ol-layer-imagery",
      source: new XYZ({
        attributions:
          '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ',
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
          mapkeys.maptiler,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })

    const osm = new TileLayer({
      source: new OSM(),
    })

    const map = new Map({
      layers: [imagery, osm],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    const opacityInput = document.getElementById("opacity-input")
    const opacityOutput = document.getElementById("opacity-output")
    function update() {
      const opacity = parseFloat(opacityInput.value)
      osm.setOpacity(opacity)
      opacityOutput.innerText = opacity.toFixed(2)
    }
    opacityInput.addEventListener("input", update)
    opacityInput.addEventListener("change", update)
    update()
  },
}
</script>
```

:::

## 4.Mapbox-gl 层

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Heatmap: HeatmapLayer, Layer },
      source: { Source, Vector: VectorSource },
      proj: { fromLonLat, toLonLat },
    } = ol

    const center = [-98.8, 37.9]

    const mbMap = new mapboxgl.Map({
      style:
        "https://api.maptiler.com/maps/bright/style.json?key=" +
        mapkeys.maptiler,
      attributionControl: false,
      boxZoom: false,
      center: center,
      container: "map",
      doubleClickZoom: false,
      dragPan: false,
      dragRotate: false,
      interactive: false,
      keyboard: false,
      pitchWithRotate: false,
      scrollZoom: false,
      touchZoomRotate: false,
    })

    const mbLayer = new Layer({
      render: function (frameState) {
        const canvas = mbMap.getCanvas()
        const viewState = frameState.viewState

        const visible = mbLayer.getVisible()
        canvas.style.display = visible ? "block" : "none"
        canvas.style.position = "absolute"

        const opacity = mbLayer.getOpacity()
        canvas.style.opacity = opacity

        // adjust view parameters in mapbox
        const rotation = viewState.rotation
        mbMap.jumpTo({
          center: toLonLat(viewState.center),
          zoom: viewState.zoom - 1,
          bearing: (-rotation * 180) / Math.PI,
          animate: false,
        })

        // cancel the scheduled update & trigger synchronous redraw
        // see https://github.com/mapbox/mapbox-gl-js/issues/7893#issue-408992184
        // NOTE: THIS MIGHT BREAK IF UPDATING THE MAPBOX VERSION
        if (mbMap._frame) {
          mbMap._frame.cancel()
          mbMap._frame = null
        }
        mbMap._render()

        return canvas
      },
      source: new Source({
        attributions: [
          '<a href="https://www.maptiler.com/copyright/" target="_blank">© MapTiler</a>',
          '<a href="https://www.openstreetmap.org/copyright" target="_blank">© OpenStreetMap contributors</a>',
        ],
      }),
    })

    const cities = new HeatmapLayer({
      source: new VectorSource({
        url: this.$withBase("/data/geojson/world-cities.geojson"),
        format: new GeoJSON(),
      }),
      weight: function (feature) {
        return feature.get("population") / 1e7
      },
      radius: 15,
      blur: 15,
    })

    const map = new Map({
      target: this.$refs.map,
      view: new View({
        center: fromLonLat(center),
        zoom: 4,
      }),
      layers: [mbLayer, cities],
    })
  },
}
</script>
```

:::

## 5.光栅源

:::demo

```vue
<template>
  <div class="rel">
    <div ref="map" class="map"></div>
    <div id="plot"></div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Image: ImageLayer },
      source: { XYZ, Raster: RasterSource },
    } = ol

    const minVgi = 0
    const maxVgi = 0.5
    const bins = 10
    function vgi(pixel) {
      const r = pixel[0] / 255
      const g = pixel[1] / 255
      const b = pixel[2] / 255
      return (2 * g - r - b) / (2 * g + r + b)
    }
    function summarize(value, counts) {
      const min = counts.min
      const max = counts.max
      const num = counts.values.length
      if (value < min) {
        // do nothing
      } else if (value >= max) {
        counts.values[num - 1] += 1
      } else {
        const index = Math.floor((value - min) / counts.delta)
        counts.values[index] += 1
      }
    }
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const aerial = new XYZ({
      attributions: attributions,
      url:
        "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
        mapkeys.maptiler,
      maxZoom: 20,
      crossOrigin: "",
    })
    const raster = new RasterSource({
      sources: [aerial],
      operation: function (pixels, data) {
        const pixel = pixels[0]
        const value = vgi(pixel)
        summarize(value, data.counts)
        if (value >= data.threshold) {
          pixel[0] = 0
          pixel[1] = 255
          pixel[2] = 0
          pixel[3] = 128
        } else {
          pixel[3] = 0
        }
        return pixel
      },
      lib: {
        vgi: vgi,
        summarize: summarize,
      },
    })
    raster.set("threshold", 0.25)

    function createCounts(min, max, num) {
      const values = new Array(num)
      for (let i = 0; i < num; ++i) {
        values[i] = 0
      }
      return {
        min: min,
        max: max,
        values: values,
        delta: (max - min) / num,
      }
    }
    raster.on("beforeoperations", function (event) {
      event.data.counts = createCounts(minVgi, maxVgi, bins)
      event.data.threshold = raster.get("threshold")
    })
    raster.on("afteroperations", function (event) {
      schedulePlot(event.resolution, event.data.counts, event.data.threshold)
    })
    const map = new Map({
      layers: [
        new TileLayer({
          source: aerial,
        }),
        new ImageLayer({
          source: raster,
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [-9651695, 4937351],
        zoom: 13,
        minZoom: 12,
        maxZoom: 19,
      }),
    })
    let timer = null
    function schedulePlot(resolution, counts, threshold) {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      timer = setTimeout(
        plot.bind(null, resolution, counts, threshold),
        1000 / 60
      )
    }
    const barWidth = 15
    const plotHeight = 150
    const chart = d3
      .select("#plot")
      .append("svg")
      .attr("width", barWidth * bins)
      .attr("height", plotHeight)
    const chartRect = chart.node().getBoundingClientRect()
    const tip = d3.select(document.body).append("div").attr("class", "tip")
    function plot(resolution, counts, threshold) {
      const yScale = d3
        .scaleLinear()
        .domain([0, d3.max(counts.values)])
        .range([0, plotHeight])
      const bar = chart.selectAll("rect").data(counts.values)
      bar.enter().append("rect")
      bar
        .attr("class", function (count, index) {
          const value = counts.min + index * counts.delta
          return "bar" + (value >= threshold ? " selected" : "")
        })
        .attr("width", barWidth - 2)
      bar
        .transition()
        .attr("transform", function (value, index) {
          return (
            "translate(" +
            index * barWidth +
            ", " +
            (plotHeight - yScale(value)) +
            ")"
          )
        })
        .attr("height", yScale)
      bar.on("mousemove", function () {
        const index = bar.nodes().indexOf(this)
        const threshold = counts.min + index * counts.delta
        if (raster.get("threshold") !== threshold) {
          raster.set("threshold", threshold)
          raster.changed()
        }
      })
      bar.on("mouseover", function (event) {
        const index = bar.nodes().indexOf(this)
        let area = 0
        for (let i = counts.values.length - 1; i >= index; --i) {
          area += resolution * resolution * counts.values[i]
        }
        tip.html(message(counts.min + index * counts.delta, area))
        tip.style("display", "block")
        tip
          .transition()
          .style(
            "left",
            chartRect.left + index * barWidth + barWidth / 2 + "px"
          )
          .style("top", event.y - 60 + "px")
          .style("opacity", 1)
      })
      bar.on("mouseout", function () {
        tip
          .transition()
          .style("opacity", 0)
          .on("end", function () {
            tip.style("display", "none")
          })
      })
    }
    function message(value, area) {
      const acres = (area / 4046.86)
        .toFixed(0)
        .replace(/\B(?=(\d{3})+(?!\d))/g, ",")
      return acres + " acres at<br>" + value.toFixed(2) + " VGI or above"
    }
  },
}
</script>
```

:::

## 1.区域增长

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <label class="input-group">
      Threshold:
      <input id="threshold" type="range" min="1" max="50" value="20" />
      <span id="threshold-value"></span>
    </label>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Raster: RasterSource },
      proj: { fromLonLat },
    } = ol
    function growRegion(inputs, data) {
      const image = inputs[0]
      let seed = data.pixel
      const delta = parseInt(data.delta)
      if (!seed) {
        return image
      }
      seed = seed.map(Math.round)
      const width = image.width
      const height = image.height
      const inputData = image.data
      const outputData = new Uint8ClampedArray(inputData)
      const seedIdx = (seed[1] * width + seed[0]) * 4
      const seedR = inputData[seedIdx]
      const seedG = inputData[seedIdx + 1]
      const seedB = inputData[seedIdx + 2]
      let edge = [seed]
      while (edge.length) {
        const newedge = []
        for (let i = 0, ii = edge.length; i < ii; i++) {
          const next = next4Edges(edge[i])
          for (let j = 0, jj = next.length; j < jj; j++) {
            const s = next[j][0]
            const t = next[j][1]
            if (s >= 0 && s < width && t >= 0 && t < height) {
              const ci = (t * width + s) * 4
              const cr = inputData[ci]
              const cg = inputData[ci + 1]
              const cb = inputData[ci + 2]
              const ca = inputData[ci + 3]
              if (ca === 0) {
                continue
              }
              if (
                Math.abs(seedR - cr) < delta &&
                Math.abs(seedG - cg) < delta &&
                Math.abs(seedB - cb) < delta
              ) {
                outputData[ci] = 255
                outputData[ci + 1] = 0
                outputData[ci + 2] = 0
                outputData[ci + 3] = 255
                newedge.push([s, t])
              }
              inputData[ci + 3] = 0
            }
          }
        }
        edge = newedge
      }
      return { data: outputData, width: width, height: height }
    }
    function next4Edges(edge) {
      const x = edge[0]
      const y = edge[1]
      return [
        [x + 1, y],
        [x - 1, y],
        [x, y + 1],
        [x, y - 1],
      ]
    }
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'
    const imagery = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
          mapkeys.maptiler,
        maxZoom: 20,
        crossOrigin: "",
      }),
    })
    const raster = new RasterSource({
      sources: [imagery.getSource()],
      operationType: "image",
      operation: growRegion,
      lib: {
        next4Edges: next4Edges,
      },
    })
    const rasterImage = new ImageLayer({
      opacity: 0.7,
      source: raster,
    })
    const map = new Map({
      layers: [imagery, rasterImage],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([-119.07, 47.65]),
        zoom: 11,
      }),
    })
    let coordinate
    map.on("click", function (event) {
      coordinate = event.coordinate
      raster.changed()
    })
    const thresholdControl = document.getElementById("threshold")
    raster.on("beforeoperations", function (event) {
      const data = event.data
      data.delta = thresholdControl.value
      if (coordinate) {
        data.pixel = map.getPixelFromCoordinate(coordinate)
      }
    })
    function updateControlValue() {
      document.getElementById("threshold-value").innerText =
        thresholdControl.value
    }
    updateControlValue()

    const listener = function () {
      updateControlValue()
      raster.changed()
    }
    thresholdControl.addEventListener("input", listener)
    thresholdControl.addEventListener("change", listener)
  },
}
</script>
```

:::


## 3.共享视图

:::demo

```vue
<template>
  <div class="wrapper">
    <div class="half">
      <h4>Road</h4>
      <div id="roadMap" class="map"></div>
    </div>
    <div class="half">
      <h4>Aerial</h4>
      <div id="aerialMap" class="map"></div>
    </div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { XYZ },
    } = ol
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const roadLayer = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/maps/streets/{z}/{x}/{y}.png?key=" +
          mapkeys.maptiler,
        tileSize: 512,
        maxZoom: 22,
      }),
    })

    const aerialLayer = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" +
          mapkeys.maptiler,
        maxZoom: 20,
      }),
    })

    const view = new View({
      center: [-6655.5402445057125, 6709968.258934638],
      zoom: 13,
    })

    const map1 = new Map({
      target: "roadMap",
      layers: [roadLayer],
      view: view,
    })

    const map2 = new Map({
      target: "aerialMap",
      layers: [aerialLayer],
      view: view,
    })
  },
}
</script>
```

:::
