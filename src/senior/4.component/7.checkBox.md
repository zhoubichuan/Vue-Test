---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 七.checkbox

## 1.在屏幕外画布中渲染的矢量瓷砖

:::demo

```vue
<template>
  <div ref="map" class="map">
    <pre id="info" class="info" />
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Layer },
      source: { Source },
      control: { FullScreen },
    } = ol
    // import stringify from 'json-stringify-safe';
    const worker = new Worker("./worker.js", { type: "module" })

    let container,
      transformContainer,
      canvas,
      rendering,
      workerFrameState,
      mainThreadFrameState

    // Transform the container to account for the differnece between the (newer)
    // main thread frameState and the (older) worker frameState
    function updateContainerTransform() {
      if (workerFrameState) {
        const viewState = mainThreadFrameState.viewState
        const renderedViewState = workerFrameState.viewState
        const center = viewState.center
        const resolution = viewState.resolution
        const rotation = viewState.rotation
        const renderedCenter = renderedViewState.center
        const renderedResolution = renderedViewState.resolution
        const renderedRotation = renderedViewState.rotation
        const transform = create()
        // Skip the extra transform for rotated views, because it will not work
        // correctly in that case
        if (!rotation) {
          compose(
            transform,
            (renderedCenter[0] - center[0]) / resolution,
            (center[1] - renderedCenter[1]) / resolution,
            renderedResolution / resolution,
            renderedResolution / resolution,
            rotation - renderedRotation,
            0,
            0
          )
        }
        transformContainer.style.transform = toTransformString(transform)
      }
    }

    const map = new Map({
      layers: [
        new Layer({
          render: function (frameState) {
            if (!container) {
              container = document.createElement("div")
              container.style.position = "absolute"
              container.style.width = "100%"
              container.style.height = "100%"
              transformContainer = document.createElement("div")
              transformContainer.style.position = "absolute"
              transformContainer.style.width = "100%"
              transformContainer.style.height = "100%"
              container.appendChild(transformContainer)
              canvas = document.createElement("canvas")
              canvas.style.position = "absolute"
              canvas.style.left = "0"
              canvas.style.transformOrigin = "top left"
              transformContainer.appendChild(canvas)
            }
            mainThreadFrameState = frameState
            updateContainerTransform()
            if (!rendering) {
              rendering = true
              worker.postMessage({
                action: "render",
                frameState: JSON.parse(stringify(frameState)),
              })
            } else {
              frameState.animate = true
            }
            return container
          },
          source: new Source({
            attributions: [
              '<a href="https://www.maptiler.com/copyright/" target="_blank">© MapTiler</a>',
              '<a href="https://www.openstreetmap.org/copyright" target="_blank">© OpenStreetMap contributors</a>',
            ],
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        resolutions: createXYZ({ tileSize: 512 }).getResolutions(),
        center: [0, 0],
        zoom: 2,
      }),
    })
    map.addControl(new FullScreen())

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      worker.postMessage({
        action: "requestFeatures",
        pixel: pixel,
      })
    })

    // Worker messaging and actions
    worker.addEventListener("message", (message) => {
      if (message.data.action === "loadImage") {
        // Image loader for ol-mapbox-style
        const image = new Image()
        image.crossOrigin = "anonymous"
        image.addEventListener("load", function () {
          createImageBitmap(image, 0, 0, image.width, image.height).then(
            (imageBitmap) => {
              worker.postMessage(
                {
                  action: "imageLoaded",
                  image: imageBitmap,
                  src: message.data.src,
                },
                [imageBitmap]
              )
            }
          )
        })
        image.src = message.data.src
      } else if (message.data.action === "getFeatures") {
        showInfo(message.data.features)
      } else if (message.data.action === "requestRender") {
        // Worker requested a new render frame
        map.render()
      } else if (canvas && message.data.action === "rendered") {
        // Worker provies a new render frame
        requestAnimationFrame(function () {
          const imageData = message.data.imageData
          canvas.width = imageData.width
          canvas.height = imageData.height
          canvas.getContext("2d").drawImage(imageData, 0, 0)
          canvas.style.transform = message.data.transform
          workerFrameState = message.data.frameState
          updateContainerTransform()
        })
        rendering = false
      }
    })

    const info = document.getElementById("info")
    function showInfo(propertiesFromFeatures) {
      if (propertiesFromFeatures.length == 0) {
        info.innerText = ""
        info.style.opacity = 0
        return
      }
      const properties = propertiesFromFeatures.map((e) =>
        Object.keys(e)
          .filter((key) => !key.includes(":"))
          .reduce(
            (newObj, currKey) => ((newObj[currKey] = e[currKey]), newObj),
            {}
          )
      )
      info.innerText = JSON.stringify(properties, null, 2)
      info.style.opacity = 1
    }
  },
}
</script>
```

:::

## 2.查看动画

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <button id="rotate-left" title="Rotate clockwise">↻</button>
  <button id="rotate-right" title="Rotate counterclockwise">↺</button>
  <button id="pan-to-london">Pan to London</button>
  <button id="elastic-to-moscow">Elastic to Moscow</button>
  <button id="bounce-to-istanbul">Bounce to Istanbul</button>
  <button id="spin-to-rome">Spin to Rome</button>
  <button id="fly-to-bern">Fly to Bern</button>
  <button id="rotate-around-rome">Rotate around Rome</button>
  <button id="tour">Take a tour</button>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      easing: { easeIn, easeOut },
      proj: { fromLonLat },
    } = ol
    const london = fromLonLat([-0.12755, 51.507222])
    const moscow = fromLonLat([37.6178, 55.7517])
    const istanbul = fromLonLat([28.9744, 41.0128])
    const rome = fromLonLat([12.5, 41.9])
    const bern = fromLonLat([7.4458, 46.95])

    const view = new View({
      center: istanbul,
      zoom: 6,
    })

    const map = new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          preload: 4,
          source: new OSM(),
        }),
      ],
      view: view,
    })

    // A bounce easing method (from https://github.com/DmitryBaranovskiy/raphael).
    function bounce(t) {
      const s = 7.5625
      const p = 2.75
      let l
      if (t < 1 / p) {
        l = s * t * t
      } else {
        if (t < 2 / p) {
          t -= 1.5 / p
          l = s * t * t + 0.75
        } else {
          if (t < 2.5 / p) {
            t -= 2.25 / p
            l = s * t * t + 0.9375
          } else {
            t -= 2.625 / p
            l = s * t * t + 0.984375
          }
        }
      }
      return l
    }

    // An elastic easing method (from https://github.com/DmitryBaranovskiy/raphael).
    function elastic(t) {
      return (
        Math.pow(2, -10 * t) * Math.sin(((t - 0.075) * (2 * Math.PI)) / 0.3) + 1
      )
    }

    function onClick(id, callback) {
      document.getElementById(id).addEventListener("click", callback)
    }

    onClick("rotate-left", function () {
      view.animate({
        rotation: view.getRotation() + Math.PI / 2,
      })
    })

    onClick("rotate-right", function () {
      view.animate({
        rotation: view.getRotation() - Math.PI / 2,
      })
    })

    onClick("rotate-around-rome", function () {
      // Rotation animation takes the shortest arc, so animate in two parts
      const rotation = view.getRotation()
      view.animate(
        {
          rotation: rotation + Math.PI,
          anchor: rome,
          easing: easeIn,
        },
        {
          rotation: rotation + 2 * Math.PI,
          anchor: rome,
          easing: easeOut,
        }
      )
    })

    onClick("pan-to-london", function () {
      view.animate({
        center: london,
        duration: 2000,
      })
    })

    onClick("elastic-to-moscow", function () {
      view.animate({
        center: moscow,
        duration: 2000,
        easing: elastic,
      })
    })

    onClick("bounce-to-istanbul", function () {
      view.animate({
        center: istanbul,
        duration: 2000,
        easing: bounce,
      })
    })

    onClick("spin-to-rome", function () {
      // Rotation animation takes the shortest arc, so animate in two parts
      const center = view.getCenter()
      view.animate(
        {
          center: [
            center[0] + (rome[0] - center[0]) / 2,
            center[1] + (rome[1] - center[1]) / 2,
          ],
          rotation: Math.PI,
          easing: easeIn,
        },
        {
          center: rome,
          rotation: 2 * Math.PI,
          easing: easeOut,
        }
      )
    })

    function flyTo(location, done) {
      const duration = 2000
      const zoom = view.getZoom()
      let parts = 2
      let called = false
      function callback(complete) {
        --parts
        if (called) {
          return
        }
        if (parts === 0 || !complete) {
          called = true
          done(complete)
        }
      }
      view.animate(
        {
          center: location,
          duration: duration,
        },
        callback
      )
      view.animate(
        {
          zoom: zoom - 1,
          duration: duration / 2,
        },
        {
          zoom: zoom,
          duration: duration / 2,
        },
        callback
      )
    }

    onClick("fly-to-bern", function () {
      flyTo(bern, function () {})
    })

    function tour() {
      const locations = [london, bern, rome, moscow, istanbul]
      let index = -1
      function next(more) {
        if (more) {
          ++index
          if (index < locations.length) {
            const delay = index === 0 ? 0 : 750
            setTimeout(function () {
              flyTo(locations[index], next)
            }, delay)
          } else {
            alert("Tour complete")
          }
        } else {
          alert("Tour cancelled")
        }
      }
      next(true)
    }

    onClick("tour", tour)
  },
}
</script>
```

:::

## 3.查看 Min-Zoom

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
    } = ol

    const viewport = document.getElementById("map")

    function getMinZoom() {
      const width = viewport.clientWidth
      return Math.ceil(Math.LOG2E * Math.log(width / 256))
    }

    const initialZoom = getMinZoom()

    const view = new View({
      center: [0, 0],
      minZoom: initialZoom,
      zoom: initialZoom,
    })

    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: view,
    })

    window.addEventListener("resize", function () {
      const minZoom = getMinZoom()
      if (minZoom !== view.getMinZoom()) {
        view.setMinZoom(minZoom)
      }
    })
  },
}
</script>
```

:::

## 4.查看填充物

:::demo

```vue
<template>
  <div class="mapcontainer">
    <div ref="map" class="map"></div>
    <div class="padding-top"></div>
    <div class="padding-left"></div>
    <div class="padding-right"></div>
    <div class="padding-bottom"></div>
  </div>
  <button id="zoomtoswitzerland">Zoom to Switzerland</button>
  <button id="centerlausanne">Center on Lausanne</button>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: {Circle as CircleStyle, Fill, Stroke, Style},
      proj: { fromLonLat },
    } = ol
    const source = new VectorSource({
  url: 'data/geojson/switzerland.geojson',
  format: new GeoJSON(),
});
const style = new Style({
  fill: new Fill({
    color: 'rgba(255, 255, 255, 0.6)',
  }),
  stroke: new Stroke({
    color: '#319FD3',
    width: 1,
  }),
  image: new CircleStyle({
    radius: 5,
    fill: new Fill({
      color: 'rgba(255, 255, 255, 0.6)',
    }),
    stroke: new Stroke({
      color: '#319FD3',
      width: 1,
    }),
  }),
});
const vectorLayer = new VectorLayer({
  source: source,
  style: style,
});
const view = new View({
  center: fromLonLat([6.6339863, 46.5193823]),
  padding: [170, 50, 30, 150],
  zoom: 6,
});
const map = new Map({
  layers: [
    new TileLayer({
      source: new OSM(),
    }),
    vectorLayer,
  ],
  target: this.$refs.map,
  view: view,
});

vectorLayer.getSource().on('featuresloadend', function () {
  const zoomtoswitzerland = document.getElementById('zoomtoswitzerland');
  zoomtoswitzerland.addEventListener(
    'click',
    function () {
      const feature = source.getFeatures()[0];
      const polygon = feature.getGeometry();
      view.fit(polygon);
    },
    false
  );

  const centerlausanne = document.getElementById('centerlausanne');
  centerlausanne.addEventListener(
    'click',
    function () {
      const feature = source.getFeatures()[1];
      const point = feature.getGeometry();
      view.setCenter(point.getCoordinates());
    },
    false
  );
});
  },
}
</script>
```

:::

## 5.查看轮岗

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
    } = ol
    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [14200000, 4130000],
        rotation: Math.PI / 6,
        zoom: 10,
      }),
    })
  },
}
</script>
```

:::
