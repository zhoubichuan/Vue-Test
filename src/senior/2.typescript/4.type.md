---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 四.案例4

## 1.立即渲染（地理）

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      geom: { Point },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { Stamen },
      style: { Circle, Fill, Style },
      proj: { useGeographic },
      render: { getVectorContext },
      easing: { upAndDown },
    } = ol
    useGeographic()
    const layer = new TileLayer({
      source: new Stamen({
        layer: "toner",
      }),
    })
    const map = new Map({
      layers: [layer],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })
    const image = new Circle({
      radius: 8,
      fill: new Fill({ color: "rgb(255, 153, 0)" }),
    })
    const style = new Style({
      image: image,
    })
    const n = 1000
    const geometries = new Array(n)
    for (let i = 0; i < n; ++i) {
      const lon = 360 * Math.random() - 180
      const lat = 180 * Math.random() - 90
      geometries[i] = new Point([lon, lat])
    }
    layer.on("postrender", function (event) {
      const vectorContext = getVectorContext(event)
      for (let i = 0; i < n; ++i) {
        const importance = upAndDown(Math.pow((n - i) / n, 0.15))
        if (importance < 0.1) {
          continue
        }
        image.setOpacity(importance)
        image.setScale(importance)
        vectorContext.setStyle(style)
        vectorContext.drawGeometry(geometries[i])
      }
      const lon = 360 * Math.random() - 180
      const lat = 180 * Math.random() - 90
      geometries.push(new Point([lon, lat]))
      geometries.shift()
      map.render()
    })
  },
}
</script>
```

:::

## 2.插值

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Circle },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: Style,
      proj: { fromLonLat },
    } = ol
  },
}
</script>
```

:::

## 3.JSTS 集成

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      geom: {
        LinearRing,
        LineString,
        MultiLineString,
        MultiPoint,
        MultiPolygon,
        Point,
        Polygon,
      },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      proj: { fromLonLat },
    } = ol
    const source = new VectorSource()
    fetch(this.$withBase("/data/geojson/roads-seoul.geojson"))
      .then(function (response) {
        return response.json()
      }).then(function (json) {
        const format = new GeoJSON()
        const features = format.readFeatures(json, {
          featureProjection: "EPSG:3857",
        })
        const parser = new jsts.io.OL3Parser()
        parser.inject(
          Point,
          LineString,
          LinearRing,
          Polygon,
          MultiPoint,
          MultiLineString,
          MultiPolygon
        )
        for (let i = 0; i < features.length; i++) {
          const feature = features[i]
          const jstsGeom = parser.read(feature.getGeometry())
          const buffered = jstsGeom.buffer(40)
          feature.setGeometry(parser.write(buffered))
        }
        source.addFeatures(features)
      })
    const vectorLayer = new VectorLayer({
      source: source,
    })
    const rasterLayer = new TileLayer({
      source: new OSM(),
    })
    const map = new Map({
      layers: [rasterLayer, vectorLayer],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([126.979293, 37.528787]),
        zoom: 15,
      }),
    })
  },
}
</script>
```

:::

## 4.KML

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div id="info">&nbsp;</div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { KML },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { XYZ, Vector: VectorSource },
    } = ol
    const key = "pk.eyJ1IjoiemhvdWJpY2h1YW4iLCJhIjoiY2wyZGRleThpMHk5YjNkcDkzMWNveXB0YSJ9.L0LaQDinn6bNDLgQQmcuxQ"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'
    const raster = new TileLayer({
      source: new XYZ({
        attributions: attributions,
        url:
          "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
        maxZoom: 20,
      }),
    })
    const vector = new VectorLayer({
      source: new VectorSource({
        url: this.$withBase("/data/kml/2012-02-10.kml"),
        format: new KML(),
      }),
    })
    const map = new Map({
      layers: [raster, vector],
      target: this.$refs.map,
      view: new View({
        center: [876970.8463461736, 5859807.853963373],
        projection: "EPSG:3857",
        zoom: 10,
      }),
    })
    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          info.push(features[i].get("name"))
        }
        document.getElementById("info").innerHTML =
          info.join(", ") || "(unknown)"
        map.getTarget().style.cursor = "pointer"
      } else {
        document.getElementById("info").innerHTML = "&nbsp;"
        map.getTarget().style.cursor = ""
      }
    }
    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })
    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })
  },
}
</script>
```

:::

## 5.分层裁剪

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
    } = ol

    const osm = new TileLayer({
      source: new OSM(),
    })

    const map = new Map({
      layers: [osm],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    osm.on("prerender", function (event) {
      const ctx = event.context
      const matrix = event.inversePixelTransform
      const canvasPixelRatio = Math.sqrt(
        matrix[0] * matrix[0] + matrix[1] * matrix[1]
      )
      const canvasRotation = -Math.atan2(matrix[1], matrix[0])
      ctx.save()
      ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2)
      ctx.rotate(-canvasRotation)
      ctx.scale(3 * canvasPixelRatio, 3 * canvasPixelRatio)
      ctx.translate(-75, -80)
      ctx.beginPath()
      ctx.moveTo(75, 40)
      ctx.bezierCurveTo(75, 37, 70, 25, 50, 25)
      ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5)
      ctx.bezierCurveTo(20, 80, 40, 102, 75, 120)
      ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5)
      ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25)
      ctx.bezierCurveTo(85, 25, 75, 37, 75, 40)
      ctx.clip()
      ctx.translate(75, 80)
      ctx.scale(1 / 3 / canvasPixelRatio, 1 / 3 / canvasPixelRatio)
      ctx.rotate(canvasRotation)
      ctx.translate(-ctx.canvas.width / 2, -ctx.canvas.height / 2)
    })

    osm.on("postrender", function (event) {
      const ctx = event.context
      ctx.restore()
    })
  },
}
</script>
```

:::
