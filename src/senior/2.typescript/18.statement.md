---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十八.案例 18

## 1.阴影浮雕

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <table class="controls">
    <tr>
      <td><label for="vert">vertical exaggeration:</label></td>
      <td><input id="vert" type="range" min="1" max="5" value="1" /></td>
      <td><span id="vertOut"></span> x</td>
    </tr>
    <tr>
      <td><label for="sunEl">sun elevation:</label></td>
      <td><input id="sunEl" type="range" min="0" max="90" value="45" /></td>
      <td><span id="sunElOut"></span> °</td>
    </tr>
    <tr>
      <td><label for="sunAz">sun azimuth:</label></td>
      <td><input id="sunAz" type="range" min="0" max="360" value="45" /></td>
      <td><span id="sunAzOut"></span> °</td>
    </tr>
  </table>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Image: ImageLayer },
      source: { OSM, Raster, XYZ },
    } = ol
    function shade(inputs, data) {
      const elevationImage = inputs[0]
      const width = elevationImage.width
      const height = elevationImage.height
      const elevationData = elevationImage.data
      const shadeData = new Uint8ClampedArray(elevationData.length)
      const dp = data.resolution * 2
      const maxX = width - 1
      const maxY = height - 1
      const pixel = [0, 0, 0, 0]
      const twoPi = 2 * Math.PI
      const halfPi = Math.PI / 2
      const sunEl = (Math.PI * data.sunEl) / 180
      const sunAz = (Math.PI * data.sunAz) / 180
      const cosSunEl = Math.cos(sunEl)
      const sinSunEl = Math.sin(sunEl)
      let pixelX,
        pixelY,
        x0,
        x1,
        y0,
        y1,
        offset,
        z0,
        z1,
        dzdx,
        dzdy,
        slope,
        aspect,
        cosIncidence,
        scaled
      function calculateElevation(pixel) {
        return pixel[0] + pixel[1] * 2 + pixel[2] * 3
      }
      for (pixelY = 0; pixelY <= maxY; ++pixelY) {
        y0 = pixelY === 0 ? 0 : pixelY - 1
        y1 = pixelY === maxY ? maxY : pixelY + 1
        for (pixelX = 0; pixelX <= maxX; ++pixelX) {
          x0 = pixelX === 0 ? 0 : pixelX - 1
          x1 = pixelX === maxX ? maxX : pixelX + 1
          offset = (pixelY * width + x0) * 4
          pixel[0] = elevationData[offset]
          pixel[1] = elevationData[offset + 1]
          pixel[2] = elevationData[offset + 2]
          pixel[3] = elevationData[offset + 3]
          z0 = data.vert * calculateElevation(pixel)
          offset = (pixelY * width + x1) * 4
          pixel[0] = elevationData[offset]
          pixel[1] = elevationData[offset + 1]
          pixel[2] = elevationData[offset + 2]
          pixel[3] = elevationData[offset + 3]
          z1 = data.vert * calculateElevation(pixel)
          dzdx = (z1 - z0) / dp
          offset = (y0 * width + pixelX) * 4
          pixel[0] = elevationData[offset]
          pixel[1] = elevationData[offset + 1]
          pixel[2] = elevationData[offset + 2]
          pixel[3] = elevationData[offset + 3]
          z0 = data.vert * calculateElevation(pixel)
          offset = (y1 * width + pixelX) * 4
          pixel[0] = elevationData[offset]
          pixel[1] = elevationData[offset + 1]
          pixel[2] = elevationData[offset + 2]
          pixel[3] = elevationData[offset + 3]
          z1 = data.vert * calculateElevation(pixel)
          dzdy = (z1 - z0) / dp
          slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy))
          aspect = Math.atan2(dzdy, -dzdx)
          if (aspect < 0) {
            aspect = halfPi - aspect
          } else if (aspect > halfPi) {
            aspect = twoPi - aspect + halfPi
          } else {
            aspect = halfPi - aspect
          }
          cosIncidence =
            sinSunEl * Math.cos(slope) +
            cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect)
          offset = (pixelY * width + pixelX) * 4
          scaled = 255 * cosIncidence
          shadeData[offset] = scaled
          shadeData[offset + 1] = scaled
          shadeData[offset + 2] = scaled
          shadeData[offset + 3] = elevationData[offset + 3]
        }
      }
      return { data: shadeData, width: width, height: height }
    }

    const elevation = new XYZ({
      url: "https://{a-d}.tiles.mapbox.com/v3/aj.sf-dem/{z}/{x}/{y}.png",
      crossOrigin: "anonymous",
    })
    const raster = new Raster({
      sources: [elevation],
      operationType: "image",
      operation: shade,
    })
    const map = new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
        new ImageLayer({
          opacity: 0.3,
          source: raster,
        }),
      ],
      view: new View({
        extent: [-13675026, 4439648, -13580856, 4580292],
        center: [-13615645, 4497969],
        minZoom: 10,
        maxZoom: 16,
        zoom: 13,
      }),
    })
    const controlIds = ["vert", "sunEl", "sunAz"]
    const controls = {}
    controlIds.forEach(function (id) {
      const control = document.getElementById(id)
      const output = document.getElementById(id + "Out")
      const listener = function () {
        output.innerText = control.value
        raster.changed()
      }
      control.addEventListener("input", listener)
      control.addEventListener("change", listener)
      output.innerText = control.value
      controls[id] = control
    })
    raster.on("beforeoperations", function (event) {
      const data = event.data
      data.resolution = event.resolution
      for (const id in controls) {
        data[id] = Number(controls[id].value)
      }
    })
  },
}
</script>
```

:::

## 2.阴影浮雕（使用 WebGL）

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <table class="controls">
    <tr>
      <td><label for="vert">vertical exaggeration:</label></td>
      <td><input id="vert" type="range" min="1" max="5" value="1" /></td>
      <td><span id="vertOut"></span> x</td>
    </tr>
    <tr>
      <td><label for="sunEl">sun elevation:</label></td>
      <td><input id="sunEl" type="range" min="0" max="90" value="45" /></td>
      <td><span id="sunElOut"></span> °</td>
    </tr>
    <tr>
      <td><label for="sunAz">sun azimuth:</label></td>
      <td><input id="sunAz" type="range" min="0" max="360" value="45" /></td>
      <td><span id="sunAzOut"></span> °</td>
    </tr>
  </table>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { WebGLTile: TileLayer },
      source: { OSM, XYZ },
    } = ol
    const variables = {}

    function elevation(xOffset, yOffset) {
      return [
        "+",
        ["*", 256, ["band", 1, xOffset, yOffset]],
        [
          "+",
          ["*", 2 * 256, ["band", 2, xOffset, yOffset]],
          ["*", 3 * 256, ["band", 3, xOffset, yOffset]],
        ],
      ]
    }

    const dp = ["*", 2, ["resolution"]]
    const z0x = ["*", ["var", "vert"], elevation(-1, 0)]
    const z1x = ["*", ["var", "vert"], elevation(1, 0)]
    const dzdx = ["/", ["-", z1x, z0x], dp]
    const z0y = ["*", ["var", "vert"], elevation(0, -1)]
    const z1y = ["*", ["var", "vert"], elevation(0, 1)]
    const dzdy = ["/", ["-", z1y, z0y], dp]
    const slope = ["atan", ["^", ["+", ["^", dzdx, 2], ["^", dzdy, 2]], 0.5]]
    const aspect = ["clamp", ["atan", ["-", 0, dzdx], dzdy], -Math.PI, Math.PI]
    const sunEl = ["*", Math.PI / 180, ["var", "sunEl"]]
    const sunAz = ["*", Math.PI / 180, ["var", "sunAz"]]

    const cosIncidence = [
      "+",
      ["*", ["sin", sunEl], ["cos", slope]],
      [
        "*",
        ["*", ["cos", sunEl], ["sin", slope]],
        ["cos", ["-", sunAz, aspect]],
      ],
    ]
    const scaled = ["*", 255, cosIncidence]

    const shadedRelief = new TileLayer({
      opacity: 0.3,
      source: new XYZ({
        url: "https://{a-d}.tiles.mapbox.com/v3/aj.sf-dem/{z}/{x}/{y}.png",
      }),
      style: {
        variables: variables,
        color: ["color", scaled, scaled, scaled],
      },
    })

    const controlIds = ["vert", "sunEl", "sunAz"]
    controlIds.forEach(function (id) {
      const control = document.getElementById(id)
      const output = document.getElementById(id + "Out")
      function updateValues() {
        output.innerText = control.value
        variables[id] = Number(control.value)
      }
      updateValues()
      const listener = function () {
        updateValues()
        shadedRelief.updateStyleVariables(variables)
      }
      control.addEventListener("input", listener)
      control.addEventListener("change", listener)
    })

    const map = new Map({
      target: this.$refs.map,
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
        shadedRelief,
      ],
      view: new View({
        extent: [-13675026, 4439648, -13580856, 4580292],
        center: [-13615645, 4497969],
        minZoom: 10,
        maxZoom: 16,
        zoom: 13,
      }),
    })
  },
}
</script>
```

:::

## 5.单个图像 WMS

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Image: ImageLayer },
      source: { OSM, ImageWMS },
    } = ol
    const layers = [
      new TileLayer({
        source: new OSM(),
      }),
      new ImageLayer({
        extent: [-13884991, 2870341, -7455066, 6338219],
        source: new ImageWMS({
          url: "https://ahocevar.com/geoserver/wms",
          params: { LAYERS: "topp:states" },
          ratio: 1,
          serverType: "geoserver",
        }),
      }),
    ]
    const map = new Map({
      layers: layers,
      target: this.$refs.map,
      view: new View({
        center: [-10997148, 4569099],
        zoom: 4,
      }),
    })
  },
}
</script>
```

:::
