---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十四.案例14

## 1.预加载瓷砖

:::demo

```vue
<template>
  <div ref="map1" class="map"></div>
  <div ref="map2" class="map" style="margin-top:10px"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { BingMaps },
    } = ol
    const view = new View({
      center: [-4808600, -2620936],
      zoom: 8,
    })

    const map1 = new Map({
      layers: [
        new TileLayer({
          preload: Infinity,
          source: new BingMaps({
            key: "Your Bing Maps Key from https://www.bingmapsportal.com/ here",
            imagerySet: "Aerial",
          }),
        }),
      ],
      target: this.$refs.map1,
      view: view,
    })

    const map2 = new Map({
      layers: [
        new TileLayer({
          preload: 0, // default value
          source: new BingMaps({
            key: "Your Bing Maps Key from https://www.bingmapsportal.com/ here",
            imagerySet: "AerialWithLabelsOnDemand",
          }),
        }),
      ],
      target: this.$refs.map2,
      view: view,
    })
  },
}
</script>
```

:::

## 2.打印到缩放示例

:::demo

```vue
<template>
  <div class="wrapper">
    <div ref="map" class="map"></div>
  </div>
  <form class="form">
    <label for="format">Page size </label>
    <select id="format">
      <option value="a0">A0 (slow)</option>
      <option value="a1">A1</option>
      <option value="a2">A2</option>
      <option value="a3">A3</option>
      <option value="a4" selected>A4</option>
      <option value="a5">A5 (fast)</option>
    </select>
    <label for="resolution">Resolution </label>
    <select id="resolution">
      <option value="72">72 dpi (fast)</option>
      <option value="150">150 dpi</option>
      <option value="200" selected>200 dpi</option>
      <option value="300">300 dpi (slow)</option>
    </select>
    <label for="scale">Scale </label>
    <select id="scale">
      <option value="500">1:500000</option>
      <option value="250" selected>1:250000</option>
      <option value="100">1:100000</option>
      <option value="50">1:50000</option>
      <option value="25">1:25000</option>
      <option value="10">1:10000</option>
    </select>
  </form>
  <button id="export-pdf">Export PDF</button>
</template>

<script>
export default {
  mounted() {
    // import proj4 from 'proj4';
    let {
      format: { WMTSCapabilities },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: {
        WMTS: { optionsFromCapabilities },
      },
      control: { ScaleLine, defaults: defaultControls },
      proj: {
        getPointResolution,
        get: getProjection,
        proj4: { register },
      },
    } = ol

    proj4.defs(
      "EPSG:27700",
      "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 " +
        "+x_0=400000 +y_0=-100000 +ellps=airy " +
        "+towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 " +
        "+units=m +no_defs"
    )

    register(proj4)

    const proj27700 = getProjection("EPSG:27700")
    proj27700.setExtent([0, 0, 700000, 1300000])

    const raster = new TileLayer()

    const url =
      "https://tiles.arcgis.com/tiles/qHLhLQrcvEnxjtPr/arcgis/rest/services/OS_Open_Raster/MapServer/WMTS"
    fetch(url)
      .then(function (response) {
        return response.text()
      })
      .then(function (text) {
        const result = new WMTSCapabilities().read(text)
        const options = optionsFromCapabilities(result, {
          layer: "OS_Open_Raster",
        })
        options.attributions =
          "Contains OS data © Crown Copyright and database right " +
          new Date().getFullYear()
        options.crossOrigin = ""
        options.projection = proj27700
        options.wrapX = false
        raster.setSource(new WMTS(options))
      })

    const map = new Map({
      layers: [raster],
      controls: defaultControls({
        attributionOptions: { collapsible: false },
      }),
      target: this.$refs.map,
      view: new View({
        center: [373500, 436500],
        projection: proj27700,
        zoom: 7,
      }),
    })

    const scaleLine = new ScaleLine({ bar: true, text: true, minWidth: 125 })
    map.addControl(scaleLine)

    const dims = {
      a0: [1189, 841],
      a1: [841, 594],
      a2: [594, 420],
      a3: [420, 297],
      a4: [297, 210],
      a5: [210, 148],
    }

    // export options for html2canvase.
    // See: https://html2canvas.hertzen.com/configuration
    const exportOptions = {
      useCORS: true,
      ignoreElements: function (element) {
        const className = element.className || ""
        return !(
          className.indexOf("ol-control") === -1 ||
          className.indexOf("ol-scale") > -1 ||
          (className.indexOf("ol-attribution") > -1 &&
            className.indexOf("ol-uncollapsible"))
        )
      },
    }

    const exportButton = document.getElementById("export-pdf")

    exportButton.addEventListener(
      "click",
      function () {
        exportButton.disabled = true
        document.body.style.cursor = "progress"

        const format = document.getElementById("format").value
        const resolution = document.getElementById("resolution").value
        const scale = document.getElementById("scale").value
        const dim = dims[format]
        const width = Math.round((dim[0] * resolution) / 25.4)
        const height = Math.round((dim[1] * resolution) / 25.4)
        const viewResolution = map.getView().getResolution()
        const scaleResolution =
          scale /
          getPointResolution(
            map.getView().getProjection(),
            resolution / 25.4,
            map.getView().getCenter()
          )

        map.once("rendercomplete", function () {
          exportOptions.width = width
          exportOptions.height = height
          html2canvas(map.getViewport(), exportOptions).then(function (canvas) {
            const pdf = new jspdf.jsPDF("landscape", undefined, format)
            pdf.addImage(
              canvas.toDataURL("image/jpeg"),
              "JPEG",
              0,
              0,
              dim[0],
              dim[1]
            )
            pdf.save("map.pdf")
            // Reset original map size
            scaleLine.setDpi()
            map.getTargetElement().style.width = ""
            map.getTargetElement().style.height = ""
            map.updateSize()
            map.getView().setResolution(viewResolution)
            exportButton.disabled = false
            document.body.style.cursor = "auto"
          })
        })

        // Set print size
        scaleLine.setDpi(resolution)
        map.getTargetElement().style.width = width + "px"
        map.getTargetElement().style.height = height + "px"
        map.updateSize()
        map.getView().setResolution(scaleResolution)
      },
      false
    )
  },
}
</script>
```

:::

## 3.投影和规模

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div>
    <label for="view-projection">View projection</label>
    <select id="view-projection">
      <option value="EPSG:3857">Spherical Mercator (EPSG:3857)</option>
      <option value="EPSG:4326" selected>WGS 84 (EPSG:4326)</option>
    </select>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      control: { ScaleLine, defaults: defaultControls },
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
      proj: { getPointResolution, get: getProjection, transform },
    } = ol

    const viewProjSelect = document.getElementById("view-projection")
    const projection = getProjection(viewProjSelect.value)

    const scaleControl = new ScaleLine({
      units: "metric",
      bar: true,
      steps: 4,
      text: true,
      minWidth: 140,
    })

    const map = new Map({
      controls: defaultControls().extend([scaleControl]),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: transform([0, 52], "EPSG:4326", projection),
        zoom: 6,
        projection: projection,
      }),
    })

    function onChangeProjection() {
      const currentView = map.getView()
      const currentProjection = currentView.getProjection()
      const newProjection = getProjection(viewProjSelect.value)
      const currentResolution = currentView.getResolution()
      const currentCenter = currentView.getCenter()
      const currentRotation = currentView.getRotation()
      const newCenter = transform(
        currentCenter,
        currentProjection,
        newProjection
      )
      const currentPointResolution = getPointResolution(
        currentProjection,
        1,
        currentCenter,
        "m"
      )
      const newPointResolution = getPointResolution(
        newProjection,
        1,
        newCenter,
        "m"
      )
      const newResolution =
        (currentResolution * currentPointResolution) / newPointResolution
      const newView = new View({
        center: newCenter,
        resolution: newResolution,
        rotation: currentRotation,
        projection: newProjection,
      })
      map.setView(newView)
    }
    viewProjSelect.addEventListener("change", onChangeProjection)
  },
}
</script>
```

:::

## 4.光栅重新投影

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      tilegrid: { TileGrid },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: {
        WMTS: { optionsFromCapabilities },
        OSM,
        TileImage,
        TileWMS,
      },
      format: { WMTSCapabilities },
      proj: {
        get: getProjection,
        transformExtent,
        proj4: { register },
      },
      extent: { getCenter, getWidth },
    } = ol
    // import proj4 from 'proj4';
    proj4.defs(
      "EPSG:27700",
      "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 " +
        "+x_0=400000 +y_0=-100000 +ellps=airy " +
        "+towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 " +
        "+units=m +no_defs"
    )
    proj4.defs(
      "EPSG:23032",
      "+proj=utm +zone=32 +ellps=intl " +
        "+towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs"
    )
    proj4.defs(
      "EPSG:5479",
      "+proj=lcc +lat_1=-76.66666666666667 +lat_2=" +
        "-79.33333333333333 +lat_0=-78 +lon_0=163 +x_0=7000000 +y_0=5000000 " +
        "+ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
    )
    proj4.defs(
      "EPSG:21781",
      "+proj=somerc +lat_0=46.95240555555556 " +
        "+lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel " +
        "+towgs84=674.4,15.1,405.3,0,0,0,0 +units=m +no_defs"
    )
    proj4.defs(
      "EPSG:3413",
      "+proj=stere +lat_0=90 +lat_ts=70 +lon_0=-45 +k=1 " +
        "+x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs"
    )
    proj4.defs(
      "EPSG:2163",
      "+proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 " +
        "+a=6370997 +b=6370997 +units=m +no_defs"
    )
    proj4.defs(
      "ESRI:54009",
      "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 " + "+units=m +no_defs"
    )
    register(proj4)

    const proj27700 = getProjection("EPSG:27700")
    proj27700.setExtent([-650000, -150000, 1350000, 1450000])

    const proj23032 = getProjection("EPSG:23032")
    proj23032.setExtent([-1206118.71, 4021309.92, 1295389.0, 8051813.28])

    const proj5479 = getProjection("EPSG:5479")
    proj5479.setExtent([6825737.53, 4189159.8, 9633741.96, 5782472.71])

    const proj21781 = getProjection("EPSG:21781")
    proj21781.setExtent([485071.54, 75346.36, 828515.78, 299941.84])

    const proj3413 = getProjection("EPSG:3413")
    proj3413.setExtent([-4194304, -4194304, 4194304, 4194304])

    const proj2163 = getProjection("EPSG:2163")
    proj2163.setExtent([
      -8040784.5135, -2577524.921, 3668901.4484, 4785105.1096,
    ])

    const proj54009 = getProjection("ESRI:54009")
    proj54009.setExtent([-18e6, -9e6, 18e6, 9e6])

    const layers = {}

    layers["osm"] = new TileLayer({
      source: new OSM(),
    })

    layers["wms4326"] = new TileLayer({
      source: new TileWMS({
        url: "https://ahocevar.com/geoserver/wms",
        crossOrigin: "",
        params: {
          LAYERS: "ne:NE1_HR_LC_SR_W_DR",
          TILED: true,
        },
        projection: "EPSG:4326",
      }),
    })

    layers["wms21781"] = new TileLayer({
      source: new TileWMS({
        attributions:
          '© <a href="https://shop.swisstopo.admin.ch/en/products/maps/national/lk1000"' +
          'target="_blank">Pixelmap 1:1000000 / geo.admin.ch</a>',
        crossOrigin: "anonymous",
        params: {
          LAYERS: "ch.swisstopo.pixelkarte-farbe-pk1000.noscale",
          FORMAT: "image/jpeg",
        },
        url: "https://wms.geo.admin.ch/",
        projection: "EPSG:21781",
      }),
    })

    const parser = new WMTSCapabilities()

    layers["wmts3413"] = new TileLayer()
    const urlA =
      "https://map1.vis.earthdata.nasa.gov/wmts-arctic/" +
      "wmts.cgi?SERVICE=WMTS&request=GetCapabilities"
    fetch(urlA)
      .then(function (response) {
        return response.text()
      })
      .then(function (text) {
        const result = parser.read(text)
        const options = optionsFromCapabilities(result, {
          layer: "OSM_Land_Mask",
          matrixSet: "EPSG3413_250m",
        })
        options.crossOrigin = ""
        options.projection = "EPSG:3413"
        options.wrapX = false
        layers["wmts3413"].setSource(new WMTS(options))
      })

    layers["bng"] = new TileLayer()
    const urlB =
      "https://tiles.arcgis.com/tiles/qHLhLQrcvEnxjtPr/arcgis/rest/services/OS_Open_Raster/MapServer/WMTS"
    fetch(urlB)
      .then(function (response) {
        return response.text()
      })
      .then(function (text) {
        const result = parser.read(text)
        const options = optionsFromCapabilities(result, {
          layer: "OS_Open_Raster",
        })
        options.attributions =
          "Contains OS data © Crown Copyright and database right " +
          new Date().getFullYear()
        options.crossOrigin = ""
        options.projection = "EPSG:27700"
        options.wrapX = false
        layers["bng"].setSource(new WMTS(options))
      })

    const startResolution =
      getWidth(getProjection("EPSG:3857").getExtent()) / 256
    const resolutions = new Array(22)
    for (let i = 0, ii = resolutions.length; i < ii; ++i) {
      resolutions[i] = startResolution / Math.pow(2, i)
    }

    layers["states"] = new TileLayer({
      source: new TileWMS({
        url: "https://ahocevar.com/geoserver/wms",
        crossOrigin: "",
        params: { LAYERS: "topp:states" },
        serverType: "geoserver",
        tileGrid: new TileGrid({
          extent: [-13884991, 2870341, -7455066, 6338219],
          resolutions: resolutions,
          tileSize: [512, 256],
        }),
        projection: "EPSG:3857",
      }),
    })

    const map = new Map({
      layers: [layers["osm"], layers["bng"]],
      target: this.$refs.map,
      view: new View({
        projection: "EPSG:3857",
        center: [0, 0],
        zoom: 2,
      }),
    })

    const baseLayerSelect = document.getElementById("base-layer")
    const overlayLayerSelect = document.getElementById("overlay-layer")
    const viewProjSelect = document.getElementById("view-projection")
    const renderEdgesCheckbox = document.getElementById("render-edges")
    let renderEdges = false

    function updateViewProjection() {
      const newProj = getProjection(viewProjSelect.value)
      const newProjExtent = newProj.getExtent()
      const newView = new View({
        projection: newProj,
        center: getCenter(newProjExtent || [0, 0, 0, 0]),
        zoom: 0,
        extent: newProjExtent || undefined,
      })
      map.setView(newView)

      // Example how to prevent double occurrence of map by limiting layer extent
      if (newProj.isGlobal()) {
        layers["bng"].setExtent(
          transformExtent(proj27700.getExtent(), proj27700, newProj, 2)
        )
      } else {
        layers["bng"].setExtent(undefined)
      }
    }

    /**
     * Handle change event.
     */
    viewProjSelect.onchange = function () {
      updateViewProjection()
    }

    updateViewProjection()

    const updateRenderEdgesOnLayer = function (layer) {
      if (layer instanceof TileLayer) {
        const source = layer.getSource()
        if (source instanceof TileImage) {
          source.setRenderReprojectionEdges(renderEdges)
        }
      }
    }

    /**
     * Handle change event.
     */
    baseLayerSelect.onchange = function () {
      const layer = layers[baseLayerSelect.value]
      if (layer) {
        layer.setOpacity(1)
        updateRenderEdgesOnLayer(layer)
        map.getLayers().setAt(0, layer)
      }
    }

    /**
     * Handle change event.
     */
    overlayLayerSelect.onchange = function () {
      const layer = layers[overlayLayerSelect.value]
      if (layer) {
        layer.setOpacity(0.7)
        updateRenderEdgesOnLayer(layer)
        map.getLayers().setAt(1, layer)
      }
    }

    /**
     * Handle change event.
     */
    renderEdgesCheckbox.onchange = function () {
      renderEdges = renderEdgesCheckbox.checked
      map.getLayers().forEach(function (layer) {
        updateRenderEdgesOnLayer(layer)
      })
    }
  },
}
</script>
```

:::

## 5.光栅源

:::demo

```vue
<template>
  <div class="rel">
    <div ref="map" class="map"></div>
    <div id="plot"></div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer, Image: ImageLayer },
      source: { XYZ, Raster: RasterSource },
    } = ol

    const minVgi = 0
    const maxVgi = 0.5
    const bins = 10

    /**
     * Calculate the Vegetation Greenness Index (VGI) from an input pixel.  This
     * is a rough estimate assuming that pixel values correspond to reflectance.
     * @param {Array<number>} pixel An array of [R, G, B, A] values.
     * @return {number} The VGI value for the given pixel.
     */
    function vgi(pixel) {
      const r = pixel[0] / 255
      const g = pixel[1] / 255
      const b = pixel[2] / 255
      return (2 * g - r - b) / (2 * g + r + b)
    }

    /**
     * Summarize values for a histogram.
     * @param {numver} value A VGI value.
     * @param {Object} counts An object for keeping track of VGI counts.
     */
    function summarize(value, counts) {
      const min = counts.min
      const max = counts.max
      const num = counts.values.length
      if (value < min) {
        // do nothing
      } else if (value >= max) {
        counts.values[num - 1] += 1
      } else {
        const index = Math.floor((value - min) / counts.delta)
        counts.values[index] += 1
      }
    }

    /**
     * Use aerial imagery as the input data for the raster source.
     */

    const key = "Get your own API key at https://www.maptiler.com/cloud/"
    const attributions =
      '<a href="https://www.maptiler.com/copyright/" target="_blank">&copy; MapTiler</a> ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'

    const aerial = new XYZ({
      attributions: attributions,
      url:
        "https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=" + key,
      maxZoom: 20,
      crossOrigin: "",
    })

    /**
     * Create a raster source where pixels with VGI values above a threshold will
     * be colored green.
     */
    const raster = new RasterSource({
      sources: [aerial],
      /**
       * Run calculations on pixel data.
       * @param {Array} pixels List of pixels (one per source).
       * @param {Object} data User data object.
       * @return {Array} The output pixel.
       */
      operation: function (pixels, data) {
        const pixel = pixels[0]
        const value = vgi(pixel)
        summarize(value, data.counts)
        if (value >= data.threshold) {
          pixel[0] = 0
          pixel[1] = 255
          pixel[2] = 0
          pixel[3] = 128
        } else {
          pixel[3] = 0
        }
        return pixel
      },
      lib: {
        vgi: vgi,
        summarize: summarize,
      },
    })
    raster.set("threshold", 0.25)

    function createCounts(min, max, num) {
      const values = new Array(num)
      for (let i = 0; i < num; ++i) {
        values[i] = 0
      }
      return {
        min: min,
        max: max,
        values: values,
        delta: (max - min) / num,
      }
    }

    raster.on("beforeoperations", function (event) {
      event.data.counts = createCounts(minVgi, maxVgi, bins)
      event.data.threshold = raster.get("threshold")
    })

    raster.on("afteroperations", function (event) {
      schedulePlot(event.resolution, event.data.counts, event.data.threshold)
    })

    const map = new Map({
      layers: [
        new TileLayer({
          source: aerial,
        }),
        new ImageLayer({
          source: raster,
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [-9651695, 4937351],
        zoom: 13,
        minZoom: 12,
        maxZoom: 19,
      }),
    })

    let timer = null
    function schedulePlot(resolution, counts, threshold) {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
      timer = setTimeout(
        plot.bind(null, resolution, counts, threshold),
        1000 / 60
      )
    }

    const barWidth = 15
    const plotHeight = 150
    const chart = d3
      .select("#plot")
      .append("svg")
      .attr("width", barWidth * bins)
      .attr("height", plotHeight)

    const chartRect = chart.node().getBoundingClientRect()

    const tip = d3.select(document.body).append("div").attr("class", "tip")

    function plot(resolution, counts, threshold) {
      const yScale = d3
        .scaleLinear()
        .domain([0, d3.max(counts.values)])
        .range([0, plotHeight])

      const bar = chart.selectAll("rect").data(counts.values)

      bar.enter().append("rect")

      bar
        .attr("class", function (count, index) {
          const value = counts.min + index * counts.delta
          return "bar" + (value >= threshold ? " selected" : "")
        })
        .attr("width", barWidth - 2)

      bar
        .transition()
        .attr("transform", function (value, index) {
          return (
            "translate(" +
            index * barWidth +
            ", " +
            (plotHeight - yScale(value)) +
            ")"
          )
        })
        .attr("height", yScale)

      bar.on("mousemove", function () {
        const index = bar.nodes().indexOf(this)
        const threshold = counts.min + index * counts.delta
        if (raster.get("threshold") !== threshold) {
          raster.set("threshold", threshold)
          raster.changed()
        }
      })

      bar.on("mouseover", function (event) {
        const index = bar.nodes().indexOf(this)
        let area = 0
        for (let i = counts.values.length - 1; i >= index; --i) {
          area += resolution * resolution * counts.values[i]
        }
        tip.html(message(counts.min + index * counts.delta, area))
        tip.style("display", "block")
        tip
          .transition()
          .style(
            "left",
            chartRect.left + index * barWidth + barWidth / 2 + "px"
          )
          .style("top", event.y - 60 + "px")
          .style("opacity", 1)
      })

      bar.on("mouseout", function () {
        tip
          .transition()
          .style("opacity", 0)
          .on("end", function () {
            tip.style("display", "none")
          })
      })
    }

    function message(value, area) {
      const acres = (area / 4046.86)
        .toFixed(0)
        .replace(/\B(?=(\d{3})+(?!\d))/g, ",")
      return acres + " acres at<br>" + value.toFixed(2) + " VGI or above"
    }
  },
}
</script>
```

:::
