---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 四.案例 4

## 1.垄断一体化

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      control: { MousePosition },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: { Circle: CircleStyle, Fill, Stroke, Style, Text },
      interaction: { Draw, Snap },
      geom: { LineString, Point, Polygon },
    } = ol
    const raster = new TileLayer({
      source: new OSM(),
    })
    const nodes = new VectorSource({ wrapX: false })
    const nodesLayer = new VectorLayer({
      source: nodes,
      style: function (f) {
        const style = new Style({
          image: new CircleStyle({
            radius: 8,
            fill: new Fill({ color: "rgba(255, 0, 0, 0.2)" }),
            stroke: new Stroke({ color: "red", width: 1 }),
          }),
          text: new Text({
            text: f.get("node").id.toString(),
            fill: new Fill({ color: "red" }),
            stroke: new Stroke({
              color: "white",
              width: 3,
            }),
          }),
        })
        return [style]
      },
    })
    const edges = new VectorSource({ wrapX: false })
    const edgesLayer = new VectorLayer({
      source: edges,
      style: function (f) {
        const style = new Style({
          stroke: new Stroke({
            color: "blue",
            width: 1,
          }),
          text: new Text({
            text: f.get("edge").id.toString(),
            fill: new Fill({ color: "blue" }),
            stroke: new Stroke({
              color: "white",
              width: 2,
            }),
          }),
        })
        return [style]
      },
    })
    const faces = new VectorSource({ wrapX: false })
    const facesLayer = new VectorLayer({
      source: faces,
      style: function (f) {
        const style = new Style({
          stroke: new Stroke({
            color: "black",
            width: 1,
          }),
          fill: new Fill({
            color: "rgba(0, 255, 0, 0.2)",
          }),
          text: new Text({
            font: "bold 12px sans-serif",
            text: f.get("face").id.toString(),
            fill: new Fill({ color: "green" }),
            stroke: new Stroke({
              color: "white",
              width: 2,
            }),
          }),
        })
        return [style]
      },
    })
    const map = new Map({
      layers: [raster, facesLayer, edgesLayer, nodesLayer],
      target: this.$refs.map,
      view: new View({
        center: [-11000000, 4600000],
        zoom: 16,
      }),
    })
    const topo = topolis.createTopology()
    topo.on("addnode", nodeToFeature)
    topo.on("removenode", function (e) {
      removeElementFeature(nodes, e)
    })
    topo.on("addedge", edgeToFeature)
    topo.on("modedge", function (e) {
      const feature = edges.getFeatureById(e.id)
      feature.setGeometry(new LineString(e.coordinates))
    })
    topo.on("removeedge", function (e) {
      removeElementFeature(edges, e)
    })
    topo.on("addface", faceToFeature)
    topo.on("removeface", function (e) {
      removeElementFeature(faces, e)
    })
    function removeElementFeature(source, element) {
      const feature = source.getFeatureById(element.id)
      source.removeFeature(feature)
    }
    function nodeToFeature(node) {
      const feature = new Feature({
        geometry: new Point(node.coordinate),
        node: node,
      })
      feature.setId(node.id)
      nodes.addFeature(feature)
    }
    function edgeToFeature(edge) {
      const feature = new Feature({
        geometry: new LineString(edge.coordinates),
        edge: edge,
      })
      feature.setId(edge.id)
      edges.addFeature(feature)
    }
    function faceToFeature(face) {
      const coordinates = topo.getFaceGeometry(face)
      const feature = new Feature({
        geometry: new Polygon(coordinates),
        face: face,
      })
      feature.setId(face.id)
      faces.addFeature(feature)
    }
    function createNode(topo, coord) {
      let node
      const existingEdge = topo.getEdgeByPoint(coord, 5)[0]
      if (existingEdge) {
        node = topo.modEdgeSplit(existingEdge, coord)
      } else {
        node = topo.addIsoNode(coord)
      }
      return node
    }
    function onDrawend(e) {
      const edgeGeom = e.feature.getGeometry().getCoordinates()
      const startCoord = edgeGeom[0]
      const endCoord = edgeGeom[edgeGeom.length - 1]
      let start, end
      try {
        start = topo.getNodeByPoint(startCoord)
        end = topo.getNodeByPoint(endCoord)
        const edgesAtStart = topo.getEdgeByPoint(startCoord, 5)
        const edgesAtEnd = topo.getEdgeByPoint(endCoord, 5)
        const crossing = topo.getEdgesByLine(edgeGeom)
        if (
          crossing.length === 1 &&
          !start &&
          !end &&
          edgesAtStart.length === 0 &&
          edgesAtEnd.length === 0
        ) {
          topo.remEdgeNewFace(crossing[0])
          start = crossing[0].start
          if (start.face) {
            topo.removeIsoNode(start)
          }
          end = crossing[0].end
          if (end.face) {
            topo.removeIsoNode(end)
          }
          return
        }
        if (!start) {
          start = createNode(topo, startCoord)
          edgeGeom[0] = start.coordinate
        }
        if (!end) {
          end = createNode(topo, endCoord)
          edgeGeom[edgeGeom.length - 1] = end.coordinate
        }
        topo.addEdgeNewFaces(start, end, edgeGeom)
      } catch (e) {
        toastr.warning(e.toString())
      }
    }
    const draw = new Draw({
      type: "LineString",
    })
    draw.on("drawend", onDrawend)
    map.addInteraction(draw)
    const snap = new Snap({
      source: edges,
    })
    map.addInteraction(snap)
    map.addControl(new MousePosition())
  },
}
</script>
```

:::

## 4.turf.js

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      proj: { fromLonLat },
    } = ol
    const source = new VectorSource()
    fetch(this.$withBase("/data/geojson/roads-seoul.geojson"))
      .then(function (response) {
        return response.json()
      })
      .then(function (json) {
        const format = new GeoJSON()
        const features = format.readFeatures(json)
        const street = features[0]

        // convert to a turf.js feature
        const turfLine = format.writeFeatureObject(street)

        // show a marker every 200 meters
        const distance = 0.2

        // get the line length in kilometers
        const length = turf.lineDistance(turfLine, "kilometers")
        for (let i = 1; i <= length / distance; i++) {
          const turfPoint = turf.along(turfLine, i * distance, "kilometers")

          // convert the generated point to a OpenLayers feature
          const marker = format.readFeature(turfPoint)
          marker.getGeometry().transform("EPSG:4326", "EPSG:3857")
          source.addFeature(marker)
        }

        street.getGeometry().transform("EPSG:4326", "EPSG:3857")
        source.addFeature(street)
      })
    const vectorLayer = new VectorLayer({
      source: source,
    })

    const rasterLayer = new TileLayer({
      source: new OSM(),
    })

    const map = new Map({
      layers: [rasterLayer, vectorLayer],
      target: document.getElementById("map"),
      view: new View({
        center: fromLonLat([126.980366, 37.52654]),
        zoom: 15,
      }),
    })
  },
}
</script>
```

:::

## 5.UTFGrid

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
  <div style="display: none;">
    <div id="country-info">
      <div id="country-name">&nbsp;</div>
      <img id="country-flag" />
    </div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Overlay,
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { TileJSON, UTFGrid },
    } = ol

    const mapLayer = new TileLayer({
      source: new TileJSON({
        url:
          "https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=" +
          mapkeys.mapbox,
      }),
    })

    const gridSource = new UTFGrid({
      url:
        "https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=" +
        mapkeys.mapbox,
    })

    const gridLayer = new TileLayer({ source: gridSource })

    const view = new View({
      center: [12579156, 3274244],
      zoom: 1,
    })

    const mapElement = document.getElementById("map")
    const map = new Map({
      layers: [mapLayer, gridLayer],
      target: mapElement,
      view: view,
    })

    const infoElement = document.getElementById("country-info")
    const flagElement = document.getElementById("country-flag")
    const nameElement = document.getElementById("country-name")

    const infoOverlay = new Overlay({
      element: infoElement,
      offset: [15, 15],
      stopEvent: false,
    })
    map.addOverlay(infoOverlay)

    const displayCountryInfo = function (coordinate) {
      const viewResolution = /** @type {number} */ (view.getResolution())
      gridSource.forDataAtCoordinateAndResolution(
        coordinate,
        viewResolution,
        function (data) {
          // If you want to use the template from the TileJSON,
          //  load the mustache.js library separately and call
          //  info.innerHTML = Mustache.render(gridSource.getTemplate(), data);
          mapElement.style.cursor = data ? "pointer" : ""
          if (data) {
            flagElement.src = "data:image/png;base64," + data["flag_png"]
            nameElement.innerHTML = data["admin"]
          }
          infoOverlay.setPosition(data ? coordinate : undefined)
        }
      )
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const coordinate = map.getEventCoordinate(evt.originalEvent)
      displayCountryInfo(coordinate)
    })

    map.on("click", function (evt) {
      displayCountryInfo(evt.coordinate)
    })
  },
}
</script>
```

:::
