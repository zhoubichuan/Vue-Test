---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 二.案例4

## 1.自定义圆圈渲染

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Circle },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: Style,
    } = ol

    const circleFeature = new Feature({
      geometry: new Circle([12127398.797692968, 4063894.123105166], 50),
    })
    circleFeature.setStyle(
      new Style({
        renderer(coordinates, state) {
          const [[x, y], [x1, y1]] = coordinates
          const ctx = state.context
          const dx = x1 - x
          const dy = y1 - y
          const radius = Math.sqrt(dx * dx + dy * dy)

          const innerRadius = 0
          const outerRadius = radius * 1.4

          const gradient = ctx.createRadialGradient(
            x,
            y,
            innerRadius,
            x,
            y,
            outerRadius
          )
          gradient.addColorStop(0, "rgba(255,0,0,0)")
          gradient.addColorStop(0.6, "rgba(255,0,0,0.2)")
          gradient.addColorStop(1, "rgba(255,0,0,0.8)")
          ctx.beginPath()
          ctx.arc(x, y, radius, 0, 2 * Math.PI, true)
          ctx.fillStyle = gradient
          ctx.fill()

          ctx.arc(x, y, radius, 0, 2 * Math.PI, true)
          ctx.strokeStyle = "rgba(255,0,0,1)"
          ctx.stroke()
        },
      })
    )

    new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
          visible: true,
        }),
        new VectorLayer({
          source: new VectorSource({
            features: [circleFeature],
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: [12127398.797692968, 4063894.123105166],
        zoom: 19,
      }),
    })
  },
}
</script>
```

:::

## 3.自定义拖放（KMZ）

:::demo

```vue
<template>
  <div>
    <div ref="map" class="map"></div>
    <br />
    <div>
      <a id="download" download></a>
      <button id="download-kmz">Download sample</button>
    </div>
    <br />
    <div id="info">&nbsp;</div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GPX, GeoJSON, IGC, KML, TopoJSON },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      interaction: { DragAndDrop, defaults: defaultInteractions },
    } = ol
    const zip = new JSZip()

    function getKMLData(buffer) {
      let kmlData
      zip.load(buffer)
      const kmlFile = zip.file(/.kml$/i)[0]
      if (kmlFile) {
        kmlData = kmlFile.asText()
      }
      return kmlData
    }

    function getKMLImage(href) {
      let url = href
      let path = window.location.href
      path = path.slice(0, path.lastIndexOf("/") + 1)
      if (href.indexOf(path) === 0) {
        const regexp = new RegExp(href.replace(path, "") + "$", "i")
        const kmlFile = zip.file(regexp)[0]
        if (kmlFile) {
          url = URL.createObjectURL(new Blob([kmlFile.asArrayBuffer()]))
        }
      }
      return url
    }

    // Define a KMZ format class by subclassing ol/format/KML

    class KMZ extends KML {
      constructor(opt_options) {
        const options = opt_options || {}
        options.iconUrlFunction = getKMLImage
        super(options)
      }

      getType() {
        return "arraybuffer"
      }

      readFeature(source, options) {
        const kmlData = getKMLData(source)
        return super.readFeature(kmlData, options)
      }

      readFeatures(source, options) {
        const kmlData = getKMLData(source)
        return super.readFeatures(kmlData, options)
      }
    }

    // Set up map with Drag and Drop interaction

    const dragAndDropInteraction = new DragAndDrop({
      formatConstructors: [KMZ, GPX, GeoJSON, IGC, KML, TopoJSON],
    })

    const map = new Map({
      interactions: defaultInteractions().extend([dragAndDropInteraction]),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    dragAndDropInteraction.on("addfeatures", function (event) {
      const vectorSource = new VectorSource({
        features: event.features,
      })
      map.addLayer(
        new VectorLayer({
          source: vectorSource,
        })
      )
      map.getView().fit(vectorSource.getExtent())
    })

    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          const description =
            features[i].get("description") ||
            features[i].get("name") ||
            features[i].get("_name") ||
            features[i].get("layer")
          if (description) {
            info.push(description)
          }
        }
        document.getElementById("info").innerHTML =
          info.join("<br/>") || "&nbsp"
      } else {
        document.getElementById("info").innerHTML = "&nbsp;"
      }
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })

    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })

    // Sample data download

    const link = document.getElementById("download")

    function download(fullpath, filename) {
      fetch(fullpath)
        .then(function (response) {
          return response.blob()
        })
        .then(function (blob) {
          if (navigator.msSaveBlob) {
            // link download attribute does not work on MS browsers
            navigator.msSaveBlob(blob, filename)
          } else {
            link.href = URL.createObjectURL(blob)
            link.download = filename
            link.click()
          }
        })
    }

    document
      .getElementById("download-kmz")
      .addEventListener("click", function () {
        download("data/kmz/iceland.kmz", "iceland.kmz")
      })
  },
}
</script>
```

:::

## 4.自定义拖放（MVT 预览）

:::demo

```vue
<template>
  <div>
    <div id="map" class="map"></div>
    <br />
    <div class="tileCoord">
      <a id="download" download></a>
      <span>Tile coordinate&nbsp;&nbsp;</span>
      <span>&nbsp;z: <input type="number" id="tileCoordZ" value="6" /></span>
      <span>&nbsp;x: <input type="number" id="tileCoordX" value="30" /></span>
      <span>&nbsp;y: <input type="number" id="tileCoordY" value="20" /></span>
      <span>&nbsp;&nbsp;</span>
      <button id="download-mvt">Download sample</button>
    </div>
    <br />
    <div id="info">&nbsp;</div>
  </div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      format: { GPX, GeoJSON, IGC, KML, MVT, TopoJSON },
      Map,
      View,
      interaction: { DragAndDrop, defaults: defaultInteractions },
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      tilegrid: { createXYZ },
    } = ol
    const tileCoordZ = document.getElementById("tileCoordZ")
    const tileCoordX = document.getElementById("tileCoordX")
    const tileCoordY = document.getElementById("tileCoordY")

    class customMVT extends MVT {
      constructor() {
        super({ featureClass: Feature })
      }
      readFeatures(source, options) {
        options.extent = createXYZ().getTileCoordExtent([
          parseInt(tileCoordZ.value),
          parseInt(tileCoordX.value),
          parseInt(tileCoordY.value),
        ])
        return super.readFeatures(source, options)
      }
    }

    // Set up map with Drag and Drop interaction

    const dragAndDropInteraction = new DragAndDrop({
      formatConstructors: [customMVT, GPX, GeoJSON, IGC, KML, TopoJSON],
    })

    const map = new Map({
      interactions: defaultInteractions().extend([dragAndDropInteraction]),
      layers: [
        new TileLayer({
          source: new OSM(),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center:[12579156, 3274244],
        zoom: 2,
      }),
    })

    dragAndDropInteraction.on("addfeatures", function (event) {
      const vectorSource = new VectorSource({
        features: event.features,
      })
      map.addLayer(
        new VectorLayer({
          source: vectorSource,
        })
      )
      map.getView().fit(vectorSource.getExtent())
    })

    const displayFeatureInfo = function (pixel) {
      const features = []
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature)
      })
      if (features.length > 0) {
        const info = []
        let i, ii
        for (i = 0, ii = features.length; i < ii; ++i) {
          const description =
            features[i].get("name") ||
            features[i].get("_name") ||
            features[i].get("layer")
          if (description) {
            info.push(description)
          }
        }
        document.getElementById("info").innerHTML = info.join(", ") || "&nbsp"
      } else {
        document.getElementById("info").innerHTML = "&nbsp;"
      }
    }

    map.on("pointermove", function (evt) {
      if (evt.dragging) {
        return
      }
      const pixel = map.getEventPixel(evt.originalEvent)
      displayFeatureInfo(pixel)
    })

    map.on("click", function (evt) {
      displayFeatureInfo(evt.pixel)
    })

    // Sample data download

    const link = document.getElementById("download")

    function download(fullpath, filename) {
      fetch(fullpath)
        .then(function (response) {
          return response.blob()
        })
        .then(function (blob) {
          if (navigator.msSaveBlob) {
            // link download attribute does not work on MS browsers
            navigator.msSaveBlob(blob, filename)
          } else {
            link.href = URL.createObjectURL(blob)
            link.download = filename
            link.click()
          }
        })
    }

    document
      .getElementById("download-mvt")
      .addEventListener("click", function () {
        const fullpath =
          "https://basemaps.arcgis.com/v1/arcgis/rest/services/World_Basemap/VectorTileServer/tile/" +
          tileCoordZ.value +
          "/" +
          tileCoordY.value +
          "/" +
          tileCoordX.value +
          ".pbf"
        const filename =
          tileCoordZ.value +
          "-" +
          tileCoordX.value +
          "-" +
          tileCoordY.value +
          ".mvt"
        download(fullpath, filename)
      })
  },
}
</script>
```

:::

## 5.自定义命中检测渲染

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Feature,
      geom: { Circle },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      style: Style,
      proj: { fromLonLat },
    } = ol
    const columbusCircleCoords = fromLonLat([-73.98189, 40.76805])
    const labelTextStroke = "rgba(120, 120, 120, 1)"
    const labelText = "Columbus Circle"

    let pointerOverFeature = null

    const renderLabelText = (ctx, x, y, stroke) => {
      ctx.fillStyle = "rgba(255,0,0,1)"
      ctx.strokeStyle = stroke
      ctx.lineWidth = 1
      ctx.textAlign = "center"
      ctx.textBaseline = "middle"
      ctx.font = `bold 30px verdana`
      ctx.filter = "drop-shadow(7px 7px 2px #e81)"
      ctx.fillText(labelText, x, y)
      ctx.strokeText(labelText, x, y)
    }

    const circleFeature = new Feature({
      geometry: new Circle(columbusCircleCoords, 50),
    })

    circleFeature.set("label-color", labelTextStroke)

    circleFeature.setStyle(
      new Style({
        renderer(coordinates, state) {
          const [[x, y], [x1, y1]] = coordinates
          const ctx = state.context
          const dx = x1 - x
          const dy = y1 - y
          const radius = Math.sqrt(dx * dx + dy * dy)

          const innerRadius = 0
          const outerRadius = radius * 1.4

          const gradient = ctx.createRadialGradient(
            x,
            y,
            innerRadius,
            x,
            y,
            outerRadius
          )
          gradient.addColorStop(0, "rgba(255,0,0,0)")
          gradient.addColorStop(0.6, "rgba(255,0,0,0.2)")
          gradient.addColorStop(1, "rgba(255,0,0,0.8)")
          ctx.beginPath()
          ctx.arc(x, y, radius, 0, 2 * Math.PI, true)
          ctx.fillStyle = gradient
          ctx.fill()
          ctx.strokeStyle = "rgba(255,0,0,1)"
          ctx.stroke()

          renderLabelText(ctx, x, y, circleFeature.get("label-color"))
        },
        hitDetectionRenderer(coordinates, state) {
          const [x, y] = coordinates[0]
          const ctx = state.context
          renderLabelText(ctx, x, y, circleFeature.get("label-color"))
        },
      })
    )

    const map = new Map({
      layers: [
        new TileLayer({
          source: new OSM(),
          visible: true,
        }),
        new VectorLayer({
          source: new VectorSource({
            features: [circleFeature],
          }),
        }),
      ],
      target: this.$refs.map,
      view: new View({
        center: columbusCircleCoords,
        zoom: 19,
      }),
    })

    map.on("pointermove", (evt) => {
      const featureOver = map.forEachFeatureAtPixel(evt.pixel, (feature) => {
        feature.set("label-color", "rgba(255,255,255,1)")
        return feature
      })

      if (pointerOverFeature && pointerOverFeature != featureOver) {
        pointerOverFeature.set("label-color", labelTextStroke)
      }
      pointerOverFeature = featureOver
    })
  },
}
</script>
```

:::
