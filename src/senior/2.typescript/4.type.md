---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的openlayers学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 四.案例 4

## 3.JSTS 集成

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      format: { GeoJSON },
      geom: {
        LinearRing,
        LineString,
        MultiLineString,
        MultiPoint,
        MultiPolygon,
        Point,
        Polygon,
      },
      Map,
      View,
      layer: { Tile: TileLayer, Vector: VectorLayer },
      source: { OSM, Vector: VectorSource },
      proj: { fromLonLat },
    } = ol
    const source = new VectorSource()
    fetch(this.$withBase("/data/geojson/roads-seoul.geojson"))
      .then(function (response) {
        return response.json()
      })
      .then(function (json) {
        const format = new GeoJSON()
        const features = format.readFeatures(json, {
          featureProjection: "EPSG:3857",
        })
        const parser = new jsts.io.OL3Parser()
        parser.inject(
          Point,
          LineString,
          LinearRing,
          Polygon,
          MultiPoint,
          MultiLineString,
          MultiPolygon
        )
        for (let i = 0; i < features.length; i++) {
          const feature = features[i]
          const jstsGeom = parser.read(feature.getGeometry())
          const buffered = jstsGeom.buffer(40)
          feature.setGeometry(parser.write(buffered))
        }
        source.addFeatures(features)
      })
    const vectorLayer = new VectorLayer({
      source: source,
    })
    const rasterLayer = new TileLayer({
      source: new OSM(),
    })
    const map = new Map({
      layers: [rasterLayer, vectorLayer],
      target: this.$refs.map,
      view: new View({
        center: fromLonLat([126.979293, 37.528787]),
        zoom: 15,
      }),
    })
  },
}
</script>
```

:::

## 5.分层裁剪

:::demo

```vue
<template>
  <div ref="map" class="map"></div>
</template>

<script>
export default {
  mounted() {
    let {
      Map,
      View,
      layer: { Tile: TileLayer },
      source: { OSM },
    } = ol

    const osm = new TileLayer({
      source: new OSM(),
    })

    const map = new Map({
      layers: [osm],
      target: this.$refs.map,
      view: new View({
        center: [12579156, 3274244],
        zoom: 2,
      }),
    })

    osm.on("prerender", function (event) {
      const ctx = event.context
      const matrix = event.inversePixelTransform
      const canvasPixelRatio = Math.sqrt(
        matrix[0] * matrix[0] + matrix[1] * matrix[1]
      )
      const canvasRotation = -Math.atan2(matrix[1], matrix[0])
      ctx.save()
      ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2)
      ctx.rotate(-canvasRotation)
      ctx.scale(3 * canvasPixelRatio, 3 * canvasPixelRatio)
      ctx.translate(-75, -80)
      ctx.beginPath()
      ctx.moveTo(75, 40)
      ctx.bezierCurveTo(75, 37, 70, 25, 50, 25)
      ctx.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5)
      ctx.bezierCurveTo(20, 80, 40, 102, 75, 120)
      ctx.bezierCurveTo(110, 102, 130, 80, 130, 62.5)
      ctx.bezierCurveTo(130, 62.5, 130, 25, 100, 25)
      ctx.bezierCurveTo(85, 25, 75, 37, 75, 40)
      ctx.clip()
      ctx.translate(75, 80)
      ctx.scale(1 / 3 / canvasPixelRatio, 1 / 3 / canvasPixelRatio)
      ctx.rotate(canvasRotation)
      ctx.translate(-ctx.canvas.width / 2, -ctx.canvas.height / 2)
    })

    osm.on("postrender", function (event) {
      const ctx = event.context
      ctx.restore()
    })
  },
}
</script>
```

:::
